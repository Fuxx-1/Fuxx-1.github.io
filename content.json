{"meta":{"title":"Fuxxの博客","subtitle":"永远相信美好的事情即将发生","description":"Fuxx-1","author":"Fuxx-1","url":"https://blog.newimg.ltd","root":"/"},"pages":[{"title":"关于新生","date":"2023-09-16T15:51:01.735Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"Newer/index.html","permalink":"https://blog.newimg.ltd/Newer/index.html","excerpt":"","text":"Github提交情况Github提交情况 第一次考核题目第一次考核题目"},{"title":"新生Github提交情况","date":"2023-09-16T15:51:01.735Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"Newer/新生Github提交情况.html","permalink":"https://blog.newimg.ltd/Newer/%E6%96%B0%E7%94%9FGithub%E6%8F%90%E4%BA%A4%E6%83%85%E5%86%B5.html","excerpt":"该内容仅供参考，接口可能出现延迟或弃用 Information","text":"该内容仅供参考，接口可能出现延迟或弃用 Information triumphdynapwwwmsrry1"},{"title":"第一次考核题目","date":"2023-09-16T15:51:01.735Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"Newer/第一次考核题目.html","permalink":"https://blog.newimg.ltd/Newer/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%80%83%E6%A0%B8%E9%A2%98%E7%9B%AE.html","excerpt":"","text":"一、链表题目1、创建链表(30point)题目描述根据输入创建单链表并遍历输出 节点中仅包含一个int型的val和next指针 输入链表元素的数量n 链表的n个元素 输出遍历链表 样例 样例 样例输入15 1 2 3 4 5样例输出11 2 3 4 5样例输入24 435 132 678 1223样例输出2435 132 678 1223 2、向单链表指定位置插入n个元素(30point)题目描述根据输入创建单链表并在指定节点后插入输入的数据 节点中仅包含一个int型的val和next指针 注意考虑插入链表的元素数量是否过大 输入链表元素的数量n、插入链表的第index值和插入链表的元素数量m 链表的n个元素 插入链表的m个元素 输出遍历链表 样例 样例 样例输入15 2 1 1 2 3 4 5 3样例输出11 3 3 4 5样例输入24 3 3 435 132 678 1223 1 2 3样例输出2435 132 1 2 3 二、算法题目1、日期计算(40point)题目描述输入日期1和该日期的星期数,根据输入计算日期2的星期数 大小月: 大月有1月、3月、5月、7月、8月、10月和12月; 小月有4月6月9月和11月。 闰年判断: 普通闰年：公历年份是4的倍数，且不是100的倍数的，为闰年（如2004年、2020年等就是闰年）。 世纪闰年：公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是闰年，2000年是闰年）。 输入日期1、日期1的星期数和日期2 输出日期2的星期数 样例 样例 样例输入12021-12-09 4 2021-12-22样例输出1星期三样例输入22021-09-01 3 2019-01-01样例输出2星期二"},{"title":"About me","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":false,"path":"about/index.html","permalink":"https://blog.newimg.ltd/about/index.html","excerpt":"","text":"我目前大三，希望能和各位大佬多多学习😁。 基础信息Github：Fuxx-1邮箱：fuxuxiang@qq.com下面是我的Contributions： 409ba5 希望拥有的专业技能GolangJava中间件协议部分LinuxCFrontEnd······ 基础 网络 基础 Web JUC 底层原理 MyBatis SSM SpringBoot JavaWeb SpringCloud MySQL Redis KafKa HTTP WebSocket 基础 进阶 进阶 网络 HTML&#x2F;HTML5 CSS&#x2F;CSS3 JavaScript ······ 我的话因为我自己目前对 Java 的理解有限，这个博客仅记录一些自己的理解，借鉴了一些大佬的创意，欢迎讨论。"},{"title":"所有分类","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"categories/index.html","permalink":"https://blog.newimg.ltd/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/test.html","permalink":"https://blog.newimg.ltd/custom/test.html","excerpt":"","text":"Document"},{"title":"我的朋友们","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"friends/index.html","permalink":"https://blog.newimg.ltd/friends/index.html","excerpt":"","text":""},{"title":"热度排行","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"hot/index.html","permalink":"https://blog.newimg.ltd/hot/index.html","excerpt":"","text":"AV.initialize(\"h3tIB2qbjXY5drW5YPWukzq9-gzGzoHsz\", \"dBV0MUqkcaL9TBlq0XVEPL94\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('times'); query.find().then(function (todo) { for (var i = 0; i < todo.length; i++){ var result=todo[i].attributes; time=result.times; title=result.title; url=result.url; var content=\"\"+\"\"+\"【文章阅读量:\"+time+\"】\"+\"\"+\"\"+title+\"\"+\"\"; if (result.xid != 1) { document.getElementById(\"hot\").innerHTML+=content; } } }, function (error) { console.log(\"error\"); });"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/autoload.js","permalink":"https://blog.newimg.ltd/live2d-widget/autoload.js","excerpt":"","text":"// 注意：live2d_path 参数应使用绝对路径 const live2d_path = \"/live2d-widget/\"; //const live2d_path = \"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", //apiPath: \"https://live2d.fghrsh.net/api/\", cdnPath: \"https://cdn.jsdelivr.net/gh/fghrsh/live2d_api/\" }); }); } // initWidget 第一个参数为 waifu-tips.json 的路径，第二个参数为 API 地址 // API 后端可自行搭建，参考 https://github.com/fghrsh/live2d_api // 初始化看板娘会自动加载指定目录下的 waifu-tips.json console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/live2d.min.js","permalink":"https://blog.newimg.ltd/live2d-widget/live2d.min.js","excerpt":"","text":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/waifu-tips.js","permalink":"https://blog.newimg.ltd/live2d-widget/waifu-tips.js","excerpt":"","text":"/* * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ function loadWidget(config) { let { waifuPath, apiPath, cdnPath } = config; let useCDN = false, modelList; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } else if (typeof apiPath === \"string\") { if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; } else { console.error(\"Invalid initWidget argument!\"); return; } localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } // 检测用户活动状态，并在空闲时显示消息 let userAction = false, userActionTimer, messageTimer, messageArray = [\"好久不见，日子过得好快呢……\", \"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\", \"嗨～快来逗我玩吧！\", \"拿小拳拳锤你胸口！\", \"记得把小家加入 Adblock 白名单哦！\"]; window.addEventListener(\"mousemove\", () => userAction = true); window.addEventListener(\"keydown\", () => userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(randomSelection(messageArray), 6000, 9); }, 20000); } }, 1000); (function registerEventListener() { document.querySelector(\"#waifu-tool .fa-comment\").addEventListener(\"click\", showHitokoto); document.querySelector(\"#waifu-tool .fa-paper-plane\").addEventListener(\"click\", () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { const script = document.createElement(\"script\"); script.src = \"https://cdn.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\"; document.head.appendChild(script); } }); document.querySelector(\"#waifu-tool .fa-user-circle\").addEventListener(\"click\", loadOtherModel); document.querySelector(\"#waifu-tool .fa-street-view\").addEventListener(\"click\", loadRandModel); document.querySelector(\"#waifu-tool .fa-camera-retro\").addEventListener(\"click\", () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; }); document.querySelector(\"#waifu-tool .fa-info-circle\").addEventListener(\"click\", () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); }); document.querySelector(\"#waifu-tool .fa-times\").addEventListener(\"click\", () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.bottom = \"-500px\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); }); const devtools = () => {}; console.log(\"%c\", devtools); devtools.toString = () => { showMessage(\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\", 6000, 9); }; window.addEventListener(\"copy\", () => { showMessage(\"你都复制了些什么呀，转载要记得加上出处哦！\", 6000, 9); }); window.addEventListener(\"visibilitychange\", () => { if (!document.hidden) showMessage(\"哇，你终于回来了～\", 6000, 9); }); })(); (function welcomeMessage() { let text; if (location.pathname === \"/\") { // 如果是主页 const now = new Date().getHours(); if (now > 5 && now 7 && now 11 && now 13 && now 17 && now 19 && now 21 && now response.json()) .then(result => { const text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); const tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 1; // 模型 ID modelTexturesId = 53; // 材质 ID } loadModel(modelId, modelTexturesId); fetch(waifuPath) .then(response => response.json()) .then(result => { window.addEventListener(\"mouseover\", event => { for (let { selector, text } of result.mouseover) { if (!event.target.matches(selector)) continue; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); window.addEventListener(\"click\", event => { for (let { selector, text } of result.click) { if (!event.target.matches(selector)) continue; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); result.seasons.forEach(({ date, text }) => { const now = new Date(), after = date.split(\"-\")[0], before = date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] response.json()) .then(result => { loadModel(result.model.id, 0, result.model.message); }); } } } function initWidget(config, apiPath) { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); const toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } }"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/waifu-tips.json","permalink":"https://blog.newimg.ltd/live2d-widget/waifu-tips.json","excerpt":"","text":"{\"mouseover\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool .fa-comment\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool .fa-paper-plane\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool .fa-user-circle\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool .fa-street-view\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool .fa-camera-retro\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool .fa-info-circle\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool .fa-times\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home a\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about a\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags a\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\"]},{\"selector\":\".menu-item-categories a\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\"]},{\"selector\":\".menu-item-archives a\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\"]},{\"selector\":\".menu-item-friends a\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search a\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".menu-item a\",\"text\":[\"快看看这里都有什么呢？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\"#qrcode\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".copy-btn\",\"text\":[\"代码可以直接点击复制哟。\"]},{\"selector\":\".highlight .table-container, .gist\",\"text\":[\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".beian a\",\"text\":[\"我也是有户口的人哦。\",\"我的主人可是遵纪守法的好主人。\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#waifu #live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}]}"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/waifu.css","permalink":"https://blog.newimg.ltd/live2d-widget/waifu.css","excerpt":"","text":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 10px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; right: 0; line-height: 0; margin-bottom: -10px; position: fixed; transform: translateY(3px); transition: transform .3s ease-in-out, bottom 3s ease-in-out; z-index: 1; } #waifu:hover { transform: translateY(0); } #waifu-tips { animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #waifu #live2d { cursor: grab; height: 300px; position: relative; width: 300px; } #waifu #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; left: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { color: #7b8c9d; cursor: pointer; display: block; line-height: 30px; text-align: center; transition: color .3s; } #waifu-tool span:hover { color: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }"},{"title":"所有标签","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"tags/index.html","permalink":"https://blog.newimg.ltd/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/css/tidio_custom.css","permalink":"https://blog.newimg.ltd/custom/css/tidio_custom.css","excerpt":"","text":"@media screen and (max-width: 500px) { #tidio-chat-iframe { right: 0px !important; bottom: 80px !important; } } #tidio-chat-iframe { position: fixed !important; right: 10px !important; bottom: 85px !important; left: auto !important; } #tidio-chat { transition: opacity 0.75s ease-in-out; }"},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/css/waifu_custom.css","permalink":"https://blog.newimg.ltd/custom/css/waifu_custom.css","excerpt":"","text":"#waifu { width: 200px; transition: opacity 0.75s ease-in-out; } #waifu #live2d { height: 200px; width: 200px; } #waifu-tool { left: 15px; top: 5px; } #waifu { right: auto; left: 0; width: 200px; } .fa-lg { font-size: 0.9em !important; } #waifu-tool span { height: 22px; } #waifu-tips { min-height: 50px; width: 150px; font-size: 0.45em; line-height: 12px; left: 15px; }"},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/js/async_load.js","permalink":"https://blog.newimg.ltd/custom/js/async_load.js","excerpt":"","text":"/** * 异步资源加载函数 * @param {URL} url 要加载的资源链接 * @param {type{\"css\", \"js\"}} type 资源类型 * @returns */ function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } /** * 根据元素id监听函数 * @param {node} fatherTree 要监听的元素的父容器 * @param {boolean} watchSubtree 是否监听所有后代节点的变化 * @param {Map} ListenerMap 需要新增的节点和操作函数数组 */ function sign(fatherTree, watchSubtree, ListenerMap) { // 创建一个 MutationObserver 实例 var observer = new MutationObserver(function (mutations) { mutations.forEach(function (mutation) { if (mutation.addedNodes.length > 0) { // 遍历新增的节点 for (var i = 0; i < mutation.addedNodes.length; i++) { var node = mutation.addedNodes[i]; // 检查新增节点是否为目标元素 if (node.matches) { let keysToDelete = []; ListenerMap.forEach((processFunc, key) => { // 判断是否满足删除条件 if (node.id == key) { processFunc(node); keysToDelete.push(key); } }) // 删除元素 keysToDelete.forEach((key) => { ListenerMap.delete(key); }) // 元素为空，停止监听 if (ListenerMap.size == 0) observer.disconnect } } } }); }); // 配置 MutationObserver 监听特定的 DOM 变化 var observerConfig = { childList: true, // 监听子节点的变化 subtree: watchSubtree // 监听所有后代节点的变化 }; // 启动 MutationObserver observer.observe(fatherTree, observerConfig); } function delayUntilConditionMet(condition, delay, callback) { if (condition()) { callback(); } else { setTimeout(function () { delayUntilConditionMet(condition, delay, callback); }, delay); } } /* 加载动态隐藏函数 */ loadExternalResource(\"./custom/js/hideObj.js\", \"js\") /* 注册监听，以便实时更新隐藏状态 */ let ListenerMap = new Map([ ['waifu', function () { handleScroll(); }], ['tidio-chat', function () { handleScroll(); }] ]) sign(document.documentElement, true, ListenerMap) /* 加载资源 */ Promise.all([ loadExternalResource(\"./live2d-widget/autoload.js\", \"js\"), ]).then(() => { loadExternalResource(\"./custom/css/waifu_custom.css\", \"css\") }); Promise.all([ loadExternalResource(\"//code.tidio.co/qfmxenxm3vbbzuagnt9kj52ykueuibfn.js\", \"js\") ]).then(() => { loadExternalResource(\"./custom/css/tidio_custom.css\", \"css\") });"},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/js/hideObj.js","permalink":"https://blog.newimg.ltd/custom/js/hideObj.js","excerpt":"","text":"function isElementVisible(element) { var rect = element.getBoundingClientRect(); return rect.top"},{"title":"","date":"2023-09-16T15:51:01.739Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"custom/js/volantis_css_async.js","permalink":"https://blog.newimg.ltd/custom/js/volantis_css_async.js","excerpt":"","text":"/** * 监听函数 * @param {node} fatherTree 要监听的元素的父容器 * @param {boolean} watchSubtree 是否监听所有后代节点的变化 * @param {Map} ListenerMap 需要新增的节点和操作函数数组 */ function sign(fatherTree, watchSubtree, ListenerMap) { // 创建一个 MutationObserver 实例 var observer = new MutationObserver(function (mutations) { mutations.forEach(function (mutation) { if (mutation.addedNodes.length > 0) { // 遍历新增的节点 for (var i = 0; i < mutation.addedNodes.length; i++) { var node = mutation.addedNodes[i]; // 检查新增节点是否为目标元素 if (node.matches) { let keysToDelete = []; ListenerMap.forEach((processFunc, key) => { // 判断是否满足删除条件 if (node.matches(key)) { processFunc(node); keysToDelete.push(key); } }) keysToDelete.forEach((key) => { ListenerMap.delete(key); }) if (ListenerMap.size == 0) observer.disconnect } } } }); }); // 配置 MutationObserver 监听特定的 DOM 变化 var observerConfig = { childList: true, // 监听子节点的变化 subtree: watchSubtree // 监听所有后代节点的变化 }; // 启动 MutationObserver observer.observe(fatherTree, observerConfig); } // let ListenerMap = new Map([ // [ // '#waifu', // function (node) { // Object.assign(node.style, { // width: '200px', // right: 'auto', // left: '0', // width: '200px' // }) // } // ], // [ // '#live2d', // function (node) { // Object.assign(node.style, { // height: '200px', // width: '200px' // }) // } // ], // [ // '#waifu-tool', // function (node) { // Object.assign(node.style, { // left: '15px', // top: '5px' // }) // } // ], // [ // '.fa-lg', // function (node) { // Object.assign(node.style, { // fontSize: '0.9em !important' // }) // } // ], // [ // '#waifu-tips', // function (node) { // Object.assign(node.style, { // minHeight: '50px', // width: '150px', // fontSize: '0.45em', // lineHeight: '12px', // left: '15px' // }) // } // ], // [ // 'key1', // { // nodeMatches: \"Hello\", // processFunc: function (node) { } // } // ] // ]) // For Test let ListenerMap = new Map([ [ '#father', function (node) { Object.assign(node.style, {width: '100px'}) } ] ]) sign(document.documentElement, true, ListenerMap)"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/demo/demo.html","permalink":"https://blog.newimg.ltd/live2d-widget/demo/demo.html","excerpt":"","text":"Live2D 看板娘 / Demo #github svg { transition: all 1s; fill: #222; color: #fff; position: absolute; top: 0; right: 0; border: 0; width: 80px; height: 80px; } #github:hover svg { width: 160px; height: 160px; }"},{"title":"","date":"2023-09-16T15:51:01.743Z","updated":"2023-09-16T15:51:01.743Z","comments":true,"path":"live2d-widget/demo/login.html","permalink":"https://blog.newimg.ltd/live2d-widget/demo/login.html","excerpt":"","text":"看板娘登陆平台 html, body { height: 100%; } body { display: flex; align-items: center; justify-content: center; padding-top: 40px; padding-bottom: 40px; background-color: #f5f5f5; } .form-signin { width: 100%; max-width: 330px; padding: 15px; margin: 0 auto; } .form-signin .checkbox { font-weight: 400; } .form-signin .form-control { position: relative; box-sizing: border-box; height: auto; padding: 10px; font-size: 16px; } .form-signin .form-control:focus { z-index: 2; } .form-signin input[type=text] { margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .form-signin input[type=password] { margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; } #stage { position: relative; } #stage img { width: 100%; margin-bottom: 20px; border-radius: 20px; } #stage a { position: absolute; width: 2em; height: 2em; border-radius: 50%; } #inner { position: relative; background-color: #999; clip-path: circle(120px at center); } #cover { position: absolute; background-color: #CB3837; width: 100%; height: 100%; bottom: 10%; transition: all 1s; box-shadow: 0 0 0 5px rgba(0, 0, 0, .1); } #text { position: absolute; bottom: 30%; font-size: 2em; left: 50%; transform: translateX(-50%); opacity: 0.4; font-weight: bold; } #detail { position: absolute; background: rgba(255, 255, 255, .1); width: 100%; height: 10px; bottom: 0; } #handle { position: absolute; background: #ccc; bottom: -2px; box-shadow: 0 1px 0 1px rgba(0, 0, 0, .1); height: 8px; left: 50%; margin-left: -15px; width: 30px; cursor: pointer; } #info { left: 40px; bottom: 20px; } #refresh { right: 40px; bottom: 20px; } #live2d { cursor: grab; height: 300px; width: 300px; } #live2d:active { cursor: grabbing; } MIMIPOWERED 看板娘登陆平台 用户名 密码 记住我 登录 Copyleft &copy; Mimi 2019 /* * _(:з」∠)_ * Created by Shuqiao Zhang in 2019. * https://zhangshuqiao.org */ /* * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */ window.addEventListener(\"load\", () => { \"use strict\"; if (!CSS.supports(\"clip-path\", \"circle(120px at center)\")) { document.getElementById(\"stage\").innerHTML = ''; return; } let apiPath = \"https://live2d.fghrsh.net/api\", state = 0, modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { modelId = 1; modelTexturesId = 53; } loadModel(modelId, modelTexturesId); function loadModel(modelId, modelTexturesId) { localStorage.setItem(\"modelId\", modelId); if (modelTexturesId === undefined) modelTexturesId = 0; localStorage.setItem(\"modelTexturesId\", modelTexturesId); loadlive2d(\"live2d\", `${apiPath}/get/?id=${modelId}-${modelTexturesId}`, null); console.log(\"live2d\", `模型 ${modelId}-${modelTexturesId} 加载完成`); setTimeout(() => { coverPosition(\"80%\"); state = 2; }, 2000); } function loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); fetch(`${apiPath}/rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { loadModel(modelId, result.textures.id); setTimeout(() => { state = 2; coverPosition(\"80%\"); document.getElementById(\"refresh\").setAttribute(\"href\", \"javascript:refresh()\"); }, 1000); }); } function loadOtherModel() { const modelId = localStorage.getItem(\"modelId\"); fetch(`${apiPath}/switch/?id=${modelId}`) .then(response => response.json()) .then(result => { loadModel(result.model.id); }); } function coverPosition(pos) { document.getElementById(\"cover\").style.bottom = pos; } window.info = function() { fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { alert(\"「\" + result.hitokoto + \"」——\" + result.from); }); }; window.refresh = function() { state = 0; coverPosition(\"10%\"); document.getElementById(\"refresh\").setAttribute(\"href\", \"javascript:void(0)\"); setTimeout(loadRandModel, 1000); }; document.getElementById(\"handle\").addEventListener(\"click\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } else if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"focus\", () => { if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"blur\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } }); });"}],"posts":[{"title":"米小游抽原神up池","slug":"米小游抽原神up池","date":"2023-08-12T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/08/13/米小游抽原神up池/","link":"","permalink":"https://blog.newimg.ltd/2023/08/13/%E7%B1%B3%E5%B0%8F%E6%B8%B8%E6%8A%BD%E5%8E%9F%E7%A5%9Eup%E6%B1%A0/","excerpt":"","text":"题目米小游抽原神u池已经好久没有歪啦！给大家来点小小的九连不歪震撼！ 图略 已知《原神》和《崩坏：星穹铁道》中的抽卡系统的概率如 下：在未触发大保底机制时，每抽一发有p&#x2F;2的概率抽到当期5 星，有p&#x2F;2的概率抽到常驻5星，其余的1一p概率不出5星。 当抽到常驻5星后，触发了大保底机制，以后每抽一发有p的概率抽到当期5星，其余的1-p概率不出5星。 另外，当连续89抽未出5星时，下一抽必出5星。也就是说，若未触发大保底机制，本次抽卡1&#x2F;2概率抽到当期5星，有1&#x2F;2的概率抽到常驻5星：若已触发了大保底机制，则100%概率抽到当期5星。 现在给定了抽中5星的概率p。米小游想要抽到一张当期5星卡，她想知道抽卡次数的期望是多少？ 输入描述一个小数p(0&lt;p&lt;1),代表抽中5星的概率。 输出描述一个浮点数，代表抽卡次数的期望。如果你的答案和正确答案的误差不超过 $10^6$ ，则以为答案正确。 示例0.006 输出104.5497057 解法（无误差）import java.math.BigDecimal; import java.util.Scanner; public class Main &#123; static BigDecimal p = BigDecimal.ZERO; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); p = sc.nextBigDecimal(); System.out.println( recursion(BigDecimal.ONE, BigDecimal.ONE) .multiply(BigDecimal.valueOf(1.5)) .setScale(7, BigDecimal.ROUND_HALF_UP) ); &#125; public static BigDecimal recursion(BigDecimal time, BigDecimal np) &#123; if (time.equals(BigDecimal.valueOf(90))) return np.multiply(BigDecimal.valueOf(90)); BigDecimal newNp = np.multiply(BigDecimal.ONE.subtract(p)); return recursion(time.add(BigDecimal.ONE), newNp).add(time.multiply(p).multiply(np)); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"algorithm","slug":"java/algorithm","permalink":"https://blog.newimg.ltd/categories/java/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"acme安装使用","slug":"acme使用","date":"2023-08-03T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/08/04/acme使用/","link":"","permalink":"https://blog.newimg.ltd/2023/08/04/acme%E4%BD%BF%E7%94%A8/","excerpt":"","text":"官方文档 软件安装与使用软件安装curl https://get.acme.sh | sh -s email=my@example.com git clone https://gitee.com/neilpang/acme.sh.git cd acme.sh ./acme.sh --install -m email=my@example.com 之后 source ~/.bashrc 设置服务商acme.sh --set-default-ca --server letsencrypt 申请证书acme.sh --issue --dns -d mydomain.com --yes-I-know-dns-manual-mode-enough-go-ahead-please --yes-I-know-dns-manual-mode-enough-go-ahead-please 必须加 添加 txt 类型的 dns acme.sh --renew -d mydomain.com --yes-I-know-dns-manual-mode-enough-go-ahead-please 安装证书acme.sh --install-cert -d example.com \\ --key-file /path/to/keyfile/in/nginx/key.pem \\ --fullchain-file /path/to/fullchain/nginx/cert.pem \\ mkdir -p /MySoftware/nginx.d/ssl/ali.newimg.ltd/ acme.sh --install-cert -d ali.newimg.ltd \\ --key-file /MySoftware/nginx.d/ssl/ali.newimg.ltd/key.pem \\ --fullchain-file /MySoftware/nginx.d/ssl/ali.newimg.ltd/fullchain.pem","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"ssl","slug":"linux/ssl","permalink":"https://blog.newimg.ltd/categories/linux/ssl/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"网络规划与设计","slug":"NetDesign","date":"2023-06-27T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/06/28/NetDesign/","link":"","permalink":"https://blog.newimg.ltd/2023/06/28/NetDesign/","excerpt":"","text":"第一章系统集成三大部分 网络系统 硬件系统 软件系统 系统集成的复杂性系统集成的复杂性体现在：技术、成员、环境、约束四个方面，它们之间互为依存关系。 实现技术的集成性 成员目标的复杂性 应用环境的不确定性 约束条件的多样性 网络工程项目集成步骤 网络系统规划 网络系统设计 网络系统实施 网络系统验收 TCP&#x2F;IP 体系结构 物联网总体结构 感知层 感知层包括传感器等数据采集设备，以及数据接入到网关之前的传感器网络 传送层 传送层建立在现有通信网络和互联网的基础上，综合使用移动互联网、有限宽带、无线局域网等技术。 应用层 应用层利用经过分析处理的感知数据，为用户提供丰富的特定服务 第二章用户特点 用户是经过筛选的 用户是沉默的 用户是难以满足的 用户是可引导的 教育系统特点对数据的可靠性要求较低，但是往往对宽带要求较高。网络技术较为单一，往往采用宽带以太网技术 网络扩展需求分析 用户业务的扩展性 网络性能的扩展性 网络结构的扩展性 网络设备的扩展性 网络软件的扩展性 第三章蜂窝网络特点采用频率复用方法，同一频率在分散的区域内被多次复用，使有限的带宽容纳大量用户。 FDM（Frequency Division Multiplexing）：频分复用是将可用频段分成若干条不同的频带，每条频带分配给一个用户，不同用户之间的频带不重叠，从而实现多用户同时使用同一信道进行通信的技术。 TDM（Time Division Multiplexing）：时分复用是将时间分成若干个时隙，每个时隙分配给一个用户，不同用户之间的时隙不重叠，从而实现多用户同时使用同一信道进行通信的技术。 OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用是一种基于频域的复用技术，它将整个频带分成若干个子载波，每个子载波之间正交，从而实现多用户同时使用同一信道进行通信的技术。 CDMA（Code Division Multiple Access）：码分复用是一种通过差异化编码实现用户信号的区分的技术，不同用户之间使用不同的编码方式，从而实现多用户同时使用同一信道进行通信的技术。 网络层次化设计模型从内而外 核心层 数据告诉转发 汇聚层 数据流量聚合，路由聚合 接入层 用户接入，访问控制 STP 的作用STP 是二层网络中用于消除环路的协议 通过阻断冗余链路来消除桥接网络中可能存在的路径回环 当前活动路径发生故障时，激活冗余备份链路，恢复网络连通性 服务子网设计模型 集中式服务设计模型 所有服务子网设计在网络核心层 分布式服务设计模型 网络服务集中，应用服务分散 VLAN 的特点 一个 VLAN 中所有设备都是在同一广播域内；广播不能跨越 VLAN 传播。 一个 VLAN 为一个逻辑子网；由被配置为此 VLAN 成员的设备组成， 不同 VLAN 通过路由器实现相互通信。 VLAN 中成员多基于 Switch 端口号码，划分 VLAN 就是对 Switch 接口划分。 VLAN 工作于 OSI 参考模型的第二层。 Trunk 的封装协议 802.1Q ISL VLAN 间路由由于 VLAN 隔离了二层广播域，也间接的隔离了各个 VLAN 之间的其他二层流量交换，这样导致属于不同 VLAN 之间的用户不能进行二层的通信。只能经过三层的路由转发才能将报文从一个 VLAN 转发到另外一个 VLAN。 第四章浮动静态路由 浮动静态路由是一种静态路由的变种，它可以实现在出现故障或者链路负载过高的情况下，自动切换到备用路由，提高网络的可靠性和可用性。在浮动静态路由中，通常会配置两条静态路由，一条为主路由，另一条为备用路由。主路由通常是网络的默认路由，备用路由则是在主路由故障或链路负载过高时使用的备用路由。备用路由的优先级比主路由低，一旦主路由出现问题，备用路由就会自动激活。 *看懂配置 OSPFrouter-id 如何获取如果没有通过命令指定 RID，将按照如下顺序自动生成一个 RID： 如果当前设备配置了 Loopback 接口，将选取所有 Loopback 接口上数值最大的 IP 地址作为 RID； 如果当前设备没有配置 Loopback 接口，将选取它所有已经配置 IP 地址且链路有效的接口上数值最大的 IP 地址作为 RID。 网络类型 Broadcast NBMA（Non-Broadcast Multi-Access，非广播多点可达网络） P2MP（Point-to-MultiPoint，点到多点） P2P（Point-to-Point，点到点） DR&#x2F;BDR 的选举原则首先比较 Hello 报文中携带的优先级 优先级最高的被选举为 DR，优先级次高的被选举为 BDR 优先级为 0 的不参与选举优先级一致的情况下，比较 Router ID Router ID 越大越优先保持稳定原则 当 DR&#x2F;BDR 已经选举完毕，就算一台具有更高优先级的路由器变为有效，也不会替换该网段中已经选举的 DR&#x2F;BDR 成为新的 DR&#x2F;BDR。 几种报文的作用 OSPF 报文类型 作用 Hello 建立并维护邻居关系 Database Description（DD） 数据库内容的汇总（仅包含 LSA 摘要） Link State Request（LSR） 请求自己没有的或者比自己更新的链路状态详细信息 Link State Update（LSU) 链路状态更新信息 Link State Acknowledge（LSAck） 对 LSU 的确认 BGP 封装传输层 TCP BGP 常见属性配置及作用Next-Hop 公认强制属性 BGP 中的跳是“AS” 对于外部 BGP 和内部 BGP，下一跳是通告该路由器的邻居路由器的 IP 地址 对于多路访问型网络（如以太网），下一跳是路由器连接到该网络接口的 IP 地址。 Origin Code（路由条目来源属性） 公认强制属性 来源属性指出该路由条目的来源是什么路由协议类型 AS_Path 公认强制属性 用来描述到达该网络经过的所以 AS 有哪些功能 让 BGP 进程决策最优路径 防止环路 Local_Preference(本地优先级） 公认自由决定属性 告诉本地 AS 中的 BGP 路由器，从哪个出口出去才是最优路径。 Weight 私有属性 权值越大、优先级越高 MED（多出口鉴别）属性告诉外部邻居 AS 中的 BGP 路由器，从哪个入口进入本地 AS 才是最优的。 第五章阻塞式设计和非阻塞式设计 阻塞式设计 分层网络设计中，上层链路带宽大于或者等于下层链路带宽总和 非阻塞式设计 分层网络设计中，上层链路带宽低于下层链路带宽总和 按非阻塞式设计的网络汇聚节点负载轻，网络扩展性好，成本高 链路聚合将交换机上的多个端口在物理上连接起来，在逻辑上捆绑在一起，形成一个有较大宽带的端口，实现均衡负载，提供冗余链路。IEEE802.3ad 标准的 LACP（链路聚合控制协议）是一种实现链路动态聚合的协议，通过 LACPDU（链路聚合控制协议数据单元）与对方交换机交互信息。 LACP 协议不等于链路聚合技术 链路聚合条件 各链路的传输介质必须相同 各分离链路传输速率必须相同 各分离链路必须是全双工链路 各分离链路两端的参数必须一致 各分离链路的速率不小于 100M。 常见队列调度算法 FIFO(先到先服务)算法 REO(随机早期检测)算法 PFQ(分组公平队列) WFQ(加权公平队列) PQ(优先级排队) RR(轮循调度） 第六章网络可靠性计算方法可靠性可以用无故障工作时间(MTBF)衡量。 网络可用性计算串联型网络结构可用性计算 并联型网络结构可用性计算 例如 网络结构如图，计算路由器 ABCD 的整体可用性 路由器 ABC 间可用性$0.99\\times0.97\\times0.98&#x3D;94.1%$路由器 B+D 并联体的可用性$1-(1-0.97)\\times(1-0.95)&#x3D;99.85%$路由器 ABC 间可用性$0.99\\times0.9985\\times0.98&#x3D;96.9%$ VRRPIETF 制定的 VRRP（虚拟路由器冗余协议）是一种容错协议（RFC-2338）。 RAIDRAID 级别是一种工业标准。 RAID 0 采用无数据冗余的储存空间条带化技术 RAID 1 采用了两块硬盘数据完全镜像的技术 RAID 2、3、4、5 可以对硬盘中的数据进行纠错校验 网络存储技术类型 直接附加存储（DAS） 直接连接在服务器主机上的存储设备 网络附加存储（NAS） 连接在网络上的专用存储设备 存储区域网络（SAN） 在服务器和存储设备之间利用专用的光纤通道连接的网络系统 JBOD 存储技术 是一个底板上安装多个磁盘的存储设备。支持热插拔，可以在不影响数据存储和服务器操作的同时增加或替换磁盘。 iSCSI 技术是什么是在 IP 上运行的 SCSI 指令集，采用 TCP 三个集群系统类型 高可用集群 HA 集群主要用于不可间断的服务环境 负载均衡集群 LBC 主要用于高负载业务，由多个计算节点提供可伸缩的，高负载的服务器群组，以保证服务的均衡响应 高性能计算集群 HPC 集群致力于开发超级计算机，研究并行算法和开发相关软件 第七章DMZ（隔离区&#x2F;非军事区）概念是设立在非安全系统与安全系统之间的缓冲区。 防火墙接口 内网接口 用于连接内部网络设备 外网接口 相当于主机接口，用于连接边界路由器等外部网关设备 DMZ 接口 用于连接 DMZ 区的网络设备 IDS（入侵检测系统）抓取网络上所有报文，分析处理后，报告异常和重要数据模式和行为模式，让网络安全管理员了解网络上发生的事，采取行动阻止可能发生的破坏。分为实时入侵检测和事后入侵检测。 IDS 系统适合安装在网络边界区域，服务器群区域，网络主机区域。不适合在网络核心层。IDS 问题：1.误报&#x2F;漏报率高。2.没有主动防御功能。3.缺乏准确定位和处理机制。 IPS（入侵防御系统）是一种主动，积极的入侵防御系统。检测入侵发生，实时终止入侵行为。一般部署在网络进出口。 部署方式：IDS 旁路式连接，IPS 串接式连接。串接工作模式保证所有网络数据必须经过 ISP 设备。IPS 问题：1.单点故障。2.性能瓶颈。3.误报漏报。4.规则动态更新。5.总体拥有成本 常见对称加密算法DES 加密算法，AES，RSA，Base64，MD5，SHA1 GAP 的特点 GAP 由固态读写开关和存储介质系统组成 GAP 连接在两个独立的网络系统中间 能抵御互联网绝大部分攻击 GRE VPN 配置 创建 Tunnel:接口，并进入其接口视图 [Router]interface tunnel interface-number 指定 Tunneli 的源端 [Router-Tunnelo]source ip-address interface-type interface-number 指定 Tunnell 的目的端 [Router-Tunnel0]destination ip-address 设置 Tunnel 接口的 IP 地址 [Router-Tunnelo]ip address ip-address mask mask-length 设置 Tunnel 接口报文的封装模式为 GRE [Router-Tunnel0]tunnel-protocol gre 设置 Tunneli 两端进行端到端校验 [Router-Tunnel0]gre checksum 设置 Tunnel 接口的识别关键字 [Router-Tunnelo]gre key key-number 配置 Tunnel 的 Keepalive 功能 [Router-Tunnelo]keepalive seconds times 第十章E1 速率E1 链路采用 PCM（脉冲编码调制)信号，规定每秒有 8000 个 E1 帧通过 E1 链路，因此 E1 链路的数据传输速率为：8000x256bit&#x3D;2.048Mbit&#x2F;s。1 个 E1 帧有 32 个时隙，因此一条 E1 链路中有 32 个 64kbit&#x2F;s(2.048Mbit÷32)的话音或数据信道。E1 帧的周期为：T&#x3D;1&#x2F;f&#x3D;1&#x2F;8000&#x3D;125μs EPON 工作原理 下行传输。 EPON 采用以太技术，因此不需复杂的协议转换。在下行方向上,光线路终端(OLT)通过 1:N(N&#x3D;4-64)的无源光分路器(OBD)，将以太帧广播给每个光网络单元(ONU)。 上行传输。 数据上行时采用了时分复用方式，每个 ONU 都分配到一个传输时隙,OUN 将数据包按时隙进行封装,然后发送到 OBD,OBD 在指定的时隙上传数据包给 OLT,上行信号采用时分复用方式避免了数据传输冲突。 第十一章SDH 帧结构ITU-TG709 规定，SDH 采用以字节为基础的矩形块状帧结构。基本帧结构为 STM-N（同步传输模块）如图 11-1 所示，一个 STM-1 帧由 9 行 x270 列&#x3D;2430Byte 组成前 9 列为系统开销，包括 再生段开销（RSOH） 指针开销（AU-PTR） 复用段开销（MSOH） 用户数据为后 261 列，其中第 1 列为通道开销（POH） 帧频ITU－T 规定，对任何级别的 STM—N 帧，帧频都是 8000 帧&#x2F;秒，帧周期恒为 125μs CWDM（粗波分复用）一般认为波长信道间距大于 1nm，且信道总数少于 18 个时。","categories":[{"name":"review","slug":"review","permalink":"https://blog.newimg.ltd/categories/review/"},{"name":"general","slug":"review/general","permalink":"https://blog.newimg.ltd/categories/review/general/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"期末网安","slug":"NetSecurity","date":"2023-06-27T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/06/28/NetSecurity/","link":"","permalink":"https://blog.newimg.ltd/2023/06/28/NetSecurity/","excerpt":"","text":"第一章计算机安全的定义对某个自动化信息系统的保护措施，其目的在于实现信息系统资源的完整性、可用性及机密。 相关性质： 机密性：保护个人隐私信息，防止非授权泄漏 数据机密性：保证私有的或机密的信息不泄漏给非授权用户 隐私性：保证个人可以控制和影响与之相关的信息（即个人隐私） 完整性：防范不当修改和破坏，保证信息的认证与授权 数据完整性：保证信息和代码只能以某种特定的授权方式更改 系统完整性：系统能够实现预期功能，不被故意或偶然的非授权操作控制 可用性：保证及时且可靠地获取和使用信息 真实性：可以被验证和信任的属性，来源可信性。即验证使用者身份、以及系统信号来自可靠信息源 可计量性：每个实体行为可以被唯一地溯源，非否认、告警、错误隔离、入侵检测、错误恢复等 安全威胁违反安全性的例子 1️⃣ 用户A向B传递了文件，该文件中包含了敏感的数据：比如合同标的。C通过监视该传输过程截取了文件副本。 2️⃣一个雇员被解雇而没有通知大家，人事经理向服务器发出了删除该雇员账号的要求。但该消息被雇员截获，并使之能延迟足够长时间。以便能够最后访问服务器获取敏感信息。然后再转发该息。 3️⃣某网络管理员D在其管理下向一台计算机E传递一条消息，指示E更新一个授权文件，该文件包含了一些能够访问该机的用户Id。F截获了该消息，进行了删改并传给E。E以为来自于D从而接受并更新了授权文件。 4️⃣用户F没有中途阻止某消息，而是直接构造了自己希望内容的消息，好像该消息来自于D。E接受并更改了授权文件 5️⃣ 一个客户向代理商发出带有多个交易指示的消息。随后该投资跌值，而该客户不承认发出过该消息 端到端通信和点到点通信点到点通信物理层、数据链路层和网络层是面向网络通信的低三层，为网络环境中的主机提供点对点通信服务。点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信。 端到端通信端到端通信完成应用程序（进程）之间的通信。OSI 参考模型中的传输层功能的裨是最终完成端到端的可靠连接。“端”是指用户应用程序的“端口”。 TCP 协议五元组？TCP 协议的五元组是指由源 IP 地址、目的 IP 地址、源端口号、目的端口号和传输协议类型这五个值组成的标识一个 TCP 连接的唯一标识符。 被动攻击 概念 特征 对策 攻击者只是窃听或监视数据传输，目标是获取传输的数据信息。常见的有消息内容泄漏和流量分析。 难以检测，不改变数据及通信 防范而非检测 分类 消息内容泄露攻击 电话交谈、电子邮件消息和传输文件中都有可能包含敏感或机密信息 流量分析攻击 攻击者对观察到的信息进行分析，推测出消息内容 被动攻击非常难以检测，因其不改变数据。对付被动攻击的重点是防范而不是检测 主动攻击 概念 特征 对策 数据流的改写及错误数据流的添加。包括假冒（伪装）、重放、篡改消息、拒绝服务。试图改变系统资源或影响系统操作。 易于检测防范困难 物理保护、检测以防范 假冒（伪装） 发生在一个实体假冒成另一个实体的场合。 重放 涉及被动获取数据单元并按照它之前的顺序重新传输，由此产生一个非授权效应。 篡改消息 合法消息的某些部分被篡改，或者消息被延迟、被重排，从而产生一个非授权效应。e.g.，一条含义为“允许 John Smith 读取机密文件 accounts”的消息被篡改为“允许 Fred Brown 读机密文件 accounts” 拒绝服务 可以阻止或禁止对通信设备的正常使用和管理。 网络访问安全模型 解决有害访问的安全机制包含：（1）看门人功能。如基于口令的登录过程（2）逻辑屏蔽。设计检测和拒绝蠕虫、病毒以及类似攻击。 第二章传统加密传统加密的原理：取代和置换取代(Substitution)：将明文集中每个元素映射为另外一个元素。置换(Permutation)：重新排列明文中每个元素求积密文：以上二者结合 一般的数据加密模型 加密的目的：通过将消息编码或隐藏使其不可读，从而保护机密性 同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密一个对称加密方案由 5 部分组成： 明文(plaintext) 原始消息或数据，作为算法的输入，任何人可解读。 加密算法(encryption algorithm) 变换函数，对明文进行各种取代和变换。 密钥(secret key) 密钥也是算法的输入，参与变换的参数，算法进行的具体替换和转换取决于这个密钥 密文(ciphertext) 产生的已被打乱的消息输出，取决于明文和密钥，对于一个给定的消息，两个不同的密钥会产生两个不同的密文 解密算法(decryption algorithm) 本质是加密算法的逆变换，输入密文，输出明文 明文 X 用加密算法 E 和加密密钥 Ke 得到密文 Y&#x3D;E(Ke ,X)。在传送过程中可能出现密文截取者。到了收端，利用解密算法 D 和解密密钥 Kd，解出明文为 D(Kd , Y)&#x3D;D(Kd , E(Ke , X))&#x3D;X。截取者又称为攻击者或入侵者。对称加密的安全使用有如下两个要求：(1)需要一个强加密算法；(2)发送者和接收者必须通过一个安全的方式获得密钥且保证密钥安全。对称加密的安全取决于密钥的保密性而非算法的保密性。 *Feistel 密码结构实际中，我们需要加密，也需要解密。因此，有两种方法：1、定义每个替换、置换的逆，这样增加了复杂度2、定义一种结构，容易求逆，这样可以使用基本的相同编码或硬件用于加密和解密Horst Feistel（working at IBM Thomas J Watson Research Labs ）于 1973 年，提出了基于可逆乘积加密器，即现在大部分对称分组密码算法的核心 Feistel Cipher 。 算法输入为长度 2W 的明文块和密钥 K，执行 N 轮循环处理,每次循环的输入取决于上一轮的输出将输入分组分成左 Li-1 和右 Ri-1 两部分变换是在密码的第 n 轮只使用 Ri-1 和子密钥 Ki对左半部数据执行替代操作(substitution)；将右半部数据和子密钥应用函数 F，其输出与左一半做异或，作为下轮的右半部分最后将这两部分进行互换(permutation swapping) *Feistel Cipher 的设计问题对称分组密码的具体操作取决于以下参数和设计属性： 分组大小(block size)：越大的分组意味着越高的安全性，但减小了加密&#x2F;解密速率。128 比特大小的分组是一个合理的折中且是近来分组密码设计的普遍选择。 密钥大小(key size)：越长的密钥意味着越高的安全性，但可能会减小加密&#x2F;解密速率。在安全性与速度间抉择，64、128bit。 迭代轮数：对称分组密码的本质是单轮处理不能提供充分的安全性，多轮处理能提供更高的安全性。增加轮数可以提高安全性,但降低速度，典型大小是 16 轮 子密钥产生算法：越复杂则密码分析越困难 轮函数 Round：越复杂则抗密码分析的能力越强 其他考虑速度（尤其是软件实现的速度）算法简洁清楚，便于分析，发现密码分析弱点 *Feistel 类算法举例:DES、CAST、Blowfish&#x2F;(Twofish)、RC6(&#x2F;5) 不是 Feistel 结构的：AES、IDEA 绝大数分组密码属于或类似 Feistel 结构：多轮、每轮有 XOR（或能恢复的操作）、轮函数 二重 DES二重 DES 是对 DES 算法的加强版本。它采用两次 DES 算法对明文进行加密，即先用一个密钥对明文进行一次加密，再用另一个密钥对加密后的结果进行一次加密。因为使用两个密钥，所以又称为双重 DES。 安全性问题：虽然二重 DES 的安全性比单重 DES 更高，但是它仍然存在被暴力破解的风险。对于一个有限的密钥空间，使用暴力破解的方法可以尝试所有的密钥组合，从而破解出密钥。 三重 DES三重 DES（Triple DES）是一种对称加密算法，是在 DES 算法的基础上发展而来的加密算法。它采用了三次 DES 算法对明文进行加密，即先用一个密钥对明文进行一次加密，再用另一个密钥对加密后的结果进行解密，最后用第三个密钥对解密后的结果再进行一次加密。 当 K1&#x3D;K2&#x3D;K3 时，有 C&#x3D;E(K1,D(K1,E(K1,P)))&#x3D;E(K1,P)，这样 3DES 会退化为 DES。 3DES 的特点：由于 168 比特的密钥长度，它克服了 DES 对穷举法攻击的不足3DES 的底层加密算法和 DES 相同，而这个算法比任何其它算法都经过了更长时间、更详细的审查，除穷举法以外没有发现任何有效的基于此算法的攻击 3DES 的缺点：DES 算法软件运行较慢(原始 DES 为硬件实现，没有高效的软件代码)，3DES 迭代轮数是 DES 的三倍，因此 3DES 更慢DES 和 3DES 都使用 64 比特大小的分组，安全性较弱 高级加密标准属于分组加密算法、分组长度 128bits、密钥长度 128&#x2F;192&#x2F;256bits，相应 10&#x2F;12&#x2F;14 轮 特点速度快，耗用内存小，可靠性、防御能力强，将替代 DES 成为新的数据加密标准 设计原则 设计简单 在多个平台上速度快，编码紧凑 抵抗所有已知的攻击 Rijndael 没有采用 Feistel 结构，轮函数由 3 个不同的可逆均匀变换构成的，称为 3 个层。Rijndael 是一个分组密码算法，其分组长度和密钥长度相互独立，都可以改变。 不是 Feistel 结构密钥扩展4 个不同步骤，1 个移位，3 个替换结构简单只有轮密钥加步骤使用密钥轮密钥加本身不强大每一步都简单可逆解密算法按照相反顺序使用扩展密钥，但解密算法与加密算法不同若 4 个步骤均可逆，可恢复明文加解密最后一轮都只要 3 个步骤 随机数和伪随机数含义产生随机数有多种不同的方法。这些方法被称为随机数发生器。随机数最重要的特性是它在产生是后面的那个数与前面的那个数毫无关系。真正的随机数是使用物理现象产生的，它们的缺点是技术要求比较高。在实际应用中往往使用伪随机数就足够了。这些数列是“似乎”随机的数，实际上它们是通过一个固定的、可以重复的计算方法产生的。它们不真正地随机，因为它们实际上是可以计算出来的，但是它们具有类似于随机数的统计特征。这样的发生器叫做伪随机数发生器。 性质随机性：主要包含两种性质（1）均匀分布：1 和 0 出现的频率大致相同。（2）独立：数字之间相互独立。不可预测性：无法根据前期的数据预测后续的数据。 两种类型的随机数产生器 真随机数 TRNG：运用一些自然发生的过程产生真正的随机数，如抛硬币、样本热噪声、测量机械过程等伪随机数 PRNG：运用一个短的输入流（种子）的确定性序列获得适度的比特随机流。目前常用这种方法：LSFR 和分组密码生成器 PRF 分组密码工作模式为了将分组密码算法应用于实际，人们定义了很多工作模式分组密码的工作模式：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法分组密码的工作模式应当力求简单, 有效和易于实现需要采用适当的工作模式来隐蔽明文的统计特性、数据的格式等降低删除、重放、插入和伪造成功的机会 1．电码本(ECB)模式在 ECB 模式下明文一次被处理 b 比特，且明文的每一个分组都使用同一密钥加密。形象地说，可以认为有一个非常大的电码本，对任意一个可能的明文分组，电码本中都有一项对应于它的密文。 在 ECB 模式下明文一次被处理 b 比特，且明文的每一个分组都使用同一密钥加密。形象地说，可以认为有一个非常大的电码本，对任意一个可能的明文分组，电码本中都有一项对应于它的密文。 优点：实现简单不同明文分组的加密可并行实施，尤其是硬件实现时速度很快 缺点：相同的明文分组对应着相同的密文分组，适合加密短信息不能隐蔽明文分组的统计规律和结构规律,不能抵抗替换攻击 2．密码分组链接(CBC)模式密码分组链接方式 CBC(Cipher Block Chaining)在密码分组链接模式中，加密算法的输入是当前明文分组与前一密文分组的异或；每个分组使用同一密钥。相当于将所有的明文组连接起来了。加密函数的每次输入和明文分组之间的关系不固定。因此，64 比特的重复模式并不会被暴露。 优点：避免明密对应 缺点：不能并行加密、无法随机存取 3．密码反馈(CFB)模式核心思想：将分组密码转换为流密码，不需要使用解密，仅需使用加密若待加密消息需按字符、字节或比特处理时，可采用 CFB 模式称待加密消息按 s 比特处理的 CFB 模式为 s 比特 CFB 模式适用范围:适用于每次处理 s 比特明文块的特定需求的加密情形,能灵活适应数据各格式的需要例如,数据库加密要求加密时不能改变明文的字节长度,这时就要以明文字节为单位进行加密使用密码反馈模式能将任意分组密码转化为流密码 4．输出反馈(OFB)模式 OFB 模式在结构上类似于 CFB 模式，但反馈的内容是 DES 的输出而不是密文 5．计数器(CTR)模式 利用固定密钥 K 对自然数序列加密，将得到的密文分组序列看作密钥流序列，按加法密码的方式与明文分组逐位异或的一种方式效率，能并行处理预处理加密数据块的随机访问可证明安全简单性（不需要使用解密，仅需使用加密） 第三章防篡改——错误校验码（1）奇偶校验码（只能校验是否有错）原理：如果有 n 个有效的信息位，那么我们会在这些信息位的首部或者尾部加入一位的奇偶校验位奇校验码：整个校验码(有效信息位和校验位)中”1”的个数为奇数偶校验码：整个校验码(有效信息位和校验位)中”1”的个数为偶数 例 1： 给出两个编码 1001101 和 1010111 的奇校验码和偶校验码。设最高位为校验位，余 7 位是信息位，则对应的奇偶校验码为：奇校验： 11001101 01010111偶校验： 01001101 11010111 缺陷：（1）偶数个数缺陷检验不出（2）无法对错误定位，进而纠错 消息摘要的 3 种安全保护方式（1）使用传统密码如果只有发送方和接收方共享密钥，可以同时保证机密性。 （2）使用公钥密码发送方使用发送方的私钥加密，接收方用发送方的公钥解密。优势在于：既能提供数字签名，又能提供消息认证不需要再通信各方分发密钥 （3）使用散列函数但未使用加密假设通信双方共享秘密值 SAB 安全散列函数单向散列函数或安全散列函数可用于：消息认证以及数字签名。常见散列函数：SHA；MD5 hash 码，也称为：哈希函数、hash 值、消息摘要、数字指纹（Digitalfinger print）、压缩（Compression）函数、紧缩（Contraction ）函数、数据鉴别码 DAC（Data authentication code）、篡改检验码 MDC(Manipulation detection code)。与 MAC 的区别：与密钥无关仅是消息 M 的函数；是所有消息位的函数，具有错误检测能力（即改变消息的若干位，都会导致 hash 码的改变）。 散列函数要求Hash 函数 H(x)可以为消息、文件或数据产生“数字指纹”，用于认证的 Hash 函数 H(M)必须满足下列性质： H 可适用于任意长度的数据块； H 能够生成固定长度的输出；称为消息摘要(MessageDigest) 对任意给定数据块 x，计算 H(x)容易实现，且适合软硬件实现； 单向性：对任意给定值 h，找到 x 使 H(x) &#x3D;h 在计算上不可行； 弱碰撞抵抗( Weak Collision Resistance，WCR)：对任意给定 x，找到 y≠x 使 H(x)&#x3D;H(y)在计算上不可行； 强碰撞抵抗( Strong Collision Resistance，SCR)：找到 y ≠ x 使 H(x)&#x3D;H(y)在计算上不可行。 1、2、3 可行性要求4 抗原像攻击，保证散列码恢复不出原始消息，有秘密值参与的应用时非常重要假如散列函数不是单向的，而攻击者能够分析或截获消息 M 和散列码 C &#x3D; H(SAB||M)，则攻击者很容易发现秘密值。攻击者对散列函数取逆得到 SAB||M &#x3D; H-1 (C)。因为这时攻击者拥有 M 和 SAB||M，所以他们可以轻而易举地恢复 SAB 。5 抗第二原像攻击：对于给定的消息，不可能找到具有相同散列值的可替换消息。利用加密的散列码可防止消息被伪造。如果该性质非真则攻击者可以进行如下操作:第一，分析或截获消息及其加密的散列码；第二，根据消息产生没有加密的散列码；第三，生成具有相同散列码的可替换消息。6 抗碰撞性：防止生日攻击等。该攻击把 m 比特的散列函数强度从 2m 简化至 2m&#x2F;2 HMACHMAC 主要是为了能对信源可信性和消息完整性同时进行验证。优点：软件实现速度快、开源的代码库 摘要算法，只能够证明签名消息的完整性。 HMAC 与消息摘要 MD 的最大不同，就是有签名密钥；HMAC 被广泛的运用于网络协议的认证阶段，例如 SET、SSL 等！HMAC 运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。 黑盒设计，直接利用 hash 函数 只是一个框架，嵌入式的 hash，具有很好的移植性 保持 hash 原有特性，不发生显著退化 共享秘密值方式，处理简单 强度依赖于 hash 函数 前两个目标，优势：第一，黑盒设计可复用现有 HMAC 模块。这样，已经预先封装的大量 HMAC 代码可以不加修改地使用。第二，便于更新维护。如果想替换一个 HMAC 实现中的特定散列函数，所需做的只是除去现有的散列函数模块，放入新模块。如果需要更快的散列函数时就可以这样操作。更为重要的是，如果嵌入式散列函数的安全性受到威胁，可通过简单地用更加安全的模块取代嵌入式散列函数，从而保证了 HMAC 的安全。最后一个目标是 HMAC 相对其他散列方案最主要的优点。如果能提供有一定合理性的抗密码分析强度的嵌入式散列函数，就能够证明 HMAC 是安全的。 公钥密码算法自从公钥密码的思想提出以来，国际上已经提出了许多种公钥密码算法，但比较流行的主要有两类：一类是基于大整数因子分解问题的，其中最典型的代表是 RSA；另一类是基于离散对数问题的，比如 ElGamal 公钥密码和影响比较大的椭圆曲线（ECC）公钥密码。 *RSARSA 算法是在 1978 年由 Rivest、Shamir 和 Adleman 提出的，它的安全性依赖于大数因式分解的困难性。众所周知，大数分解和素性检测是著名的数论难题。 1、加密算法RSA 算法中模数 n 是两个大素数 p 和 q 的乘积，公钥 e 和模数 n 是公开的，而私钥 d 是保密的。RSA 算法的加密过程就是通过 n 和 e 将明文 M（M&lt;n）转化成密文 C。若用整数 M 表示明文，用整数 C 表示密文(M，C&lt;n)，则加密和解密运算为：$$加密：C &#x3D; M^e mod n （其中gcd(M,n)&#x3D;1）$$$$解密：M &#x3D; C^d mod n $$ 其中：加解密方均知道 n 和 e，加密方不知道 d，仅解密方拥有 d 值。公钥 PU&#x3D;{e.n},私钥 PR&#x3D;{d.n}。算法必须满足以下条件才可以使用：可以找到 e、d、n 的值，使得对所有的 M&lt;n，Med mod n&#x3D;M 成立；对所有的满足 M&lt;n 的值，计算 Me 和 Cd 相对容易；对给定 e 和 n，不可能推出 d。注：当 e 与 n 值较大时，n 的分解非常困难，难以求出 d。 2、密钥的产生计算 n。用户秘密地选择两个大素数 p 和 q，计算出 n&#x3D;p×q。n 称为 RSA 算法的模数。计算 φ(n)。用户计算出 n 的欧拉函数 φ(n)&#x3D;(p-1)×(q-1)，φ(n)的定义为不超过 n，且与 n 互素的正整数的个数选择 e。用户从[0, φ(n)-1]中选择一个与 φ(n)互素的数 e 作为公开的加密指数。计算 d。求解 d 满足 e×d &#x3D; 1 mod φ(n) 作为解密指数得出所需要的公开密钥和秘密密钥：公开密钥(即加密密钥) PU&#x3D;{e, n}秘密密钥(即解密密钥) PR&#x3D;{d, n} 第四章对称密钥与公开密钥密钥数密钥管理量的困难密钥管理两个问题：密钥的存储、密钥的更新，试思考：（1）当用户规模为 n 时，为保证用户两两之间进行通信，对于对称加密，需要使用的密钥对的最少个数？对于非对称加密，需要使用的密钥对的最少个数？ 对称密钥：n(n-1)&#x2F;2； 非对称密钥：n 对 （2）当用户规模为 n 时，新用户加入时，对于对称加密&#x2F;非对称加密，需要使用的密钥对的最少个数？ 对称密钥：n 对；非对称密钥：1 对 密钥分发方法 通信一方选定密钥并通过物理方法传递给另一方 可信第三方选定密钥并通过物理方法传递给通信双方 通信双方使用早先用过的密钥加密传递新的共享密钥 通过与可信第三方的安全加密链路获得共享密钥1，2 方法适合链路级加密，不适合端到端安全通信；方法 3 可以兼顾两种链路，但是早先密钥泄漏会导致安全威胁。目前常用第 4 种方法。 方法 4 的安全保障需要两种密钥：会话密钥、永久密钥 会话密钥：有时也称数据密钥，用于数据加密传输，是一次性的临时密钥 永久密钥：也称秘密密钥，用于会话密钥的分发和安全传递。方法 4 会用密钥分发中心 KDC（Key Distribution Center）管理和分发密钥。 KerberosKerberos 设计的目的是解决在分布网络环境下，用户访问网络资源时的安全问题。Kerberos 的安全不依赖于用户登陆的主机或者应用服务器，而是依赖于几个认证服务器。Kerberos 协议中有 4 个通信参与方：需要验证身份的通信双方,一个双方都信任的第三方 KDC（包含认证服务器 AS 和票据授权服务器 TGS）。将发起认证服务的一方称为客户端客户端需要访问的对象称为服务器。 在 Kerberos 认证协议中，存在四个角色（1）客户端（C，即用户）请求服务的用户（2）应用服务器（V，即提供某种服务器的服务器）向用户提供服务的一方（3）认证服务器（AS： Authentication Server）负责验证用户的身份，如果通过了认证，则向用户提供访问票据准许服务器的票据授权票据（Ticket-Granting Ticket）（4）票据授权服务器（TGS：Ticket-Granting Server）负责验证用户的票据授权票据，如果验证通过，则为用户提供访问服务器的服务授权票据（Service-Granting Ticket） 公钥证书公钥加密的意思就是公钥是公开的。通过广泛接受的公钥算法，如 RSA，任何参与者都可以给其他参与者发送他的或她的公钥，或向群体广播自己的公钥。优点：方法简单方便，缺点：任何人可以伪造公共通告具体来说：某用户可以伪装用户 A 向其他参与者发送公钥或者广播公钥。直到一段时间后用户 A 发觉了伪造并且警告其他参与者，伪装者在此之前都可以读到试图发送给 A 的加密消息，并且使用假的公钥进行认证。 解决方案：公钥证书，包含公钥、公钥所有者的 ID、可信第三方签名。可信第三方，即用户团体所信任的认证中心(CA)，如政府机构或金融机构用户可通过安全渠道将自身公钥提交给 CA 获取证书。然后用户就可以发布证书。任何需要该用户公钥的人都可以获取这个证书并且通过所附的可信签名验证其有效性 X.509 标准通用公钥证书格式：X.509 标准应用场合，大多数网络安全设施，包括：IP 安全、安全套接字层（SSL）、安全电子交易（SET）、S&#x2F;MIME PKIPKI（Public Key Infrastructure）是一个用公钥概念与技术来实施和提供安全服务的具有普适性的安全基础设施。PKI 公钥基础设施的主要任务是在开放环境中为开放性业务提供数字签名服务。 第五章SSL 会话与连接 握手协议：用来实现密钥交换和认证记录层协议：用来安全传输数据修改密码规格协议：启用新的密码参数报警协议：报警和错误 警告消息(Warning Msg) 仅仅是通告对方有关报警信息，不会导致连接的关闭。一般连接被关闭，尽管其它己经打开的连接依然可以使用，但是会话标识被标记为无效，因此可以防止通过该会话创建新的连接。致命消息 将导致连接被立即中止，并将与这个连接相关的会话（会话标识符）作废，以免这个会话被继续用来建立新的连接。 用于将 SSL 握手协议或者记录层协议等过程有关的告警传输给对方或向对方发出警告，或者中止当前连接。 握手协议本质上是一个密钥交换协议，但它也包含认证功能，因此可以视为认证和密钥交换协议握手协议主要由四个过程组成 交换安全能力 服务器认证和密钥交换 客户端认证和密钥交换 完成：通知启用新的安全参数 SSL 与 HTTPHTTP 协议在传输过程中没有提供足够的安全保护网景公司（Netscape）在 1995 年首先提出了采用 SSL 保护 HTTP 的方案（ HTTP over SSL ）HTTP over TLS 具体在 RFC 2817 和 RFC 2818 中描述HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议 Netscape 公司 1994 年所研发 第六章试回忆，你所遇到的电子邮件安全威胁？ 垃圾邮件（spam）：垃圾邮件是指未经请求的广告性电子邮件。垃圾邮件可能会包含冒充身份的钓鱼邮件或恶意软件。 钓鱼邮件（phishing）：钓鱼邮件是指伪装成合法机构或个人的电子邮件，旨在欺骗接收者提供个人信息、账户信息或密码等敏感信息。 恶意软件（malware）：恶意软件是指在电子邮件中携带的恶意代码或文件，包括病毒、木马、间谍软件等，可能会感染您的计算机或手机并窃取敏感信息。 带有恶意链接或附件的电子邮件：这些电子邮件可能包含恶意链接或附件，当接收者点击链接或打开附件时，可能会导致系统感染恶意软件或黑客攻击。 带有伪装附件的电子邮件：这些电子邮件可能包含伪装成常见文件类型的恶意附件，例如 PDF、Word 文档或压缩文件，当接收者打开附件时，可能会感染恶意软件或黑客攻击。 内部威胁：内部威胁是指由组织内部的员工或其他人员故意或无意地泄露敏感信息或攻击组织的网络安全。 S&#x2F;MIME协议提供4种与消息相关的服务：身份认证、机密性、压缩、电子邮件兼容性。 功能 典型算法 典型案例 数字签名 RSA&#x2F;SHA-256 使用SHA-256生成一条带有散列值的消息此消息摘要使用SHA-256与发送方的私钥进行加密，并包含在邮件中 消息加密 带CBC的AES-128 使用带有CBC的AES-128加密消息使用发送方生成的一次性会话密钥。会话密钥使用RSA与接收方的公钥进行加密，并包含在消息中 压缩 未定义 可以压缩消息以进行存储或传输 邮件兼容性 radix-64转换 为了提供电子邮件应用程序的透明性，可以使用radix-64conversion将加密的消息转换为ASCII字符串 PGPPGP（Pretty Good Privacy）协议，一个提供加密和认证的基于 RSA 公钥及 AES 等加密算法的加密软件系列。与S&#x2F;MIME功能基本相同，其区别在于：密钥认证：PGP协议由用户生成自己的公钥和私钥；S&#x2F;MIME由证书颁发机构（CA）颁发X.509证书。密钥分发：PGP不包含每封邮件的发送方公钥，因此邮件接收方必须单独获取发送方的公钥才能验证邮件。如在受TLS保护的网站上发布&#x2F;下载对应的PGP密钥。PGP 提供电子邮件的安全性、发送方鉴别和报文完整性。假定 A 向 B 发送电子邮件明文 X，使用 PGP 进行加密。发送方A 有三个密钥：A 的私钥、B 的公钥和 A 生成的一次性密钥。接收方B 有两个密钥：B 的私钥和 A 的公钥。 对明文邮件 X 进行 MD5 运算，得出 MD5 报文摘要，即 H&#x3D;H(X)。 用 A 的私钥对 H 进行加密（即数字签名）得出消息认证码MAC，即E(PRA，H(X)) 把它拼接在明文 X 后面，得到扩展的邮件，即 X || E(PRA，H(X)) 。 压缩。即 Z( X || E(PRA , H(X)))。 使用 A 自己生成的一次性密钥Ks对扩展的邮件进行加密，即E(Ks， Z( X || E(PRA , H(X)))) 。 用 B 的公钥对 A 生成的一次性密钥进行加密，即E(PUB， Ks) 。因为加密所用的密钥是一次性的，即密钥只会使用一次，不会出现因为密钥泄露导致之前的加密内容被解密。即使密钥被泄露了，也只会影响一次通信过程。 把加了密的一次性密钥和加了密的扩展的邮件连接发送给 B，即E(PUB , Ks) || E(Ks , Z( X||E(PRA , H(X)))) 。 把被加密的一次性密钥E(PUB , Ks)和被加密的扩展报文E(Ks，Z( X || E(PRA , H(X))) )分离开。 用 B 自己的私钥解出 A 的一次性密钥Ks，即Ks &#x3D;D(PRB, E(PUB , Ks) )。 用解出的一次性密钥Ks对报文进行解密，即Z( X || E(PRA , H(X))) &#x3D; D(Ks , E(Ks， Z( X || E(PRA , H(X))) ) 解压缩。即X || E(PRA , H(X)) &#x3D; Z-1(Z( X || E(PRA , H(X))) ) 然后分离出明文 X 和 E(PRA , H(X)) 。 用 A 的公钥对 MAC 进行解密（即签名核实），得出报文摘要 H。即H(X) &#x3D; D(PUA,E(PRA , H(X)) ) ，这个报文摘要就是 A 原先用明文邮件 X 通过 MD5 运算生成的那个报文摘要。 对签名进行验证：对分离出的明文邮件 X 进行 MD5 报文摘要运算，得出另一个报文摘要 H(X)。把 H(X) 和前面得出的 H 进行比较，是否和一样。如一样，则对邮件的发送方的鉴别就通过了，报文的完整性也得到肯定。 为何先压缩再加密？由于压缩的实质就是将有序的消息进行无序化处理，当消息规则性越强压缩效果可能越好，而加密的过程也是将消息进行无序化处理。因此，先加密再压缩是在无序的基础上变更无序，没有什么实质性作用，可能原来10G的文件，还是10G。但是若先压缩再加密，就可能使得原来10G的文件变为5G，因此传输的消息将变少。 PGP 可以只签名而不(使用对方公钥)加密整个邮件。那么我们需要去掉图中的哪些步骤呢？ 这适用于公开发表声明时，声明人为了证实自己的身份，可以用自己的私匙签名。这样就可以让收件人能确认发信人的身份，也可以防止发信人抵赖自己的声明。这一点在商业领域有很大的应用前途，它可以防止发信人抵赖和信件被途中篡改。同样的，PGP可以只加密而不签名整个邮件，以提供邮件保密性。 DNSSECDomain Name System Security Extensions (DNSSEC) DNS安全扩展，是由IETF提供的一系列DNS安全认证的机制。它提供了一种来源鉴定和数据完整性的扩展，但不去保障可用性、加密性和证实域名不存在。DNSSEC的主要思想是通过在DNS记录中添加加密签名，从而为DNS解析流程提供来源可认证和数据完整性的保障。开启DNSSEC,可有效防止DNS欺骗和缓存污染等攻击 第七章IPSec两种操作模式 传输模式 隧道模式两个数据库 安全策略数据库SPD 安全关联数据库SAD两个通信协议： AH ：认证头（Authentication Head) ESP: 封装安全载荷（Encapsulating Security Payload ）两个算法： 加密算法 认证算法三个密钥管理协议 安全关联与密钥管理协议（ISAKMP： Internet Security Association and Key Management Protocol） 因特网密钥交换管理协议（IKE： Internet Key Exchange ） Oakley： IKE的密钥交换协议 什么是隧道技术 VPN的具体实现技术是采用隧道，通过其在公网中建立企业之间的链接，将用户的数据封装在隧道中进行传输。隧道技术与接入方式无关，它可以支持各种形式的接入，如拨号方式接入、CABLE Modem、xDSL以及ISDN、E1专线和无线接入等。一个隧道协议通常包括以下几个方面： 乘客协议：被封装的协议，如PPP、SLIP； 封装协议：隧道的建立、维持和断开，如L2TP、IPSec等； 承载协议：承载经过封装后的数据包的协议，如IP和ATM等。 目前因特网上较为常见的隧道协议大致有：第二层隧道协议：PPTP（由微软、Ascend、3COM 等公司支持）、L2F（Cisco、北方电信等公司支持）、L2TP（由 IETF 起草，微软 Ascend 、Cisco、 3COM 等公司参与）第三层隧道协议：GRE（RFC 1701 ）、IPSec 隧道可在网络的任一层实现 数据链路层隧道：先把各种网络协议封装到PPP中，再把整个数据包装入隧道协议中。这种双层封装方法形成的数据包靠第二层协议进行传输。第二层隧道协议有L2F、PPTP、L2TP等。 网络层隧道：把各种网络协议直接装入隧道协议中，形成的数据包依靠第三层协议进行传输。第三层隧道协议有GRE、IPSec等。 第二层和第三层隧道协议的区别主要在于用户数据在网络协议栈的第几层被封装。其中GRE和IPSec主要用于实现专线VPN业务，L2TP主要用于实现拨号VPN业务，也可用于实现专线VPN业务。 封装安全载荷 ESP 协议格式ESP有两种模式 传输模式：仅适用于主机实现，且仅为上层协议提供保护，而不包括IP头。 隧道模式：可适用于主机和安全网关，整个数据包被封装在ESP有效负载中，并产生一个新的IP头附加在ESP头之前。","categories":[{"name":"review","slug":"review","permalink":"https://blog.newimg.ltd/categories/review/"},{"name":"general","slug":"review/general","permalink":"https://blog.newimg.ltd/categories/review/general/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"期末Web","slug":"期末Web","date":"2023-06-23T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/06/24/期末Web/","link":"","permalink":"https://blog.newimg.ltd/2023/06/24/%E6%9C%9F%E6%9C%ABWeb/","excerpt":"","text":"填空 简答1)简述 ajax 中 get 和 post 的请求方式及他们的优缺点？(6 分)1在 Ajax 中，可以使用 GET 和 POST 两种 HTTP 请求方法来发送请求和接收响应数据。 GET 请求方式： 使用 GET 请求方式时，将请求数据添加到 URL 的查询字符串中，发送至服务器。查询字符串的格式为：key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3，多个键值对之间使用&amp;符号分隔。通过 XMLHttpRequest 对象的 open()方法设置请求方式和请求 URL，然后调用 send()方法发送请求。 例子： var xhr &#x3D; new XMLHttpRequest(); xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;api&#x2F;data?key&#x3D;value&#39;, true); xhr.onreadystatechange &#x3D; function() &#123; if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123; console.log(xhr.responseText); &#125; &#125;; xhr.send(); POST 请求方式： 使用 POST 请求方式时，将请求数据作为请求主体发送至服务器。通过 XMLHttpRequest 对象的 open()方法设置请求方式和请求 URL，然后调用 send()方法发送请求，并将请求数据作为参数传递给 send()方法。请求数据可以是表单数据、JSON 数据、XML 数据等。 例子： var xhr &#x3D; new XMLHttpRequest(); xhr.open(&#39;POST&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;api&#x2F;data&#39;, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;); xhr.onreadystatechange &#x3D; function() &#123; if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123; console.log(xhr.responseText); &#125; &#125;; var data &#x3D; &#123;key: &#39;value&#39;&#125;; xhr.send(JSON.stringify(data)); 在 POST 请求中，可以通过 setRequestHeader()方法设置请求头，用于指定请求数据的格式、编码方式等信息。在上面的例子中，setRequestHeader()方法设置了 Content-Type 请求头，用于指定请求数据的格式为 JSON。 GET 请求的优点： GET 请求比 POST 请求更快，因为它不需要发送任何请求主体。 GET 请求可以被缓存，可以减少网络带宽的使用。 GET 请求允许将数据作为 URL 参数发送，可以方便地在 URL 中传递数据。 GET 请求在浏览器地址栏中可见，可以方便地调试和测试。 GET 请求的缺点： GET 请求的 URL 参数有长度限制，不适合发送大量数据。 GET 请求的 URL 参数可以被缓存到浏览器历史记录或服务器日志中，可能存在安全风险。 GET 请求不适合用于敏感数据的传输，因为 URL 参数可以被轻易地窃取。 POST 请求的优点： POST 请求可以发送大量数据，不受 URL 长度限制。 POST 请求的数据被包含在请求主体中，不会被缓存到浏览器历史记录或服务器日志中，安全性更高。 POST 请求适合用于敏感数据的传输。 POST 请求的缺点： POST 请求比 GET 请求慢，因为它需要发送请求主体。 POST 请求不支持缓存，每次请求都需要从服务器获取响应。 POST 请求的请求主体格式需要与服务器端相匹配，需要进行格式校验。 2)简述 Ajax 都有哪些优点和缺点？(6 分)Ajax（Asynchronous JavaScript and XML）是一种基于 JavaScript 和 XML 的技术，可以在不重新加载整个页面的情况下向服务器发送和获取数据。下面是 Ajax 的优点和缺点： 优点： 提高用户体验。 减少带宽使用。 提高效率。 支持多种数据格式。 可以与服务器进行部分通信。 缺点： 对搜索引擎的支持不好，搜索引擎更新的内容，影响网站的 SEO 效果。 安全性问题：由于 Ajax 可以异步发送和接收数据，可能存在安全性问题，如跨站脚本攻击（XSS）等。 对 JavaScript 的依赖性强。 不同浏览器对 Ajax 的支持程度不同，开发和维护难度高。 调试和测试会更困难，需要使用调试工具和技术。 3)简述什么是 DOM 对象？(6 分)DOM（Document Object Model，文档对象模型）是一种 API（Application Programming Interface，应用程序编程接口），它提供了一种访问和操作 HTML 或 XML 文档的方式。在 DOM 中，文档被视为一个树形结构，每个 HTML 或 XML 标签都是树中的一个节点，可以通过 DOM API 来访问和操作这些节点。 DOM 对象是指文档中的每个 HTML 或 XML 标签和文本节点，每个标签都有对应的 DOM 对象。在 JavaScript 中，可以通过 DOM API 来获取和操作 DOM 对象，从而实现对文档的访问和操作。 每个 DOM 对象都有一组属性和方法，用于获取和设置标签的属性和内容，以及与其他 DOM 对象进行交互。例如，可以通过 DOM API 来获取元素的标签名、类名、ID、样式等属性，也可以通过 DOM API 来添加、删除、修改元素的子元素、文本内容等。 DOM 对象是 JavaScript 与 HTML 或 XML 文档之间的桥梁，可以实现动态地修改和更新文档内容，从而实现交互和动态效果。 4)简述什么是 jQuery?(6 分)jQuery 是一种 JavaScript 库，它简化了 JavaScript 编程，提供了一种跨浏览器的 JavaScript 编程方式，可以帮助开发人员快速地编写动态、交互式的网页。jQuery 提供了一系列的 API，使得开发人员可以轻松地操作 DOM、处理事件、实现动画效果、进行 AJAX 交互等。 5)简述什么是 Cookie?(6 分)Cookie 是一种在客户端保存数据的技术，可以将一些数据保存在客户端的浏览器中，以便于下次访问同一网站时使用。 6)简述 Servlet 的生命周期？(6 分) 初始化阶段（Initialization）：创建 Servlet 实例，并调用其 init()方法进行初始化。 处理请求阶段（Request Processing）：当客户端发送 HTTP 请求时，Servlet 容器会将请求转发给对应的 Servlet 实例，并调用其 service()方法进行处理。 销毁阶段（Destroy）：当 Servlet 容器关闭时，或 Web 应用程序被卸载时，Servlet 实例会被销毁，并调用其 destroy()方法进行清理工作。 7)简述 JSON (JavaScript Object Notation)和 XML 的区别(6 分)JSON（JavaScript Object Notation）和 XML（eXtensible Markup Language）都是常用的数据格式，用于在不同的应用程序之间传递数据。它们之间的主要区别如下： 语法：JSON 使用 JavaScript 语法，是一种轻量级的数据交换格式，数据结构比较简单；而 XML 是一种基于标签的语言，具有非常丰富的标记及其属性，数据结构比较复杂。 可读性：JSON 数据格式可读性较高，易于理解和解析，可以直接在 JavaScript 中进行解析；而 XML 数据格式较为复杂，需要使用专门的解析器来解析。 数据大小：JSON 数据格式通常比 XML 更小，因为 JSON 不需要包含标记和属性等元信息，只包含数据本身。 扩展性：XML 具有较高的扩展性，可以通过定义新的标记和属性来扩展数据结构；而 JSON 的数据结构比较简单，不具有 XML 那样的扩展性。 性能：由于 JSON 的数据结构比较简单，解析和序列化的速度比 XML 更快，而且 JSON 的数据量比 XML 更小，可以减少网络传输的时间和带宽占用。 总之，JSON 和 XML 都有自己的优缺点，开发人员需要根据具体的应用场景来选择使用哪种数据格式。如果需要传输大量的数据或需要高性能的解析和序列化，可以选择 JSON；如果需要较高的扩展性或需要与其他系统进行数据交换，可以选择 XML。 8)JSP 有哪些内置对象？作用分别是什么？(6 分)JSP（JavaServer Pages）是一种基于 Java 技术的服务器端动态网页技术，它可以将 Java 代码嵌入到 HTML 页面中，动态生成网页内容。在 JSP 中，有以下 9 个内置对象： request：表示 HTTP 请求对象，封装了客户端请求的信息，如请求头、请求参数等。 response：表示 HTTP 响应对象，封装了服务端响应的信息，如响应头、响应内容等。 pageContext：表示 JSP 页面上下文，可以访问当前页面的其他内置对象，如 request、response 等。 session：表示 HTTP 会话对象，用于在用户访问多个页面时保存用户的状态信息。 application：表示 Web 应用程序对象，用于保存全局的信息，如 Web 应用程序的初始化参数、全局变量等。 out：表示 JSP 页面输出流，可以将内容输出到客户端浏览器。 config：表示 Servlet 配置对象，用于获取 Servlet 的配置信息。 page：表示当前 JSP 页面对象，可以访问当前页面的属性和方法。 exception：表示 JSP 页面中发生的异常对象，用于处理异常信息。 这些内置对象在 JSP 页面中都可以直接使用，它们可以帮助开发人员方便地访问和操作 HTTP 请求、HTTP 响应、HTTP 会话、Servlet 配置等信息，简化了 JSP 页面的开发。 9)简述什么是 Session？(6 分)Session 是一种在 Web 应用程序中保存用户状态信息的机制，用于跟踪用户的会话状态。在用户访问 Web 应用程序时，服务器会为每个用户创建一个 Session 对象，用于保存用户的状态信息，如登录状态、购物车信息等。Session 可以在不同的页面之间共享，可以方便地保存和传递用户的状态信息。 Session 的工作原理如下： 当用户第一次访问 Web 应用程序时，服务器会为该用户创建一个 Session 对象，并生成一个唯一的 Session ID。 服务器会将 Session ID 发送给客户端浏览器，通常是通过 Cookie 或 URL 重写的方式。 当用户访问 Web 应用程序的其他页面时，浏览器会将 Session ID 发送给服务器，服务器根据 Session ID 找到对应的 Session 对象，从而获取用户的状态信息。 当用户关闭浏览器或超时时，服务器会销毁该用户的 Session 对象，释放资源。 Session 的主要特点包括： 可跨页面共享：Session 可以在不同的页面之间共享，可以方便地保存和传递用户的状态信息。 安全性高：Session ID 是由服务器生成的唯一标识符，相对安全，不易被伪造。 可控性强：Session 可以设置超时时间和最大空闲时间等属性，可以避免资源浪费和安全问题。 存储容量限制：Session 的存储容量通常受到服务器内存的限制，如果 Session 对象过多，可能会导致服务器性能下降。 总之，Session 是一种常用的跟踪用户会话状态的机制，可以方便地保存和传递用户的状态信息，提高 Web 应用程序的交互性和用户体验。 读程题1.采用纯 javascript 实现 cookie 读取操作 &lt;html> &lt;head> &lt;title>setCookie&lt;/title> &lt;script> //脚本标识 function gefCookie(cname) &#123; //函数定义 var id=document.getElementById(\"cname\"); var name id.value()+\"=\"; //取DOM的值. var ca = document.cookie.split(';'); //将cookie值按';''拆分 for(var i = 0; i &lt; ca.length; i++) &#123; var c=ca[i].trim(); if(c.indexOf(name)=0) &#123; return c.substring(name.length, c.length) &#125;; &#125; return \"\"; &#125; &lt;/script> &lt;/head> &lt;body> &lt;input type=”text” id=\"username\" value=\"myName\"> &lt;input type=\"button\" onclick=\"getCookie ('username')\"> //点击事件 &lt;/body> &lt;/html> 2.在 Spring MVC 中定义一个控制类，实现服务分流 package edu.xupt.controller; //设置包. import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller //控制注解 @RequestMapping(\"/index\") //请求映射注解 public class IndexController &#123; @RequestMapping(\"/login\"). public String login()&#123; return \"login\"; ∥返回服务响应 &#125; @RequestMapping (\"/register\") //请求映射注解 public String register()&#123; return \"register\"; &#125; &#125;","categories":[{"name":"review","slug":"review","permalink":"https://blog.newimg.ltd/categories/review/"},{"name":"general","slug":"review/general","permalink":"https://blog.newimg.ltd/categories/review/general/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"使用juc库中的Semaphore实现ReadwriteLock","slug":"使用juc库中的Semaphore实现ReadwriteLock","date":"2023-06-10T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/06/11/使用juc库中的Semaphore实现ReadwriteLock/","link":"","permalink":"https://blog.newimg.ltd/2023/06/11/%E4%BD%BF%E7%94%A8juc%E5%BA%93%E4%B8%AD%E7%9A%84Semaphore%E5%AE%9E%E7%8E%B0ReadwriteLock/","excerpt":"","text":"使用juc库中的Semaphore实现ReadwriteLock使用读锁和写锁实现读共享和写独占特性，内部维护readCount表示读线程的个数。 实现代码如下： import java.util.concurrent.Semaphore; public class TestLock &#123; private volatile int readCount = 0; private Semaphore countLock = new Semaphore(1); private Semaphore writeLock = new Semaphore(1); public void readlock() throws InterruptedException &#123; countLock.acquire(); if (readCount == 0) writelock(); readCount += 1; countLock.release(); &#125; public void readunlock() throws InterruptedException &#123; countLock.acquire(); readCount--; if (readCount == 0) writeunlock(); countLock.release(); &#125; public void writelock() throws InterruptedException &#123; writeLock.acquire(); &#125; public void writeunlock() &#123; writeLock.release(); &#125; &#125; 测试代码如下： import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class Test &#123; private static TestLock testLock = new TestLock(); private static ReadWriteLock lock = new ReentrantReadWriteLock(); private static int num = 0; public static void main(String[] args) throws InterruptedException &#123; lock.readLock().lock(); for (int i = 0; i &lt; 20; i++) &#123; add(); &#125; for (int i = 0; i &lt; 5; i++) &#123; read(); &#125; &#125; private static void read() &#123; new Thread(()-> &#123; try &#123; testLock.readlock(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + \"start!\"); System.out.println(num); System.out.println(Thread.currentThread().getName() + \"over!\"); try &#123; testLock.readunlock(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;).start(); &#125; private static void add() &#123; new Thread(()-> &#123; try &#123; testLock.writelock(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.println(Thread.currentThread().getName() + \"start!\"); System.out.println(num + \"->\" + ++num); System.out.println(Thread.currentThread().getName() + \"over!\"); testLock.writeunlock(); &#125;).start(); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"algorithm","slug":"java/algorithm","permalink":"https://blog.newimg.ltd/categories/java/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"关于环境配置","slug":"关于环境配置","date":"2023-02-27T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/02/28/关于环境配置/","link":"","permalink":"https://blog.newimg.ltd/2023/02/28/%E5%85%B3%E4%BA%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"关于我现在使用的环境的配置教程，主要用以备份，以防电脑更换后麻烦的搜索教程。 环境按语言和框架划分JavaJava系统变量变量名变量值JAVA_HOMED:\\MySoftware\\Environment\\Java\\jdk-17.0.6 环境变量%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin Maven系统变量变量名变量值MAVEN_HOMED:\\MySoftware\\Environment\\apache-maven\\apache-maven-3.8.1 环境变量%MAVEN_HOME%\\bin Gradle系统变量变量名变量值GRADLE_HOMED:\\MySoftware\\Environment\\Gradle\\gradle-7.5.1 变量名变量值GRADLE_USER_HOMED:\\MySoftware\\Environment\\Gradle\\repository 环境变量%GRADLE_HOME%\\bin Go系统变量变量名变量值GOROOTD:\\MySoftware\\Environment\\Go\\go1.19.5.windows-amd64\\go 变量名变量值GOPATHF:\\Programing\\Myfile\\backEnd\\Go\\GoProject 环境变量%GOROOT%\\bin C环境变量D:\\MySoftware\\Environment\\C\\MinGW64_C\\bin Node使用自安装包，免环境配置","categories":[{"name":"environment","slug":"environment","permalink":"https://blog.newimg.ltd/categories/environment/"},{"name":"general","slug":"environment/general","permalink":"https://blog.newimg.ltd/categories/environment/general/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"用Github Action实现自动部署Hexo博客","slug":"用Github Action实现自动部署Hexo博客","date":"2023-02-25T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2023/02/26/用Github Action实现自动部署Hexo博客/","link":"","permalink":"https://blog.newimg.ltd/2023/02/26/%E7%94%A8Github%20Action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用Hexo和GitPages搭建博客略 配置Action申请Github_Token申请链接 配置Git_Token 创建Action文件在博客源码根目录下创建 .github/workflows/post.yaml 文件 文件内容name: Deployment # 触发条件：在 push 到 main 分支后 on: push: branches: - main jobs: Blog-Deployment: runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: - name: Checkout Blog_source env: GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; run: | git clone \"https://$GH_TOKEN@github.com/Fuxx-1/Blog_source\" - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: '18.x' - name: Install dependencies &amp; Generate static files run: | cd ./Blog_source node -v npm i -g hexo-cli npm i hexo clean hexo g - name: Deploy to Github Pages env: GIT_NAME: fuxx-1 GIT_EMAIL: $&#123;&#123; secrets.GIT_EMAIL &#125;&#125; REPO: github.com/fuxx-1/fuxx-1.github.io GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; run: | cd ./Blog_source cd ./public &amp;&amp; git init &amp;&amp; git add . git config --global user.name $GIT_NAME git config --global user.email $GIT_EMAIL git commit -m \"Site deployed by GitHub Actions from Blog_Source\" git push --force --quiet \"https://$GH_TOKEN@$REPO\" master:master 各部分代码作用解释on: push: branches: - main 触发条件：在 push 到 main 分支后 jobs: Blog-Deployment: runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: 使用ubuntu最新版系统运行 - name: Checkout Blog_source env: GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; run: | git clone \"https://$GH_TOKEN@github.com/Fuxx-1/Blog_source\" 克隆源码仓库、将 github.com/Fuxx-1/Blog_source 改为自己存放博客源码的仓库 - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: '18.x' 安装node - name: Install dependencies &amp; Generate static files run: | cd ./Blog_source node -v npm i -g hexo-cli npm i hexo clean hexo g 安装hexo环境和依赖、并生成静态页面 - name: Deploy to Github Pages env: GIT_NAME: fuxx-1 GIT_EMAIL: $&#123;&#123; secrets.GIT_EMAIL &#125;&#125; REPO: github.com/fuxx-1/fuxx-1.github.io GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; run: | cd ./Blog_source cd ./public &amp;&amp; git init &amp;&amp; git add . git config --global user.name $GIT_NAME git config --global user.email $GIT_EMAIL git commit -m \"Site deployed by GitHub Actions from Blog_Source\" git push --force --quiet \"https://$GH_TOKEN@$REPO\" master:master 将静态页面发布至pages仓库、将 GIT_NAME 改为自己的用户名、将 REPO 改为自己的pages仓库","categories":[{"name":"github","slug":"github","permalink":"https://blog.newimg.ltd/categories/github/"},{"name":"action","slug":"github/action","permalink":"https://blog.newimg.ltd/categories/github/action/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"我在校园每日打卡","slug":"我在校园每日打卡","date":"2022-09-14T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/09/15/我在校园每日打卡/","link":"","permalink":"https://blog.newimg.ltd/2022/09/15/%E6%88%91%E5%9C%A8%E6%A0%A1%E5%9B%AD%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/","excerpt":"","text":"使用本软件时造成的一切后果由用户自行承担 软件链接 软件简介为什么有它起因是设置了多次提醒后仍容易忘记每日健康打卡，在了解了相关知识后便萌生了写一个软件来同步每日状态。 注意事项1、建议使用最新版 2、重启后打开 App 以激活后台监听线程 3、打卡后会返回主页面 且发送通知（每天仅一次） 4、建议将本 App 的通知设为重要通知 更新日志 查看更新日志 v1.0.7修复通知提示问题，并加入更新检测功能，建议将本 App 的通知设为重要通知。v1.0.6修复 v1.0.5 版本部分提示的问题，修复部分情况下打卡成功但结果通知失败，同时 打卡后会返回主页面 且发送通知（每天主动通知一次，进入软件会重新通知）。v1.0.5修复 v1.0.4 版本部分提示的问题，优化安装包体积，同时 打卡后会返回主页面 且发送通知（每天仅一次）。v1.0.4修复 v1.0.3 版本教程打不开的问题，并解决 token 过期时需要手动点击允许的Bug，同时 打卡后将不会返回主页面 以供快速核校是否打卡成功。v1.0.3修复 v1.0.2 版本的问题，该问题由微信版本升级导致。v1.0.2修复新版微信中无法打卡的Bug，同时建议用户重启后打开 App 以激活后台监听线程v1.0.1修复了计时中可能会卡 [Sleep]0 的Bugv1.0.0目前未发现明显bug，可以通过评论或反馈bug 使用教程 该教程可能滞后于最新版本，查看更新日志能帮助你更好的了解软件。 查看教程前置 需要的权限及作用软件不会上传任何信息。权限作用无障碍模拟用户点击后台弹出界面打开微信自启动防止系统关闭应用后台运行用于定时打卡通知用于前台保活 查看教程 设置流程概述打开 App ，根据引导授予部分权限，进入 App ，配置自动打卡，运行测试，打开部分未引导的权限，坐等打卡（建议用户重启后打开 App 以激活后台监听线程）。设置流程建议配合图组阅读教程1、打开无障碍教程略2、脚本设置图一.④ &#x3D;&#x3D;&gt; 图四选项解释关于无障碍服务请务必打开，是脚本运行的基础关于用户条款同意后脚本才会运行手机密码仅支持字母数字，不填可能会因无法解锁屏幕而打卡失败脚本每天执行时间脚本会在该时间执行，当日执行过则不会执行第二次3、打卡设置图一.⑤ &#x3D;&#x3D;&gt; 图五选项解释关于新冠，我的状况选择无其他状况脚本才会执行是否处于居家隔离请及时更新是否需要填写体温可能不兼容部分手机，建议选否，若选是请填写体温关于打卡提交自动会打卡并返回桌面，手动会定位后停在打卡界面，建议先手动几次，再自动4、测试脚本选项【图一.① &#x3D;&#x3D;&gt; 图二.②】 可以测试脚本运行，不影响当天自动打卡5、其他设置（关于软件稳定性）请不必担心软件在后台耗电，后台进程非常省电请打开软件自启动权限和后台运行权限，以保证软件在后台正常运行。打开选项【图一.① &#x3D;&#x3D;&gt; 图二.④ &#x3D;&#x3D;&gt; 图三.①】以保证软件运行 图组 查看图片 图一图二图三图四图五 特别鸣谢AutoX","categories":[{"name":"software","slug":"software","permalink":"https://blog.newimg.ltd/categories/software/"},{"name":"introduce","slug":"software/introduce","permalink":"https://blog.newimg.ltd/categories/software/introduce/"}],"tags":[{"name":"software","slug":"software","permalink":"https://blog.newimg.ltd/tags/software/"}]},{"title":"Vscode C语言配置","slug":"Vscode C语言配置","date":"2022-09-08T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/09/09/Vscode C语言配置/","link":"","permalink":"https://blog.newimg.ltd/2022/09/09/Vscode%20C%E8%AF%AD%E8%A8%80%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Windows系统使用时请修改： c_cpp_properties.json → include路径 launch.json → gdb路径 tasks.json → bin路径 c_cpp_properties.json 查看代码 /.vscode/c_cpp_properties.json&#123; \"configurations\": [&#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\", \"C:\\\\MySoftware\\\\Environment\\\\C\\\\MinGW64_C\\\\include\"//include路径 ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"windowsSdkVersion\": \"10.0.18362.0\", \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Tools/MSVC/14.27.29110/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c99\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"msvc-x64\" &#125;], \"version\": 4 &#125; launch.json 查看代码 /.vscode/launch.json&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [&#123; \"name\": \"C/C++/C#\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": false, \"internalConsoleOptions\": \"neverOpen\", \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:\\\\MySoftware\\\\Environment\\\\C\\\\MinGW64_C\\\\bin\\\\gdb.exe\",//gdb路径 \"setupCommands\": [&#123; \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true &#125;], \"preLaunchTask\": \"gcc.exe build active file\" &#125;, &#123; \"name\": \"Python3.7\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"$&#123;file&#125;\", \"console\": \"integratedTerminal\" &#125; ] &#125; settings.json 查看代码 /.vscode/settings.json&#123; \"python.formatting.provider\": \"autopep8\", \"C_Cpp.errorSquiggles\": \"Disabled\", \"liveServer.settings.port\": 5501, \"files.associations\": &#123; \"vector\": \"cpp\", \"type_traits\": \"cpp\", \"cmath\": \"cpp\", \"limits\": \"cpp\", \"new\": \"cpp\", \"utility\": \"cpp\", \"random\": \"cpp\", \"array\": \"cpp\", \"string\": \"cpp\", \"string_view\": \"cpp\", \"bitset\": \"cpp\", \"chrono\": \"cpp\", \"algorithm\": \"cpp\" &#125; &#125; tasks.json 查看代码 /.vscode/tasks.json&#123; // 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [&#123; \"type\": \"shell\", \"label\": \"gcc.exe build active file\", \"command\": \"gcc\", \"args\": [ \"-g\", \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\", \"-std=c11\" ], \"options\": &#123; \"cwd\": \"C:\\\\MySoftware\\\\Environment\\\\C\\\\MinGW64_C\\\\bin\"//bin路径 &#125;, \"problemMatcher\": [ \"$gcc\" ], \"group\": \"build\" &#125; ] &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"config","slug":"c/config","permalink":"https://blog.newimg.ltd/categories/c/config/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"用certbot自动签署免费SSL证书实现全站HTTPS","slug":"用certbot自动签署免费SSL证书实现全站HTTPS","date":"2022-07-27T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/07/28/用certbot自动签署免费SSL证书实现全站HTTPS/","link":"","permalink":"https://blog.newimg.ltd/2022/07/28/%E7%94%A8certbot%E8%87%AA%E5%8A%A8%E7%AD%BE%E7%BD%B2%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99HTTPS/","excerpt":"","text":"起因各大浏览器会在非https网站显示不安全，且许多应用不允许访问非https网站（例如微信小程序），ssl证书就成了网站的必备选项了，但是大部分的证书是要收费的，当然也有支持申请免费证书的平台，但是不仅需要各种认证资料，而且绝大多数不能自动续签。 certbot是一个免费好用的SSL生成认证配置工具。利用certbot生成的证书是由EEF电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书。这个免费证书不仅免费，而且还相当好用，所以我们就可以利用 Let’s Encrypt 提供的免费证书部署 https 了。 配置方式本教程适用于Ubuntu20.04，其余系统未测试 首先 python-certbot-nginx 已停止支持，我们应当安装python3-certbot-nginx 1、安装Cerbotsudo apt-get update sudo apt-get install software-properties-common sudo add-apt-repository ppa:certbot/certbot sudo apt-get update sudo apt-get install python3-certbot-nginx 安装过程中，若出现 W: GPG error: http://ppa.launchpad.net/ondrej/php/ubuntu xenial InRelease: The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY 4F4EA0AAE5267A6C 可使用以下指令解决，注意后面的key要替换为提示错误中的PUBKEY sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4F4EA0AAE5267A6C 补充下Centos下安装方法（未验证）：yum install certbot 安装完可能会遇到下面两个错误，对应解决即可 解决 ImportError: cannot import name UnrewindableBodyError pip install --upgrade urllib3 utils 解决 ImportError: &#39;pyOpenSSL&#39; module missing required functionality pip install --upgrade --force-reinstall 'requests==2.6.0' 安装nginx插件 pip install certbot-nginx 2、申请证书sudo certbot --nginx --nginx-server-root /etc/nginx/ -d xxx.newimg.ltd Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator nginx, Installer nginx Enter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): xxxxx@126.com Starting new HTTPS connection (1): acme-v01.api.letsencrypt.org ------------------------------------------------------------------------------- Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must agree in order to register with the ACME server at https://acme-v01.api.letsencrypt.org/directory ------------------------------------------------------------------------------- (A)gree/(C)ancel: A ------------------------------------------------------------------------------- Would you be willing to share your email address with the Electronic Frontier Foundation, a founding partner of the Let's Encrypt project and the non-profit organization that develops Certbot? We'd like to send you email about EFF and our work to encrypt the web, protect its users and defend digital rights. ------------------------------------------------------------------------------- (Y)es/(N)o: N Obtaining a new certificate Performing the following challenges: http-01 challenge for ddy.j2do.com nginx: [warn] conflicting server name \"\" on 0.0.0.0:80, ignored nginx: [warn] conflicting server name \"\" on [::]:80, ignored Waiting for verification... Cleaning up challenges nginx: [warn] conflicting server name \"\" on 0.0.0.0:80, ignored nginx: [warn] conflicting server name \"\" on [::]:80, ignored Deploying Certificate to VirtualHost /etc/nginx/sites-enabled/ddy nginx: [warn] conflicting server name \"\" on 0.0.0.0:80, ignored nginx: [warn] conflicting server name \"\" on [::]:80, ignored Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access. ------------------------------------------------------------------------------- 1: No redirect - Make no further changes to the webserver configuration. 2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for new sites, or if you're confident your site works on HTTPS. You can undo this change by editing your web server's configuration. ------------------------------------------------------------------------------- Select the appropriate number [1-2] then [enter] (press 'c' to cancel): 1 ------------------------------------------------------------------------------- Congratulations! You have successfully enabled https://ddy.j2do.com You should test your configuration at: https://www.ssllabs.com/ssltest/analyze.html?d=ddy.j2do.com ------------------------------------------------------------------------------- IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/xxx.j2do.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/xxx.j2do.com/privkey.pem Your cert will expire on 2018-09-16. To obtain a new or tweaked version of this certificate in the future, simply run certbot again with the \"certonly\" option. To non-interactively renew *all* of your certificates, run \"certbot renew\" - Your account credentials have been saved in your Certbot configuration directory at /etc/letsencrypt. You should make a secure backup of this folder now. This configuration directory will also contain certificates and private keys obtained by Certbot so making regular backups of this folder is ideal. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 第一项必须是选择同意（A)，第二项无所谓，是将记得邮件地址添加到EFF邮件列表中，发送一些邮件给你，可以选择否（N)，这时候证书会自动生成，并根据你的域名，去查找nginx配置，自动修改nginx配置支持https，最后询问你，是否要将http的请求全部重置到https上，配置完成后告诉你一些信息，证书存放在/etc/letsencrypt位置 3、重启nignx即可sudo service nginx restart 4、自动定时申请更新证书 无论如何要记得更新证书这个事情还是很麻烦，那么certbot提供了一个自动为所有证书重新申请的命令，而且它是智能的，只申请七天内到期的证书 设置crontab命令 0 4 1 * * certbot renew --force-renew","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"ssl","slug":"linux/ssl","permalink":"https://blog.newimg.ltd/categories/linux/ssl/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"LeetCode总结","slug":"LeetCode总结","date":"2022-07-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/07/23/LeetCode总结/","link":"","permalink":"https://blog.newimg.ltd/2022/07/23/LeetCode%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.两数之和题目链接 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9 因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9 所以返回 [0, 1] 题解解法一：class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int n = nums.length; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[0]; &#125; &#125; // 官方题解 // 作者：LeetCode-Solution // 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 解法二：public class Solution &#123; public static void main(String[] args) &#123; int[] Sample = &#123;2, 7, 11, 15&#125;; System.out.println(Arrays.toString(twoSum(Sample, 9))); &#125; public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer> Temp = new HashMap&lt;>(); for (int i = 0; i &lt; nums.length; i++) &#123; int temp = target - nums[i]; if (Temp.containsKey(temp)) &#123; return new int[] &#123;i, Temp.get(temp)&#125;; &#125; else &#123; Temp.put(nums[i], i); &#125; &#125; return null; &#125; &#125; 评价LeeCode 中少有的靠暴力就能破解的题，但他的优化仍有一些难度。 知识点总结[HashMap].containsKey(Object value) HashMap 检测存在函数 2.两数相加Problem Link // @algorithm @lc id=2 lang=java // @title add-two-numbers package _2_Add_Two_Numbers; import algm.*; // @test([2,4,3],[5,6,4])=[7,0,8] // @test([0],[0])=[0] // @test([9,9,9,9,9,9,9],[9,9,9,9])=[8,9,9,9,0,0,0,1] /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */ public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int temp = 0, result = 0; ListNode lNode = new ListNode(); ListNode tNode = lNode; while (l1 != null || l2 != null || temp != 0) &#123; // 置空 result = temp; if (l1 != null) &#123; // 加入值1 result += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; // 加入值2 result += l2.val; l2 = l2.next; &#125; if (result >= 10) &#123; //进位判断 temp = 1; result -= 10; &#125; else &#123; temp = 0; &#125; //输出 tNode.next = new ListNode(result, null); tNode = tNode.next; &#125; return lNode.next; &#125; &#125; 202. 快乐数题目链接 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例：输入：19 输出：true 解释： 1^2 + 9^2 &#x3D; 82 8^2 + 2^2 &#x3D; 68 6^2 + 8^2 &#x3D; 100 1^2 + 0^2 + 0^2 &#x3D; 1 题解解法一：public class Solution &#123; public static void main(String[] args) &#123; System.out.println(isHappy(19)); &#125; public static boolean isHappy(int n) &#123; Set&lt;Integer> appear = new HashSet&lt;>(); while (n != 1 &amp;&amp; !appear.contains(n)) &#123; appear.add(n); n = getNext(n); &#125; return n == 1; &#125; private static int getNext(int n) &#123; int res = 0; while (n > 0) &#123; int temp = n % 10; res += temp * temp; n = n / 10; &#125; return res; &#125; &#125; 评价使用 HashSet 实现存储唯一值 知识点总结Set&lt;Integer&gt; appear = new HashSet&lt;&gt;(); 242.有效的字母异位词Problem Link 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true 示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false 说明: 你可以假设字符串只包含小写字母。 题解解法一：public class Solution &#123; public static void main(String[] args) &#123; String s = \"anagram\"; String t = \"nagaram\"; System.out.println(isAnagram(s, t)); &#125; public static boolean isAnagram(String s, String t) &#123; //定义新数组储存各字母的出现次数 int[] Sign = new int[26]; //统计s中出现 for (char a : s.toCharArray()) &#123; Sign[a - 'a']++; &#125; //统计t中出现 for (char a : t.toCharArray()) &#123; Sign[a - 'a']--; &#125; //判断s和t是否为字母异位词 for (int flag : Sign) &#123; if (flag != 0) &#123; return false; &#125; &#125; return true; &#125; &#125; 解法二：import java.lang.reflect.Array; import java.util.*; public class Solution2 &#123; public static void main(String[] args) &#123; String s = \"anagram\"; String t = \"nagaram\"; System.out.println(isAnagram(s, t)); &#125; public static boolean isAnagram(String s, String t) &#123; //定义新数组储存各字母的出现次数 ArrayList Sign = new ArrayList(Arrays.asList(s.split(\"\"))); //统计t中出现 for (String c : t.split(\"\")) &#123; if (!Sign.remove(c)) &#123; return false; &#125; &#125; //判断s和t是否为字母异位词 return Sign.size() == 0; &#125; &#125; 评价该题使用了 [String].toCharArray() 、Arrays.asList() 、[List].size() 、[String].split() 和 [List].remove() 方法和基本的算法逻辑 知识点总结[String].toCharArray() public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; Arrays.asList() [List].size() [String].split() [List].remove() 349. 两个数组的交集Problem Link 给定两个数组，编写一个函数来计算它们的交集。 输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2] 输出：[2] 示例 2： 输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4] 输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解解法一：import java.util.*; public class Solution &#123; public static void main(String[] args) &#123; int[] nums1 = &#123;1,2,2,1&#125;; int[] nums2 = &#123;2,2&#125;; System.out.println(Arrays.toString(intersection(nums1, nums2))); &#125; public static int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer> set = new HashSet&lt;>(); Set&lt;Integer> temp = new HashSet&lt;>(); for (int i : nums1) &#123; set.add(i); &#125; for (int i : nums2) &#123; if (set.contains(i)) &#123; temp.add(i); &#125; &#125; int[] res = new int[temp.size()]; int index = 0; for (Integer i : temp) &#123; res[index++] = i; &#125; return res; &#125; &#125; 解法二：import java.util.*; public class Solution2 &#123; public static void main(String[] args) &#123; int[] nums1 = &#123;1,2,2,1&#125;; int[] nums2 = &#123;2,2&#125;; System.out.println(Arrays.toString(intersection(nums1, nums2))); &#125; public static int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer> set = new HashSet&lt;>(); Set&lt;Integer> temp = new HashSet&lt;>(); for (int i : nums1) &#123; set.add(i); &#125; for (int i : nums2) &#123; if (set.contains(i)) &#123; temp.add(i); &#125; &#125; return temp.stream().mapToInt(x -> x).toArray(); &#125; &#125; 评价该题使用了 stream()、mapToInt() 方法、Set 数据结构和基本的算法逻辑 知识点总结stream() mapToInt() 383.赎金信题目链接 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 注意： 你可以假设两个字符串均只含有小写字母。 canConstruct(\"a\", \"b\") -> false canConstruct(\"aa\", \"ab\") -> false canConstruct(\"aa\", \"aab\") -> true 题解解法一：public class Solution &#123; public static void main(String[] args) &#123; String a = \"a\"; String b = \"b\"; System.out.println(canConstruct(a, b)); &#125; public static boolean canConstruct(String ransomNote, String magazine) &#123; int[] Flag = new int[26]; int temp; for (int i = 0; i &lt; magazine.length(); i++) &#123; temp = magazine.charAt(i) - 'a'; Flag[temp]++; &#125; for (int i = 0; i &lt; ransomNote.length(); i++) &#123; temp = ransomNote.charAt(i) - 'a'; if (Flag[temp] > 0) &#123; Flag[temp]--; &#125; else &#123; return false; &#125; &#125; return true; &#125; &#125; 评价与 字母异位词 类似，但要注意字母不能复用 454.四数相加II题目链接 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。 例如: 输入: A &#x3D; [ 1, 2] B &#x3D; [-2,-1] C &#x3D; [-1, 2] D &#x3D; [ 0, 2] 输出: 2 *解释: 两个元组如下: 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 题解解法一：public class Solution &#123; public static void main(String[] args) &#123; int[] a = &#123;1, 2&#125;; int[] b = &#123;-1, -2&#125;; int[] c = &#123;-1, 2&#125;; int[] d = &#123;0, 2&#125;; System.out.println(fourSumCount(a, b, c, d)); &#125; public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; int Result = 0; Map&lt;Integer, Integer> temp = new HashMap&lt;>(); for (int i : nums1) &#123; for (int j : nums2) &#123; if (temp.containsKey(i + j)) &#123; temp.put(i + j, temp.get(i + j) + 1); &#125; else &#123; temp.put(i + j, 1); &#125; &#125; &#125; for (int i : nums3) &#123; for (int j : nums4) &#123; if (temp.containsKey(-i - j)) &#123; Result += temp.get(-i - j); &#125; &#125; &#125; return Result; &#125; &#125; 解法二：// 参考题解 class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; int res = 0; Map&lt;Integer, Integer> map = new HashMap&lt;>(); for (int a : nums1) for (int b : nums2) map.compute(a + b, (k, v) -> v == null ? 1 : v + 1); for (int c : nums3) for (int d : nums4) res += map.getOrDefault(-c - d, 0); return res; &#125; &#125; 评价增强了对哈希表的理解 知识点总结Lambda表达式 lambda 表达式的语法格式如下： (parameters) -> expression 或 (parameters) -> &#123; statements; &#125; [HashMap].compute(K key, BiFunction remappingFunction key - 键 remappingFunction - 重新映射函数，用于重新计算值","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"algorithm","slug":"java/algorithm","permalink":"https://blog.newimg.ltd/categories/java/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"部分Java源码的阅读","slug":"部分Java源码的阅读","date":"2022-07-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"2022/07/23/部分Java源码的阅读/","link":"","permalink":"https://blog.newimg.ltd/2022/07/23/%E9%83%A8%E5%88%86Java%E6%BA%90%E7%A0%81%E7%9A%84%E9%98%85%E8%AF%BB/","excerpt":"","text":"java.langObjectPackage/* * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */ package java.lang; ClassInfo 类 Object 是类层次结构的根、每个类都有 Object 作为超类。所有对象，包括数组，均会实现这个类的方法。 sinceJDK1.0 MethodregisterNatives()带有 native 修饰的方法，不是用 Java 语言实现的，而是调用了底层 C&#x2F;C++ 的代码，这些代码为 .dll 文件，让 Java来执行。 Java程序要想调用本地方法，需要执行两个步骤： 第一，通过 System.loadLibrary() 将包含本地方法实现的动态文件加载进内存； 第二，当 Java 程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。 registerNatives() 方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。 private static native void registerNatives(); static &#123; registerNatives(); &#125; getClass()返回此 Object 的运行时类。 public final native Class&lt;?> getClass(); hashCode() 返回对象的哈希码值。这种方法是支持哈希表的，例如 java.util.HashMap 每当它在同一个对象上被多次调用时 Java 应用程序的执行， hashCode() 方法 必须始终返回相同的整数 public native int hashCode(); equals(Object obj)表示某个其他对象是否“等于”这个对象。 public boolean equals(Object obj) &#123; return (this == obj); &#125; clone()创建并返回此对象的副本。准确的意思“副本”的类可能取决于对象的类。 x.clone() !&#x3D; x x.clone().getClass() &#x3D;&#x3D; x.getClass() protected native Object clone() throws CloneNotSupportedException; toString() /** * &lt;pre> * getClass().getName() + '@' + Integer.toHexString(hashCode()) * &lt;/pre>&lt;/blockquote> * @return a string representation of the object. */ public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; notify()唤醒正在等待该对象的单个线程 监视器。如果有任何线程正在等待此对象，则其中之一选择被唤醒。选择是任意的，发生在 实施的自由裁量权。 public final native void notify(); notifyAll()唤醒所有在这个对象的监视器上等待的线程。一个线程通过调用其中一个来等待对象的监视器 public final native void notifyAll(); wait(long timeout)使当前线程等待直到另一个线程调用 java.lang.Object#notify() 方法或此对象的 java.lang.Object#notifyAll() 方法，或指定的时间已经过去。 /** * A thread can also wake up without being notified, interrupted, or * timing out, a so-called &lt;i>spurious wakeup&lt;/i>. While this will rarely * occur in practice, applications must guard against it by testing for * the condition that should have caused the thread to be awakened, and * continuing to wait if the condition is not satisfied. In other words, * waits should always occur in loops, like this one: * &lt;pre> * synchronized (obj) &#123; * while (&amp;lt;condition does not hold&amp;gt;) * obj.wait(timeout); * ... // Perform action appropriate to condition * &#125; * &lt;/pre> */ public final native void wait(long timeout) throws InterruptedException; wait(long timeout, int nanos)使当前线程等待直到另一个线程调用 java.lang.Object#notify() 方法或此对象的 java.lang.Object#notifyAll() 方法，或指定的时间（可以精确到纳秒）已经过去。 /** * &lt;pre> * 1000000*timeout+nanos&lt;/pre>&lt;/blockquote> * &lt;p> */ public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos > 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos > 0) &#123; timeout++; &#125; wait(timeout); &#125; wait()使当前线程等待直到另一个线程调用 java.lang.Object#notify() 方法或此对象的 java.lang.Object#notifyAll() 方法，换句话说，这个方法的行为就像它只是执行调用 wait(0)。 public final void wait() throws InterruptedException &#123; wait(0); &#125; finalize()垃圾回收时对象上的垃圾回收器调用,确定不再有对该对象的引用。 子类覆盖 finalize() 方法来处理系统资源或执行其他清理。 protected void finalize() throws Throwable &#123; &#125; String/* * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */ package java.lang; import java.io.ObjectStreamField; import java.io.UnsupportedEncodingException; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Formatter; import java.util.Locale; import java.util.Objects; import java.util.StringJoiner; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.regex.PatternSyntaxException; /** * The &#123;@code String&#125; class represents character strings. All * string literals in Java programs, such as &#123;@code \"abc\"&#125;, are * implemented as instances of this class. * &lt;p> * Strings are constant; their values cannot be changed after they * are created. String buffers support mutable strings. * Because String objects are immutable they can be shared. For example: * &lt;blockquote>&lt;pre> * String str = \"abc\"; * &lt;/pre>&lt;/blockquote>&lt;p> * is equivalent to: * &lt;blockquote>&lt;pre> * char data[] = &#123;'a', 'b', 'c'&#125;; * String str = new String(data); * &lt;/pre>&lt;/blockquote>&lt;p> * Here are some more examples of how strings can be used: * &lt;blockquote>&lt;pre> * System.out.println(\"abc\"); * String cde = \"cde\"; * System.out.println(\"abc\" + cde); * String c = \"abc\".substring(2,3); * String d = cde.substring(1, 2); * &lt;/pre>&lt;/blockquote> * &lt;p> * The class &#123;@code String&#125; includes methods for examining * individual characters of the sequence, for comparing strings, for * searching strings, for extracting substrings, and for creating a * copy of a string with all characters translated to uppercase or to * lowercase. Case mapping is based on the Unicode Standard version * specified by the &#123;@link java.lang.Character Character&#125; class. * &lt;p> * The Java language provides special support for the string * concatenation operator (&amp;nbsp;+&amp;nbsp;), and for conversion of * other objects to strings. String concatenation is implemented * through the &#123;@code StringBuilder&#125;(or &#123;@code StringBuffer&#125;) * class and its &#123;@code append&#125; method. * String conversions are implemented through the method * &#123;@code toString&#125;, defined by &#123;@code Object&#125; and * inherited by all classes in Java. For additional information on * string concatenation and conversion, see Gosling, Joy, and Steele, * &lt;i>The Java Language Specification&lt;/i>. * * &lt;p> Unless otherwise noted, passing a &lt;tt>null&lt;/tt> argument to a constructor * or method in this class will cause a &#123;@link NullPointerException&#125; to be * thrown. * * &lt;p>A &#123;@code String&#125; represents a string in the UTF-16 format * in which &lt;em>supplementary characters&lt;/em> are represented by &lt;em>surrogate * pairs&lt;/em> (see the section &lt;a href=\"Character.html#unicode\">Unicode * Character Representations&lt;/a> in the &#123;@code Character&#125; class for * more information). * Index values refer to &#123;@code char&#125; code units, so a supplementary * character uses two positions in a &#123;@code String&#125;. * &lt;p>The &#123;@code String&#125; class provides methods for dealing with * Unicode code points (i.e., characters), in addition to those for * dealing with Unicode code units (i.e., &#123;@code char&#125; values). * * @author Lee Boynton * @author Arthur van Hoff * @author Martin Buchholz * @author Ulf Zibis * @see java.lang.Object#toString() * @see java.lang.StringBuffer * @see java.lang.StringBuilder * @see java.nio.charset.Charset * @since JDK1.0 */ public final class String implements java.io.Serializable, Comparable&lt;String>, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; /** * Class String is special cased within the Serialization Stream Protocol. * * A String instance is written into an ObjectOutputStream according to * &lt;a href=\"&#123;@docRoot&#125;/../platform/serialization/spec/output.html\"> * Object Serialization Specification, Section 6.2, \"Stream Elements\"&lt;/a> */ private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; /** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */ public String() &#123; this.value = \"\".value; &#125; /** * Initializes a newly created &#123;@code String&#125; object so that it represents * the same sequence of characters as the argument; in other words, the * newly created string is a copy of the argument string. Unless an * explicit copy of &#123;@code original&#125; is needed, use of this constructor is * unnecessary since Strings are immutable. * * @param original * A &#123;@code String&#125; */ public String(String original) &#123; this.value = original.value; this.hash = original.hash; &#125; /** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */ public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; /** * Allocates a new &#123;@code String&#125; that contains characters from a subarray * of the character array argument. The &#123;@code offset&#125; argument is the * index of the first character of the subarray and the &#123;@code count&#125; * argument specifies the length of the subarray. The contents of the * subarray are copied; subsequent modification of the character array does * not affect the newly created string. * * @param value * Array that is the source of characters * * @param offset * The initial offset * * @param count * The length * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and &#123;@code count&#125; arguments index * characters outside the bounds of the &#123;@code value&#125; array */ public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1>>>1. if (offset > value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; /** * Allocates a new &#123;@code String&#125; that contains characters from a subarray * of the &lt;a href=\"Character.html#unicode\">Unicode code point&lt;/a> array * argument. The &#123;@code offset&#125; argument is the index of the first code * point of the subarray and the &#123;@code count&#125; argument specifies the * length of the subarray. The contents of the subarray are converted to * &#123;@code char&#125;s; subsequent modification of the &#123;@code int&#125; array does not * affect the newly created string. * * @param codePoints * Array that is the source of Unicode code points * * @param offset * The initial offset * * @param count * The length * * @throws IllegalArgumentException * If any invalid Unicode code point is found in &#123;@code * codePoints&#125; * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and &#123;@code count&#125; arguments index * characters outside the bounds of the &#123;@code codePoints&#125; array * * @since 1.5 */ public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1>>>1. if (offset > codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v; &#125; /** * Allocates a new &#123;@code String&#125; constructed from a subarray of an array * of 8-bit integer values. * * &lt;p> The &#123;@code offset&#125; argument is the index of the first byte of the * subarray, and the &#123;@code count&#125; argument specifies the length of the * subarray. * * &lt;p> Each &#123;@code byte&#125; in the subarray is converted to a &#123;@code char&#125; as * specified in the method above. * * @deprecated This method does not properly convert bytes into characters. * As of JDK&amp;nbsp;1.1, the preferred way to do this is via the * &#123;@code String&#125; constructors that take a &#123;@link * java.nio.charset.Charset&#125;, charset name, or that use the platform's * default charset. * * @param ascii * The bytes to be converted to characters * * @param hibyte * The top 8 bits of each 16-bit Unicode code unit * * @param offset * The initial offset * @param count * The length * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; or &#123;@code count&#125; argument is invalid * * @see #String(byte[], int) * @see #String(byte[], int, int, java.lang.String) * @see #String(byte[], int, int, java.nio.charset.Charset) * @see #String(byte[], int, int) * @see #String(byte[], java.lang.String) * @see #String(byte[], java.nio.charset.Charset) * @see #String(byte[]) */ @Deprecated public String(byte ascii[], int hibyte, int offset, int count) &#123; checkBounds(ascii, offset, count); char value[] = new char[count]; if (hibyte == 0) &#123; for (int i = count; i-- > 0;) &#123; value[i] = (char)(ascii[i + offset] &amp; 0xff); &#125; &#125; else &#123; hibyte &lt;&lt;= 8; for (int i = count; i-- > 0;) &#123; value[i] = (char)(hibyte | (ascii[i + offset] &amp; 0xff)); &#125; &#125; this.value = value; &#125; /** * Allocates a new &#123;@code String&#125; containing characters constructed from * an array of 8-bit integer values. Each character &lt;i>c&lt;/i>in the * resulting string is constructed from the corresponding component * &lt;i>b&lt;/i> in the byte array such that: * * &lt;blockquote>&lt;pre> * &lt;b>&lt;i>c&lt;/i>&lt;/b> == (char)(((hibyte &amp;amp; 0xff) &amp;lt;&amp;lt; 8) * | (&lt;b>&lt;i>b&lt;/i>&lt;/b> &amp;amp; 0xff)) * &lt;/pre>&lt;/blockquote> * * @deprecated This method does not properly convert bytes into * characters. As of JDK&amp;nbsp;1.1, the preferred way to do this is via the * &#123;@code String&#125; constructors that take a &#123;@link * java.nio.charset.Charset&#125;, charset name, or that use the platform's * default charset. * * @param ascii * The bytes to be converted to characters * * @param hibyte * The top 8 bits of each 16-bit Unicode code unit * * @see #String(byte[], int, int, java.lang.String) * @see #String(byte[], int, int, java.nio.charset.Charset) * @see #String(byte[], int, int) * @see #String(byte[], java.lang.String) * @see #String(byte[], java.nio.charset.Charset) * @see #String(byte[]) */ @Deprecated public String(byte ascii[], int hibyte) &#123; this(ascii, hibyte, 0, ascii.length); &#125; /* Common private utility method used to bounds check the byte array * and requested offset &amp; length values used by the String(byte[],..) * constructors. */ private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset > bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified subarray of * bytes using the specified charset. The length of the new &#123;@code String&#125; * is a function of the charset, and hence may not be equal to the length * of the subarray. * * &lt;p> The behavior of this constructor when the given bytes are not valid * in the given charset is unspecified. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @param offset * The index of the first byte to decode * * @param length * The number of bytes to decode * @param charsetName * The name of a supported &#123;@linkplain java.nio.charset.Charset * charset&#125; * * @throws UnsupportedEncodingException * If the named charset is not supported * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and &#123;@code length&#125; arguments index * characters outside the bounds of the &#123;@code bytes&#125; array * * @since JDK1.1 */ public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(\"charsetName\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified subarray of * bytes using the specified &#123;@linkplain java.nio.charset.Charset charset&#125;. * The length of the new &#123;@code String&#125; is a function of the charset, and * hence may not be equal to the length of the subarray. * * &lt;p> This method always replaces malformed-input and unmappable-character * sequences with this charset's default replacement string. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @param offset * The index of the first byte to decode * * @param length * The number of bytes to decode * * @param charset * The &#123;@linkplain java.nio.charset.Charset charset&#125; to be used to * decode the &#123;@code bytes&#125; * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and &#123;@code length&#125; arguments index * characters outside the bounds of the &#123;@code bytes&#125; array * * @since 1.6 */ public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException(\"charset\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified array of bytes * using the specified &#123;@linkplain java.nio.charset.Charset charset&#125;. The * length of the new &#123;@code String&#125; is a function of the charset, and hence * may not be equal to the length of the byte array. * * &lt;p> The behavior of this constructor when the given bytes are not valid * in the given charset is unspecified. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @param charsetName * The name of a supported &#123;@linkplain java.nio.charset.Charset * charset&#125; * * @throws UnsupportedEncodingException * If the named charset is not supported * * @since JDK1.1 */ public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified array of * bytes using the specified &#123;@linkplain java.nio.charset.Charset charset&#125;. * The length of the new &#123;@code String&#125; is a function of the charset, and * hence may not be equal to the length of the byte array. * * &lt;p> This method always replaces malformed-input and unmappable-character * sequences with this charset's default replacement string. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @param charset * The &#123;@linkplain java.nio.charset.Charset charset&#125; to be used to * decode the &#123;@code bytes&#125; * * @since 1.6 */ public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified subarray of * bytes using the platform's default charset. The length of the new * &#123;@code String&#125; is a function of the charset, and hence may not be equal * to the length of the subarray. * * &lt;p> The behavior of this constructor when the given bytes are not valid * in the default charset is unspecified. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @param offset * The index of the first byte to decode * * @param length * The number of bytes to decode * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and the &#123;@code length&#125; arguments index * characters outside the bounds of the &#123;@code bytes&#125; array * * @since JDK1.1 */ public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length); &#125; /** * Constructs a new &#123;@code String&#125; by decoding the specified array of bytes * using the platform's default charset. The length of the new &#123;@code * String&#125; is a function of the charset, and hence may not be equal to the * length of the byte array. * * &lt;p> The behavior of this constructor when the given bytes are not valid * in the default charset is unspecified. The &#123;@link * java.nio.charset.CharsetDecoder&#125; class should be used when more control * over the decoding process is required. * * @param bytes * The bytes to be decoded into characters * * @since JDK1.1 */ public String(byte bytes[]) &#123; this(bytes, 0, bytes.length); &#125; /** * Allocates a new string that contains the sequence of characters * currently contained in the string buffer argument. The contents of the * string buffer are copied; subsequent modification of the string buffer * does not affect the newly created string. * * @param buffer * A &#123;@code StringBuffer&#125; */ public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125; &#125; /** * Allocates a new string that contains the sequence of characters * currently contained in the string builder argument. The contents of the * string builder are copied; subsequent modification of the string builder * does not affect the newly created string. * * &lt;p> This constructor is provided to ease migration to &#123;@code * StringBuilder&#125;. Obtaining a string from a string builder via the &#123;@code * toString&#125; method is likely to run faster and is generally preferred. * * @param builder * A &#123;@code StringBuilder&#125; * * @since 1.5 */ public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length()); &#125; /* * Package private constructor which shares value array for speed. * this constructor is always expected to be called with share==true. * a separate constructor is needed because we already have a public * String(char[]) constructor that makes a copy of the given char[]. */ String(char[] value, boolean share) &#123; // assert share : \"unshared not supported\"; this.value = value; &#125; /** * Returns the length of this string. * The length is equal to the number of &lt;a href=\"Character.html#unicode\">Unicode * code units&lt;/a> in the string. * * @return the length of the sequence of characters represented by this * object. */ public int length() &#123; return value.length; &#125; /** * Returns &#123;@code true&#125; if, and only if, &#123;@link #length()&#125; is &#123;@code 0&#125;. * * @return &#123;@code true&#125; if &#123;@link #length()&#125; is &#123;@code 0&#125;, otherwise * &#123;@code false&#125; * * @since 1.6 */ public boolean isEmpty() &#123; return value.length == 0; &#125; /** * Returns the &#123;@code char&#125; value at the * specified index. An index ranges from &#123;@code 0&#125; to * &#123;@code length() - 1&#125;. The first &#123;@code char&#125; value of the sequence * is at index &#123;@code 0&#125;, the next at index &#123;@code 1&#125;, * and so on, as for array indexing. * * &lt;p>If the &#123;@code char&#125; value specified by the index is a * &lt;a href=\"Character.html#unicode\">surrogate&lt;/a>, the surrogate * value is returned. * * @param index the index of the &#123;@code char&#125; value. * @return the &#123;@code char&#125; value at the specified index of this string. * The first &#123;@code char&#125; value is at index &#123;@code 0&#125;. * @exception IndexOutOfBoundsException if the &#123;@code index&#125; * argument is negative or not less than the length of this * string. */ public char charAt(int index) &#123; if ((index &lt; 0) || (index >= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index]; &#125; /** * Returns the character (Unicode code point) at the specified * index. The index refers to &#123;@code char&#125; values * (Unicode code units) and ranges from &#123;@code 0&#125; to * &#123;@link #length()&#125;&#123;@code - 1&#125;. * * &lt;p> If the &#123;@code char&#125; value specified at the given index * is in the high-surrogate range, the following index is less * than the length of this &#123;@code String&#125;, and the * &#123;@code char&#125; value at the following index is in the * low-surrogate range, then the supplementary code point * corresponding to this surrogate pair is returned. Otherwise, * the &#123;@code char&#125; value at the given index is returned. * * @param index the index to the &#123;@code char&#125; values * @return the code point value of the character at the * &#123;@code index&#125; * @exception IndexOutOfBoundsException if the &#123;@code index&#125; * argument is negative or not less than the length of this * string. * @since 1.5 */ public int codePointAt(int index) &#123; if ((index &lt; 0) || (index >= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length); &#125; /** * Returns the character (Unicode code point) before the specified * index. The index refers to &#123;@code char&#125; values * (Unicode code units) and ranges from &#123;@code 1&#125; to &#123;@link * CharSequence#length() length&#125;. * * &lt;p> If the &#123;@code char&#125; value at &#123;@code (index - 1)&#125; * is in the low-surrogate range, &#123;@code (index - 2)&#125; is not * negative, and the &#123;@code char&#125; value at &#123;@code (index - * 2)&#125; is in the high-surrogate range, then the * supplementary code point value of the surrogate pair is * returned. If the &#123;@code char&#125; value at &#123;@code index - * 1&#125; is an unpaired low-surrogate or a high-surrogate, the * surrogate value is returned. * * @param index the index following the code point that should be returned * @return the Unicode code point value before the given index. * @exception IndexOutOfBoundsException if the &#123;@code index&#125; * argument is less than 1 or greater than the length * of this string. * @since 1.5 */ public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i >= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0); &#125; /** * Returns the number of Unicode code points in the specified text * range of this &#123;@code String&#125;. The text range begins at the * specified &#123;@code beginIndex&#125; and extends to the * &#123;@code char&#125; at index &#123;@code endIndex - 1&#125;. Thus the * length (in &#123;@code char&#125;s) of the text range is * &#123;@code endIndex-beginIndex&#125;. Unpaired surrogates within * the text range count as one code point each. * * @param beginIndex the index to the first &#123;@code char&#125; of * the text range. * @param endIndex the index after the last &#123;@code char&#125; of * the text range. * @return the number of Unicode code points in the specified text * range * @exception IndexOutOfBoundsException if the * &#123;@code beginIndex&#125; is negative, or &#123;@code endIndex&#125; * is larger than the length of this &#123;@code String&#125;, or * &#123;@code beginIndex&#125; is larger than &#123;@code endIndex&#125;. * @since 1.5 */ public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex > value.length || beginIndex > endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex); &#125; /** * Returns the index within this &#123;@code String&#125; that is * offset from the given &#123;@code index&#125; by * &#123;@code codePointOffset&#125; code points. Unpaired surrogates * within the text range given by &#123;@code index&#125; and * &#123;@code codePointOffset&#125; count as one code point each. * * @param index the index to be offset * @param codePointOffset the offset in code points * @return the index within this &#123;@code String&#125; * @exception IndexOutOfBoundsException if &#123;@code index&#125; * is negative or larger then the length of this * &#123;@code String&#125;, or if &#123;@code codePointOffset&#125; is positive * and the substring starting with &#123;@code index&#125; has fewer * than &#123;@code codePointOffset&#125; code points, * or if &#123;@code codePointOffset&#125; is negative and the substring * before &#123;@code index&#125; has fewer than the absolute value * of &#123;@code codePointOffset&#125; code points. * @since 1.5 */ public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index > value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset); &#125; /** * Copy characters from this string into dst starting at dstBegin. * This method doesn't perform any range checking. */ void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length); &#125; /** * Copies characters from this string into the destination character * array. * &lt;p> * The first character to be copied is at index &#123;@code srcBegin&#125;; * the last character to be copied is at index &#123;@code srcEnd-1&#125; * (thus the total number of characters to be copied is * &#123;@code srcEnd-srcBegin&#125;). The characters are copied into the * subarray of &#123;@code dst&#125; starting at index &#123;@code dstBegin&#125; * and ending at index: * &lt;blockquote>&lt;pre> * dstBegin + (srcEnd-srcBegin) - 1 * &lt;/pre>&lt;/blockquote> * * @param srcBegin index of the first character in the string * to copy. * @param srcEnd index after the last character in the string * to copy. * @param dst the destination array. * @param dstBegin the start offset in the destination array. * @exception IndexOutOfBoundsException If any of the following * is true: * &lt;ul>&lt;li>&#123;@code srcBegin&#125; is negative. * &lt;li>&#123;@code srcBegin&#125; is greater than &#123;@code srcEnd&#125; * &lt;li>&#123;@code srcEnd&#125; is greater than the length of this * string * &lt;li>&#123;@code dstBegin&#125; is negative * &lt;li>&#123;@code dstBegin+(srcEnd-srcBegin)&#125; is larger than * &#123;@code dst.length&#125;&lt;/ul> */ public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd > value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin > srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); &#125; /** * Copies characters from this string into the destination byte array. Each * byte receives the 8 low-order bits of the corresponding character. The * eight high-order bits of each character are not copied and do not * participate in the transfer in any way. * * &lt;p> The first character to be copied is at index &#123;@code srcBegin&#125;; the * last character to be copied is at index &#123;@code srcEnd-1&#125;. The total * number of characters to be copied is &#123;@code srcEnd-srcBegin&#125;. The * characters, converted to bytes, are copied into the subarray of &#123;@code * dst&#125; starting at index &#123;@code dstBegin&#125; and ending at index: * * &lt;blockquote>&lt;pre> * dstBegin + (srcEnd-srcBegin) - 1 * &lt;/pre>&lt;/blockquote> * * @deprecated This method does not properly convert characters into * bytes. As of JDK&amp;nbsp;1.1, the preferred way to do this is via the * &#123;@link #getBytes()&#125; method, which uses the platform's default charset. * * @param srcBegin * Index of the first character in the string to copy * * @param srcEnd * Index after the last character in the string to copy * * @param dst * The destination array * * @param dstBegin * The start offset in the destination array * * @throws IndexOutOfBoundsException * If any of the following is true: * &lt;ul> * &lt;li> &#123;@code srcBegin&#125; is negative * &lt;li> &#123;@code srcBegin&#125; is greater than &#123;@code srcEnd&#125; * &lt;li> &#123;@code srcEnd&#125; is greater than the length of this String * &lt;li> &#123;@code dstBegin&#125; is negative * &lt;li> &#123;@code dstBegin+(srcEnd-srcBegin)&#125; is larger than &#123;@code * dst.length&#125; * &lt;/ul> */ @Deprecated public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd > value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin > srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; Objects.requireNonNull(dst); int j = dstBegin; int n = srcEnd; int i = srcBegin; char[] val = value; /* avoid getfield opcode */ while (i &lt; n) &#123; dst[j++] = (byte)val[i++]; &#125; &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the named * charset, storing the result into a new byte array. * * &lt;p> The behavior of this method when this string cannot be encoded in * the given charset is unspecified. The &#123;@link * java.nio.charset.CharsetEncoder&#125; class should be used when more control * over the encoding process is required. * * @param charsetName * The name of a supported &#123;@linkplain java.nio.charset.Charset * charset&#125; * * @return The resultant byte array * * @throws UnsupportedEncodingException * If the named charset is not supported * * @since JDK1.1 */ public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length); &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the given * &#123;@linkplain java.nio.charset.Charset charset&#125;, storing the result into a * new byte array. * * &lt;p> This method always replaces malformed-input and unmappable-character * sequences with this charset's default replacement byte array. The * &#123;@link java.nio.charset.CharsetEncoder&#125; class should be used when more * control over the encoding process is required. * * @param charset * The &#123;@linkplain java.nio.charset.Charset&#125; to be used to encode * the &#123;@code String&#125; * * @return The resultant byte array * * @since 1.6 */ public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length); &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the * platform's default charset, storing the result into a new byte array. * * &lt;p> The behavior of this method when this string cannot be encoded in * the default charset is unspecified. The &#123;@link * java.nio.charset.CharsetEncoder&#125; class should be used when more control * over the encoding process is required. * * @return The resultant byte array * * @since JDK1.1 */ public byte[] getBytes() &#123; return StringCoding.encode(value, 0, value.length); &#125; /** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; /** * Compares this string to the specified &#123;@code StringBuffer&#125;. The result * is &#123;@code true&#125; if and only if this &#123;@code String&#125; represents the same * sequence of characters as the specified &#123;@code StringBuffer&#125;. This method * synchronizes on the &#123;@code StringBuffer&#125;. * * @param sb * The &#123;@code StringBuffer&#125; to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if this &#123;@code String&#125; represents the same * sequence of characters as the specified &#123;@code StringBuffer&#125;, * &#123;@code false&#125; otherwise * * @since 1.4 */ public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb); &#125; private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * Compares this string to the specified &#123;@code CharSequence&#125;. The * result is &#123;@code true&#125; if and only if this &#123;@code String&#125; represents the * same sequence of char values as the specified sequence. Note that if the * &#123;@code CharSequence&#125; is a &#123;@code StringBuffer&#125; then the method * synchronizes on it. * * @param cs * The sequence to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if this &#123;@code String&#125; represents the same * sequence of char values as the specified sequence, &#123;@code * false&#125; otherwise * * @since 1.5 */ public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true; &#125; /** * Compares this &#123;@code String&#125; to another &#123;@code String&#125;, ignoring case * considerations. Two strings are considered equal ignoring case if they * are of the same length and corresponding characters in the two strings * are equal ignoring case. * * &lt;p> Two characters &#123;@code c1&#125; and &#123;@code c2&#125; are considered the same * ignoring case if at least one of the following is true: * &lt;ul> * &lt;li> The two characters are the same (as compared by the * &#123;@code ==&#125; operator) * &lt;li> Applying the method &#123;@link * java.lang.Character#toUpperCase(char)&#125; to each character * produces the same result * &lt;li> Applying the method &#123;@link * java.lang.Character#toLowerCase(char)&#125; to each character * produces the same result * &lt;/ul> * * @param anotherString * The &#123;@code String&#125; to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the argument is not &#123;@code null&#125; and it * represents an equivalent &#123;@code String&#125; ignoring case; &#123;@code * false&#125; otherwise * * @see #equals(Object) */ public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); &#125; /** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The character sequence represented by this * &#123;@code String&#125; object is compared lexicographically to the * character sequence represented by the argument string. The result is * a negative integer if this &#123;@code String&#125; object * lexicographically precedes the argument string. The result is a * positive integer if this &#123;@code String&#125; object lexicographically * follows the argument string. The result is zero if the strings * are equal; &#123;@code compareTo&#125; returns &#123;@code 0&#125; exactly when * the &#123;@link #equals(Object)&#125; method would return &#123;@code true&#125;. * &lt;p> * This is the definition of lexicographic ordering. If two strings are * different, then either they have different characters at some index * that is a valid index for both strings, or their lengths are different, * or both. If they have different characters at one or more index * positions, let &lt;i>k&lt;/i> be the smallest such index; then the string * whose character at position &lt;i>k&lt;/i> has the smaller value, as * determined by using the &amp;lt; operator, lexicographically precedes the * other string. In this case, &#123;@code compareTo&#125; returns the * difference of the two character values at position &#123;@code k&#125; in * the two string -- that is, the value: * &lt;blockquote>&lt;pre> * this.charAt(k)-anotherString.charAt(k) * &lt;/pre>&lt;/blockquote> * If there is no index position at which they differ, then the shorter * string lexicographically precedes the longer string. In this case, * &#123;@code compareTo&#125; returns the difference of the lengths of the * strings -- that is, the value: * &lt;blockquote>&lt;pre> * this.length()-anotherString.length() * &lt;/pre>&lt;/blockquote> * * @param anotherString the &#123;@code String&#125; to be compared. * @return the value &#123;@code 0&#125; if the argument string is equal to * this string; a value less than &#123;@code 0&#125; if this string * is lexicographically less than the string argument; and a * value greater than &#123;@code 0&#125; if this string is * lexicographically greater than the string argument. */ public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2; &#125; /** * A Comparator that orders &#123;@code String&#125; objects as by * &#123;@code compareToIgnoreCase&#125;. This comparator is serializable. * &lt;p> * Note that this Comparator does &lt;em>not&lt;/em> take locale into account, * and will result in an unsatisfactory ordering for certain locales. * The java.text package provides &lt;em>Collators&lt;/em> to allow * locale-sensitive ordering. * * @see java.text.Collator#compare(String, String) * @since 1.2 */ public static final Comparator&lt;String> CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator implements Comparator&lt;String>, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125; &#125; /** * Compares two strings lexicographically, ignoring case * differences. This method returns an integer whose sign is that of * calling &#123;@code compareTo&#125; with normalized versions of the strings * where case differences have been eliminated by calling * &#123;@code Character.toLowerCase(Character.toUpperCase(character))&#125; on * each character. * &lt;p> * Note that this method does &lt;em>not&lt;/em> take locale into account, * and will result in an unsatisfactory ordering for certain locales. * The java.text package provides &lt;em>collators&lt;/em> to allow * locale-sensitive ordering. * * @param str the &#123;@code String&#125; to be compared. * @return a negative integer, zero, or a positive integer as the * specified String is greater than, equal to, or less * than this String, ignoring case considerations. * @see java.text.Collator#compare(String, String) * @since 1.2 */ public int compareToIgnoreCase(String str) &#123; return CASE_INSENSITIVE_ORDER.compare(this, str); &#125; /** * Tests if two string regions are equal. * &lt;p> * A substring of this &#123;@code String&#125; object is compared to a substring * of the argument other. The result is true if these substrings * represent identical character sequences. The substring of this * &#123;@code String&#125; object to be compared begins at index &#123;@code toffset&#125; * and has length &#123;@code len&#125;. The substring of other to be compared * begins at index &#123;@code ooffset&#125; and has length &#123;@code len&#125;. The * result is &#123;@code false&#125; if and only if at least one of the following * is true: * &lt;ul>&lt;li>&#123;@code toffset&#125; is negative. * &lt;li>&#123;@code ooffset&#125; is negative. * &lt;li>&#123;@code toffset+len&#125; is greater than the length of this * &#123;@code String&#125; object. * &lt;li>&#123;@code ooffset+len&#125; is greater than the length of the other * argument. * &lt;li>There is some nonnegative integer &lt;i>k&lt;/i> less than &#123;@code len&#125; * such that: * &#123;@code this.charAt(toffset + &#125;&lt;i>k&lt;/i>&#123;@code ) != other.charAt(ooffset + &#125; * &lt;i>k&lt;/i>&#123;@code )&#125; * &lt;/ul> * * @param toffset the starting offset of the subregion in this string. * @param other the string argument. * @param ooffset the starting offset of the subregion in the string * argument. * @param len the number of characters to compare. * @return &#123;@code true&#125; if the specified subregion of this string * exactly matches the specified subregion of the string argument; * &#123;@code false&#125; otherwise. */ public boolean regionMatches(int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1>>>1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset > (long)value.length - len) || (ooffset > (long)other.value.length - len)) &#123; return false; &#125; while (len-- > 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; /** * Tests if two string regions are equal. * &lt;p> * A substring of this &#123;@code String&#125; object is compared to a substring * of the argument &#123;@code other&#125;. The result is &#123;@code true&#125; if these * substrings represent character sequences that are the same, ignoring * case if and only if &#123;@code ignoreCase&#125; is true. The substring of * this &#123;@code String&#125; object to be compared begins at index * &#123;@code toffset&#125; and has length &#123;@code len&#125;. The substring of * &#123;@code other&#125; to be compared begins at index &#123;@code ooffset&#125; and * has length &#123;@code len&#125;. The result is &#123;@code false&#125; if and only if * at least one of the following is true: * &lt;ul>&lt;li>&#123;@code toffset&#125; is negative. * &lt;li>&#123;@code ooffset&#125; is negative. * &lt;li>&#123;@code toffset+len&#125; is greater than the length of this * &#123;@code String&#125; object. * &lt;li>&#123;@code ooffset+len&#125; is greater than the length of the other * argument. * &lt;li>&#123;@code ignoreCase&#125; is &#123;@code false&#125; and there is some nonnegative * integer &lt;i>k&lt;/i> less than &#123;@code len&#125; such that: * &lt;blockquote>&lt;pre> * this.charAt(toffset+k) != other.charAt(ooffset+k) * &lt;/pre>&lt;/blockquote> * &lt;li>&#123;@code ignoreCase&#125; is &#123;@code true&#125; and there is some nonnegative * integer &lt;i>k&lt;/i> less than &#123;@code len&#125; such that: * &lt;blockquote>&lt;pre> * Character.toLowerCase(this.charAt(toffset+k)) != Character.toLowerCase(other.charAt(ooffset+k)) * &lt;/pre>&lt;/blockquote> * and: * &lt;blockquote>&lt;pre> * Character.toUpperCase(this.charAt(toffset+k)) != * Character.toUpperCase(other.charAt(ooffset+k)) * &lt;/pre>&lt;/blockquote> * &lt;/ul> * * @param ignoreCase if &#123;@code true&#125;, ignore case when comparing * characters. * @param toffset the starting offset of the subregion in this * string. * @param other the string argument. * @param ooffset the starting offset of the subregion in the string * argument. * @param len the number of characters to compare. * @return &#123;@code true&#125; if the specified subregion of this string * matches the specified subregion of the string argument; * &#123;@code false&#125; otherwise. Whether the matching is exact * or case insensitive depends on the &#123;@code ignoreCase&#125; * argument. */ public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1>>>1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset > (long)value.length - len) || (ooffset > (long)other.value.length - len)) &#123; return false; &#125; while (len-- > 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true; &#125; /** * Tests if the substring of this string beginning at the * specified index starts with the specified prefix. * * @param prefix the prefix. * @param toffset where to begin looking in this string. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a prefix of the substring of this object starting * at index &#123;@code toffset&#125;; &#123;@code false&#125; otherwise. * The result is &#123;@code false&#125; if &#123;@code toffset&#125; is * negative or greater than the length of this * &#123;@code String&#125; object; otherwise the result is the same * as the result of the expression * &lt;pre> * this.substring(toffset).startsWith(prefix) * &lt;/pre> */ public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1>>>1. if ((toffset &lt; 0) || (toffset > value.length - pc)) &#123; return false; &#125; while (--pc >= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; /** * Tests if this string starts with the specified prefix. * * @param prefix the prefix. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a prefix of the character sequence represented by * this string; &#123;@code false&#125; otherwise. * Note also that &#123;@code true&#125; will be returned if the * argument is an empty string or is equal to this * &#123;@code String&#125; object as determined by the * &#123;@link #equals(Object)&#125; method. * @since 1. 0 */ public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0); &#125; /** * Tests if this string ends with the specified suffix. * * @param suffix the suffix. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a suffix of the character sequence represented by * this object; &#123;@code false&#125; otherwise. Note that the * result will be &#123;@code true&#125; if the argument is the * empty string or is equal to this &#123;@code String&#125; object * as determined by the &#123;@link #equals(Object)&#125; method. */ public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length); &#125; /** * Returns a hash code for this string. The hash code for a * &#123;@code String&#125; object is computed as * &lt;blockquote>&lt;pre> * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre>&lt;/blockquote> * using &#123;@code int&#125; arithmetic, where &#123;@code s[i]&#125; is the * &lt;i>i&lt;/i>th character of the string, &#123;@code n&#125; is the length of * the string, and &#123;@code ^&#125; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length > 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; /** * Returns the index within this string of the first occurrence of * the specified character. If a character with value * &#123;@code ch&#125; occurs in the character sequence represented by * this &#123;@code String&#125; object, then the index (in Unicode * code units) of the first such occurrence is returned. For * values of &#123;@code ch&#125; in the range from 0 to 0xFFFF * (inclusive), this is the smallest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * this.charAt(&lt;i>k&lt;/i>) == ch * &lt;/pre>&lt;/blockquote> * is true. For other values of &#123;@code ch&#125;, it is the * smallest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * this.codePointAt(&lt;i>k&lt;/i>) == ch * &lt;/pre>&lt;/blockquote> * is true. In either case, if no such character occurs in this * string, then &#123;@code -1&#125; is returned. * * @param ch a character (Unicode code point). * @return the index of the first occurrence of the character in the * character sequence represented by this object, or * &#123;@code -1&#125; if the character does not occur. */ public int indexOf(int ch) &#123; return indexOf(ch, 0); &#125; /** * Returns the index within this string of the first occurrence of the * specified character, starting the search at the specified index. * &lt;p> * If a character with value &#123;@code ch&#125; occurs in the * character sequence represented by this &#123;@code String&#125; * object at an index no smaller than &#123;@code fromIndex&#125;, then * the index of the first such occurrence is returned. For values * of &#123;@code ch&#125; in the range from 0 to 0xFFFF (inclusive), * this is the smallest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * (this.charAt(&lt;i>k&lt;/i>) == ch) &#123;@code &amp;&amp;&#125; (&lt;i>k&lt;/i> &amp;gt;= fromIndex) * &lt;/pre>&lt;/blockquote> * is true. For other values of &#123;@code ch&#125;, it is the * smallest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * (this.codePointAt(&lt;i>k&lt;/i>) == ch) &#123;@code &amp;&amp;&#125; (&lt;i>k&lt;/i> &amp;gt;= fromIndex) * &lt;/pre>&lt;/blockquote> * is true. In either case, if no such character occurs in this * string at or after position &#123;@code fromIndex&#125;, then * &#123;@code -1&#125; is returned. * * &lt;p> * There is no restriction on the value of &#123;@code fromIndex&#125;. If it * is negative, it has the same effect as if it were zero: this entire * string may be searched. If it is greater than the length of this * string, it has the same effect as if it were equal to the length of * this string: &#123;@code -1&#125; is returned. * * &lt;p>All indices are specified in &#123;@code char&#125; values * (Unicode code units). * * @param ch a character (Unicode code point). * @param fromIndex the index to start the search from. * @return the index of the first occurrence of the character in the * character sequence represented by this object that is greater * than or equal to &#123;@code fromIndex&#125;, or &#123;@code -1&#125; * if the character does not occur. */ public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex >= max) &#123; // Note: fromIndex might be near -1>>>1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125; &#125; /** * Handles (rare) calls of indexOf with a supplementary character. */ private int indexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; final char hi = Character.highSurrogate(ch); final char lo = Character.lowSurrogate(ch); final int max = value.length - 1; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the last occurrence of * the specified character. For values of &#123;@code ch&#125; in the * range from 0 to 0xFFFF (inclusive), the index (in Unicode code * units) returned is the largest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * this.charAt(&lt;i>k&lt;/i>) == ch * &lt;/pre>&lt;/blockquote> * is true. For other values of &#123;@code ch&#125;, it is the * largest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * this.codePointAt(&lt;i>k&lt;/i>) == ch * &lt;/pre>&lt;/blockquote> * is true. In either case, if no such character occurs in this * string, then &#123;@code -1&#125; is returned. The * &#123;@code String&#125; is searched backwards starting at the last * character. * * @param ch a character (Unicode code point). * @return the index of the last occurrence of the character in the * character sequence represented by this object, or * &#123;@code -1&#125; if the character does not occur. */ public int lastIndexOf(int ch) &#123; return lastIndexOf(ch, value.length - 1); &#125; /** * Returns the index within this string of the last occurrence of * the specified character, searching backward starting at the * specified index. For values of &#123;@code ch&#125; in the range * from 0 to 0xFFFF (inclusive), the index returned is the largest * value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * (this.charAt(&lt;i>k&lt;/i>) == ch) &#123;@code &amp;&amp;&#125; (&lt;i>k&lt;/i> &amp;lt;= fromIndex) * &lt;/pre>&lt;/blockquote> * is true. For other values of &#123;@code ch&#125;, it is the * largest value &lt;i>k&lt;/i> such that: * &lt;blockquote>&lt;pre> * (this.codePointAt(&lt;i>k&lt;/i>) == ch) &#123;@code &amp;&amp;&#125; (&lt;i>k&lt;/i> &amp;lt;= fromIndex) * &lt;/pre>&lt;/blockquote> * is true. In either case, if no such character occurs in this * string at or before position &#123;@code fromIndex&#125;, then * &#123;@code -1&#125; is returned. * * &lt;p>All indices are specified in &#123;@code char&#125; values * (Unicode code units). * * @param ch a character (Unicode code point). * @param fromIndex the index to start the search from. There is no * restriction on the value of &#123;@code fromIndex&#125;. If it is * greater than or equal to the length of this string, it has * the same effect as if it were equal to one less than the * length of this string: this entire string may be searched. * If it is negative, it has the same effect as if it were -1: * -1 is returned. * @return the index of the last occurrence of the character in the * character sequence represented by this object that is less * than or equal to &#123;@code fromIndex&#125;, or &#123;@code -1&#125; * if the character does not occur before that point. */ public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i >= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; /** * Handles (rare) calls of lastIndexOf with a supplementary character. */ private int lastIndexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; char hi = Character.highSurrogate(ch); char lo = Character.lowSurrogate(ch); int i = Math.min(fromIndex, value.length - 2); for (; i >= 0; i--) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the first occurrence of the * specified substring. * * &lt;p>The returned index is the smallest value &lt;i>k&lt;/i> for which: * &lt;blockquote>&lt;pre> * this.startsWith(str, &lt;i>k&lt;/i>) * &lt;/pre>&lt;/blockquote> * If no such value of &lt;i>k&lt;/i> exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the first occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */ public int indexOf(String str) &#123; return indexOf(str, 0); &#125; /** * Returns the index within this string of the first occurrence of the * specified substring, starting at the specified index. * * &lt;p>The returned index is the smallest value &lt;i>k&lt;/i> for which: * &lt;blockquote>&lt;pre> * &lt;i>k&lt;/i> &amp;gt;= fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i>k&lt;/i>) * &lt;/pre>&lt;/blockquote> * If no such value of &lt;i>k&lt;/i> exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index from which to start the search. * @return the index of the first occurrence of the specified substring, * starting at the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */ public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; /** * Code shared by String and AbstractStringBuilder to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param fromIndex the index to begin searching from. */ static int indexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return indexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex); &#125; /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param targetOffset offset of the target string. * @param targetCount count of the target string. * @param fromIndex the index to begin searching from. */ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex >= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the last occurrence of the * specified substring. The last occurrence of the empty string \"\" * is considered to occur at the index value &#123;@code this.length()&#125;. * * &lt;p>The returned index is the largest value &lt;i>k&lt;/i> for which: * &lt;blockquote>&lt;pre> * this.startsWith(str, &lt;i>k&lt;/i>) * &lt;/pre>&lt;/blockquote> * If no such value of &lt;i>k&lt;/i> exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the last occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length); &#125; /** * Returns the index within this string of the last occurrence of the * specified substring, searching backward starting at the specified index. * * &lt;p>The returned index is the largest value &lt;i>k&lt;/i> for which: * &lt;blockquote>&lt;pre> * &lt;i>k&lt;/i> &#123;@code &lt;=&#125; fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i>k&lt;/i>) * &lt;/pre>&lt;/blockquote> * If no such value of &lt;i>k&lt;/i> exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index to start the search from. * @return the index of the last occurrence of the specified substring, * searching backward from the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; /** * Code shared by String and AbstractStringBuilder to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param fromIndex the index to begin searching from. */ static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return lastIndexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex); &#125; /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param targetOffset offset of the target string. * @param targetCount count of the target string. * @param fromIndex the index to begin searching from. */ static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don't check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex > rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex; startSearchForLastChar: while (true) &#123; while (i >= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j > start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125; &#125; /** * Returns a string that is a substring of this string. The * substring begins with the character at the specified index and * extends to the end of this string. &lt;p> * Examples: * &lt;blockquote>&lt;pre> * \"unhappy\".substring(2) returns \"happy\" * \"Harbison\".substring(3) returns \"bison\" * \"emptiness\".substring(9) returns \"\" (an empty string) * &lt;/pre>&lt;/blockquote> * * @param beginIndex the beginning index, inclusive. * @return the specified substring. * @exception IndexOutOfBoundsException if * &#123;@code beginIndex&#125; is negative or larger than the * length of this &#123;@code String&#125; object. */ public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); &#125; /** * Returns a string that is a substring of this string. The * substring begins at the specified &#123;@code beginIndex&#125; and * extends to the character at index &#123;@code endIndex - 1&#125;. * Thus the length of the substring is &#123;@code endIndex-beginIndex&#125;. * &lt;p> * Examples: * &lt;blockquote>&lt;pre> * \"hamburger\".substring(4, 8) returns \"urge\" * \"smiles\".substring(1, 5) returns \"mile\" * &lt;/pre>&lt;/blockquote> * * @param beginIndex the beginning index, inclusive. * @param endIndex the ending index, exclusive. * @return the specified substring. * @exception IndexOutOfBoundsException if the * &#123;@code beginIndex&#125; is negative, or * &#123;@code endIndex&#125; is larger than the length of * this &#123;@code String&#125; object, or * &#123;@code beginIndex&#125; is larger than * &#123;@code endIndex&#125;. */ public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex > value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; /** * Returns a character sequence that is a subsequence of this sequence. * * &lt;p> An invocation of this method of the form * * &lt;blockquote>&lt;pre> * str.subSequence(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote> * * behaves in exactly the same way as the invocation * * &lt;blockquote>&lt;pre> * str.substring(begin,&amp;nbsp;end)&lt;/pre>&lt;/blockquote> * * @apiNote * This method is defined so that the &#123;@code String&#125; class can implement * the &#123;@link CharSequence&#125; interface. * * @param beginIndex the begin index, inclusive. * @param endIndex the end index, exclusive. * @return the specified subsequence. * * @throws IndexOutOfBoundsException * if &#123;@code beginIndex&#125; or &#123;@code endIndex&#125; is negative, * if &#123;@code endIndex&#125; is greater than &#123;@code length()&#125;, * or if &#123;@code beginIndex&#125; is greater than &#123;@code endIndex&#125; * * @since 1.4 * @spec JSR-51 */ public CharSequence subSequence(int beginIndex, int endIndex) &#123; return this.substring(beginIndex, endIndex); &#125; /** * Concatenates the specified string to the end of this string. * &lt;p> * If the length of the argument string is &#123;@code 0&#125;, then this * &#123;@code String&#125; object is returned. Otherwise, a * &#123;@code String&#125; object is returned that represents a character * sequence that is the concatenation of the character sequence * represented by this &#123;@code String&#125; object and the character * sequence represented by the argument string.&lt;p> * Examples: * &lt;blockquote>&lt;pre> * \"cares\".concat(\"s\") returns \"caress\" * \"to\".concat(\"get\").concat(\"her\") returns \"together\" * &lt;/pre>&lt;/blockquote> * * @param str the &#123;@code String&#125; that is concatenated to the end * of this &#123;@code String&#125;. * @return a string that represents the concatenation of this object's * characters followed by the string argument's characters. */ public String concat(String str) &#123; if (str.isEmpty()) &#123; return this; &#125; int len = value.length; int otherLen = str.length(); char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); &#125; /** * Returns a string resulting from replacing all occurrences of * &#123;@code oldChar&#125; in this string with &#123;@code newChar&#125;. * &lt;p> * If the character &#123;@code oldChar&#125; does not occur in the * character sequence represented by this &#123;@code String&#125; object, * then a reference to this &#123;@code String&#125; object is returned. * Otherwise, a &#123;@code String&#125; object is returned that * represents a character sequence identical to the character sequence * represented by this &#123;@code String&#125; object, except that every * occurrence of &#123;@code oldChar&#125; is replaced by an occurrence * of &#123;@code newChar&#125;. * &lt;p> * Examples: * &lt;blockquote>&lt;pre> * \"mesquite in your cellar\".replace('e', 'o') * returns \"mosquito in your collar\" * \"the war of baronets\".replace('r', 'y') * returns \"the way of bayonets\" * \"sparring with a purple porpoise\".replace('p', 't') * returns \"starring with a turtle tortoise\" * \"JonL\".replace('q', 'x') returns \"JonL\" (no change) * &lt;/pre>&lt;/blockquote> * * @param oldChar the old character. * @param newChar the new character. * @return a string derived from this string by replacing every * occurrence of &#123;@code oldChar&#125; with &#123;@code newChar&#125;. */ public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this; &#125; /** * Tells whether or not this string matches the given &lt;a * href=\"../util/regex/Pattern.html#sum\">regular expression&lt;/a>. * * &lt;p> An invocation of this method of the form * &lt;i>str&lt;/i>&#123;@code .matches(&#125;&lt;i>regex&lt;/i>&#123;@code )&#125; yields exactly the * same result as the expression * * &lt;blockquote> * &#123;@link java.util.regex.Pattern&#125;.&#123;@link java.util.regex.Pattern#matches(String,CharSequence) * matches(&lt;i>regex&lt;/i>, &lt;i>str&lt;/i>)&#125; * &lt;/blockquote> * * @param regex * the regular expression to which this string is to be matched * * @return &#123;@code true&#125; if, and only if, this string matches the * given regular expression * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public boolean matches(String regex) &#123; return Pattern.matches(regex, this); &#125; /** * Returns true if and only if this string contains the specified * sequence of char values. * * @param s the sequence to search for * @return true if this string contains &#123;@code s&#125;, false otherwise * @since 1.5 */ public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) > -1; &#125; /** * Replaces the first substring of this string that matches the given &lt;a * href=\"../util/regex/Pattern.html#sum\">regular expression&lt;/a> with the * given replacement. * * &lt;p> An invocation of this method of the form * &lt;i>str&lt;/i>&#123;@code .replaceFirst(&#125;&lt;i>regex&lt;/i>&#123;@code ,&#125; &lt;i>repl&lt;/i>&#123;@code )&#125; * yields exactly the same result as the expression * * &lt;blockquote> * &lt;code> * &#123;@link java.util.regex.Pattern&#125;.&#123;@link * java.util.regex.Pattern#compile compile&#125;(&lt;i>regex&lt;/i>).&#123;@link * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher&#125;(&lt;i>str&lt;/i>).&#123;@link * java.util.regex.Matcher#replaceFirst replaceFirst&#125;(&lt;i>repl&lt;/i>) * &lt;/code> * &lt;/blockquote> * *&lt;p> * Note that backslashes (&#123;@code \\&#125;) and dollar signs (&#123;@code $&#125;) in the * replacement string may cause the results to be different than if it were * being treated as a literal replacement string; see * &#123;@link java.util.regex.Matcher#replaceFirst&#125;. * Use &#123;@link java.util.regex.Matcher#quoteReplacement&#125; to suppress the special * meaning of these characters, if desired. * * @param regex * the regular expression to which this string is to be matched * @param replacement * the string to be substituted for the first match * * @return The resulting &#123;@code String&#125; * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement); &#125; /** * Replaces each substring of this string that matches the given &lt;a * href=\"../util/regex/Pattern.html#sum\">regular expression&lt;/a> with the * given replacement. * * &lt;p> An invocation of this method of the form * &lt;i>str&lt;/i>&#123;@code .replaceAll(&#125;&lt;i>regex&lt;/i>&#123;@code ,&#125; &lt;i>repl&lt;/i>&#123;@code )&#125; * yields exactly the same result as the expression * * &lt;blockquote> * &lt;code> * &#123;@link java.util.regex.Pattern&#125;.&#123;@link * java.util.regex.Pattern#compile compile&#125;(&lt;i>regex&lt;/i>).&#123;@link * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher&#125;(&lt;i>str&lt;/i>).&#123;@link * java.util.regex.Matcher#replaceAll replaceAll&#125;(&lt;i>repl&lt;/i>) * &lt;/code> * &lt;/blockquote> * *&lt;p> * Note that backslashes (&#123;@code \\&#125;) and dollar signs (&#123;@code $&#125;) in the * replacement string may cause the results to be different than if it were * being treated as a literal replacement string; see * &#123;@link java.util.regex.Matcher#replaceAll Matcher.replaceAll&#125;. * Use &#123;@link java.util.regex.Matcher#quoteReplacement&#125; to suppress the special * meaning of these characters, if desired. * * @param regex * the regular expression to which this string is to be matched * @param replacement * the string to be substituted for each match * * @return The resulting &#123;@code String&#125; * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement); &#125; /** * Replaces each substring of this string that matches the literal target * sequence with the specified literal replacement sequence. The * replacement proceeds from the beginning of the string to the end, for * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in * \"ba\" rather than \"ab\". * * @param target The sequence of char values to be replaced * @param replacement The replacement sequence of char values * @return The resulting string * @since 1.5 */ public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString())); &#125; /** * Splits this string around matches of the given * &lt;a href=\"../util/regex/Pattern.html#sum\">regular expression&lt;/a>. * * &lt;p> The array returned by this method contains each substring of this * string that is terminated by another substring that matches the given * expression or is terminated by the end of the string. The substrings in * the array are in the order in which they occur in this string. If the * expression does not match any part of the input then the resulting array * has just one element, namely this string. * * &lt;p> When there is a positive-width match at the beginning of this * string then an empty leading substring is included at the beginning * of the resulting array. A zero-width match at the beginning however * never produces such empty leading substring. * * &lt;p> The &#123;@code limit&#125; parameter controls the number of times the * pattern is applied and therefore affects the length of the resulting * array. If the limit &lt;i>n&lt;/i> is greater than zero then the pattern * will be applied at most &lt;i>n&lt;/i>&amp;nbsp;-&amp;nbsp;1 times, the array's * length will be no greater than &lt;i>n&lt;/i>, and the array's last entry * will contain all input beyond the last matched delimiter. If &lt;i>n&lt;/i> * is non-positive then the pattern will be applied as many times as * possible and the array can have any length. If &lt;i>n&lt;/i> is zero then * the pattern will be applied as many times as possible, the array can * have any length, and trailing empty strings will be discarded. * * &lt;p> The string &#123;@code \"boo:and:foo\"&#125;, for example, yields the * following results with these parameters: * * &lt;blockquote>&lt;table cellpadding=1 cellspacing=0 summary=\"Split example showing regex, limit, and result\"> * &lt;tr> * &lt;th>Regex&lt;/th> * &lt;th>Limit&lt;/th> * &lt;th>Result&lt;/th> * &lt;/tr> * &lt;tr>&lt;td align=center>:&lt;/td> * &lt;td align=center>2&lt;/td> * &lt;td>&#123;@code &#123; \"boo\", \"and:foo\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>:&lt;/td> * &lt;td align=center>5&lt;/td> * &lt;td>&#123;@code &#123; \"boo\", \"and\", \"foo\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>:&lt;/td> * &lt;td align=center>-2&lt;/td> * &lt;td>&#123;@code &#123; \"boo\", \"and\", \"foo\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>o&lt;/td> * &lt;td align=center>5&lt;/td> * &lt;td>&#123;@code &#123; \"b\", \"\", \":and:f\", \"\", \"\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>o&lt;/td> * &lt;td align=center>-2&lt;/td> * &lt;td>&#123;@code &#123; \"b\", \"\", \":and:f\", \"\", \"\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>o&lt;/td> * &lt;td align=center>0&lt;/td> * &lt;td>&#123;@code &#123; \"b\", \"\", \":and:f\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;/table>&lt;/blockquote> * * &lt;p> An invocation of this method of the form * &lt;i>str.&lt;/i>&#123;@code split(&#125;&lt;i>regex&lt;/i>&#123;@code ,&#125;&amp;nbsp;&lt;i>n&lt;/i>&#123;@code )&#125; * yields the same result as the expression * * &lt;blockquote> * &lt;code> * &#123;@link java.util.regex.Pattern&#125;.&#123;@link * java.util.regex.Pattern#compile compile&#125;(&lt;i>regex&lt;/i>).&#123;@link * java.util.regex.Pattern#split(java.lang.CharSequence,int) split&#125;(&lt;i>str&lt;/i>,&amp;nbsp;&lt;i>n&lt;/i>) * &lt;/code> * &lt;/blockquote> * * * @param regex * the delimiting regular expression * * @param limit * the result threshold, as described above * * @return the array of strings computed by splitting this string * around matches of the given regular expression * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters \".$|()[&#123;^?*+\\\\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; \".$|()[&#123;^?*+\\\\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch > Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit > 0; ArrayList&lt;String> list = new ArrayList&lt;>(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize > 0 &amp;&amp; list.get(resultSize - 1).isEmpty()) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit); &#125; /** * Splits this string around matches of the given &lt;a * href=\"../util/regex/Pattern.html#sum\">regular expression&lt;/a>. * * &lt;p> This method works as if by invoking the two-argument &#123;@link * #split(String, int) split&#125; method with the given expression and a limit * argument of zero. Trailing empty strings are therefore not included in * the resulting array. * * &lt;p> The string &#123;@code \"boo:and:foo\"&#125;, for example, yields the following * results with these expressions: * * &lt;blockquote>&lt;table cellpadding=1 cellspacing=0 summary=\"Split examples showing regex and result\"> * &lt;tr> * &lt;th>Regex&lt;/th> * &lt;th>Result&lt;/th> * &lt;/tr> * &lt;tr>&lt;td align=center>:&lt;/td> * &lt;td>&#123;@code &#123; \"boo\", \"and\", \"foo\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;tr>&lt;td align=center>o&lt;/td> * &lt;td>&#123;@code &#123; \"b\", \"\", \":and:f\" &#125;&#125;&lt;/td>&lt;/tr> * &lt;/table>&lt;/blockquote> * * * @param regex * the delimiting regular expression * * @return the array of strings computed by splitting this string * around matches of the given regular expression * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public String[] split(String regex) &#123; return split(regex, 0); &#125; /** * Returns a new String composed of copies of the * &#123;@code CharSequence elements&#125; joined together with a copy of * the specified &#123;@code delimiter&#125;. * * &lt;blockquote>For example, * &lt;pre>&#123;@code * String message = String.join(\"-\", \"Java\", \"is\", \"cool\"); * // message returned is: \"Java-is-cool\" * &#125;&lt;/pre>&lt;/blockquote> * * Note that if an element is null, then &#123;@code \"null\"&#125; is added. * * @param delimiter the delimiter that separates each element * @param elements the elements to join together. * * @return a new &#123;@code String&#125; that is composed of the &#123;@code elements&#125; * separated by the &#123;@code delimiter&#125; * * @throws NullPointerException If &#123;@code delimiter&#125; or &#123;@code elements&#125; * is &#123;@code null&#125; * * @see java.util.StringJoiner * @since 1.8 */ public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; /** * Returns a new &#123;@code String&#125; composed of copies of the * &#123;@code CharSequence elements&#125; joined together with a copy of the * specified &#123;@code delimiter&#125;. * * &lt;blockquote>For example, * &lt;pre>&#123;@code * List&lt;String> strings = new LinkedList&lt;>(); * strings.add(\"Java\");strings.add(\"is\"); * strings.add(\"cool\"); * String message = String.join(\" \", strings); * //message returned is: \"Java is cool\" * * Set&lt;String> strings = new LinkedHashSet&lt;>(); * strings.add(\"Java\"); strings.add(\"is\"); * strings.add(\"very\"); strings.add(\"cool\"); * String message = String.join(\"-\", strings); * //message returned is: \"Java-is-very-cool\" * &#125;&lt;/pre>&lt;/blockquote> * * Note that if an individual element is &#123;@code null&#125;, then &#123;@code \"null\"&#125; is added. * * @param delimiter a sequence of characters that is used to separate each * of the &#123;@code elements&#125; in the resulting &#123;@code String&#125; * @param elements an &#123;@code Iterable&#125; that will have its &#123;@code elements&#125; * joined together. * * @return a new &#123;@code String&#125; that is composed from the &#123;@code elements&#125; * argument * * @throws NullPointerException If &#123;@code delimiter&#125; or &#123;@code elements&#125; * is &#123;@code null&#125; * * @see #join(CharSequence,CharSequence...) * @see java.util.StringJoiner * @since 1.8 */ public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence> elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; /** * Converts all of the characters in this &#123;@code String&#125; to lower * case using the rules of the given &#123;@code Locale&#125;. Case mapping is based * on the Unicode Standard version specified by the &#123;@link java.lang.Character Character&#125; * class. Since case mappings are not always 1:1 char mappings, the resulting * &#123;@code String&#125; may be a different length than the original &#123;@code String&#125;. * &lt;p> * Examples of lowercase mappings are in the following table: * &lt;table border=\"1\" summary=\"Lowercase mapping examples showing language code of locale, upper case, lower case, and description\"> * &lt;tr> * &lt;th>Language Code of Locale&lt;/th> * &lt;th>Upper Case&lt;/th> * &lt;th>Lower Case&lt;/th> * &lt;th>Description&lt;/th> * &lt;/tr> * &lt;tr> * &lt;td>tr (Turkish)&lt;/td> * &lt;td>&amp;#92;u0130&lt;/td> * &lt;td>&amp;#92;u0069&lt;/td> * &lt;td>capital letter I with dot above -&amp;gt; small letter i&lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>tr (Turkish)&lt;/td> * &lt;td>&amp;#92;u0049&lt;/td> * &lt;td>&amp;#92;u0131&lt;/td> * &lt;td>capital letter I -&amp;gt; small letter dotless i &lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>(all)&lt;/td> * &lt;td>French Fries&lt;/td> * &lt;td>french fries&lt;/td> * &lt;td>lowercased all chars in String&lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>(all)&lt;/td> * &lt;td>&lt;img src=\"doc-files/capiota.gif\" alt=\"capiota\">&lt;img src=\"doc-files/capchi.gif\" alt=\"capchi\"> * &lt;img src=\"doc-files/captheta.gif\" alt=\"captheta\">&lt;img src=\"doc-files/capupsil.gif\" alt=\"capupsil\"> * &lt;img src=\"doc-files/capsigma.gif\" alt=\"capsigma\">&lt;/td> * &lt;td>&lt;img src=\"doc-files/iota.gif\" alt=\"iota\">&lt;img src=\"doc-files/chi.gif\" alt=\"chi\"> * &lt;img src=\"doc-files/theta.gif\" alt=\"theta\">&lt;img src=\"doc-files/upsilon.gif\" alt=\"upsilon\"> * &lt;img src=\"doc-files/sigma1.gif\" alt=\"sigma\">&lt;/td> * &lt;td>lowercased all chars in String&lt;/td> * &lt;/tr> * &lt;/table> * * @param locale use the case transformation rules for this locale * @return the &#123;@code String&#125;, converted to lowercase. * @see java.lang.String#toLowerCase() * @see java.lang.String#toUpperCase() * @see java.lang.String#toUpperCase(Locale) * @since 1.1 */ public String toLowerCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstUpper = 0 ; firstUpper &lt; len; ) &#123; char c = value[firstUpper]; if ((c >= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) &#123; break scan; &#125; firstUpper += Character.charCount(supplChar); &#125; else &#123; if (c != Character.toLowerCase(c)) &#123; break scan; &#125; firstUpper++; &#125; &#125; return this; &#125; char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == \"tr\" || lang == \"az\" || lang == \"lt\"); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar >= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent || srcChar == '\\u03A3' || // GREEK CAPITAL LETTER SIGMA srcChar == '\\u0130') &#123; // LATIN CAPITAL LETTER I WITH DOT ABOVE lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); &#125; else &#123; lowerChar = Character.toLowerCase(srcChar); &#125; if ((lowerChar == Character.ERROR) || (lowerChar >= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (lowerChar == Character.ERROR) &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; lowerCharArray = Character.toChars(lowerChar); &#125; /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen > srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = lowerCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)lowerChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; /** * Converts all of the characters in this &#123;@code String&#125; to lower * case using the rules of the default locale. This is equivalent to calling * &#123;@code toLowerCase(Locale.getDefault())&#125;. * &lt;p> * &lt;b>Note:&lt;/b> This method is locale sensitive, and may produce unexpected * results if used for strings that are intended to be interpreted locale * independently. * Examples are programming language identifiers, protocol keys, and HTML * tags. * For instance, &#123;@code \"TITLE\".toLowerCase()&#125; in a Turkish locale * returns &#123;@code \"t\\u005Cu0131tle\"&#125;, where '\\u005Cu0131' is the * LATIN SMALL LETTER DOTLESS I character. * To obtain correct results for locale insensitive strings, use * &#123;@code toLowerCase(Locale.ROOT)&#125;. * &lt;p> * @return the &#123;@code String&#125;, converted to lowercase. * @see java.lang.String#toLowerCase(Locale) */ public String toLowerCase() &#123; return toLowerCase(Locale.getDefault()); &#125; /** * Converts all of the characters in this &#123;@code String&#125; to upper * case using the rules of the given &#123;@code Locale&#125;. Case mapping is based * on the Unicode Standard version specified by the &#123;@link java.lang.Character Character&#125; * class. Since case mappings are not always 1:1 char mappings, the resulting * &#123;@code String&#125; may be a different length than the original &#123;@code String&#125;. * &lt;p> * Examples of locale-sensitive and 1:M case mappings are in the following table. * * &lt;table border=\"1\" summary=\"Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\"> * &lt;tr> * &lt;th>Language Code of Locale&lt;/th> * &lt;th>Lower Case&lt;/th> * &lt;th>Upper Case&lt;/th> * &lt;th>Description&lt;/th> * &lt;/tr> * &lt;tr> * &lt;td>tr (Turkish)&lt;/td> * &lt;td>&amp;#92;u0069&lt;/td> * &lt;td>&amp;#92;u0130&lt;/td> * &lt;td>small letter i -&amp;gt; capital letter I with dot above&lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>tr (Turkish)&lt;/td> * &lt;td>&amp;#92;u0131&lt;/td> * &lt;td>&amp;#92;u0049&lt;/td> * &lt;td>small letter dotless i -&amp;gt; capital letter I&lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>(all)&lt;/td> * &lt;td>&amp;#92;u00df&lt;/td> * &lt;td>&amp;#92;u0053 &amp;#92;u0053&lt;/td> * &lt;td>small letter sharp s -&amp;gt; two letters: SS&lt;/td> * &lt;/tr> * &lt;tr> * &lt;td>(all)&lt;/td> * &lt;td>Fahrvergn&amp;uuml;gen&lt;/td> * &lt;td>FAHRVERGN&amp;Uuml;GEN&lt;/td> * &lt;td>&lt;/td> * &lt;/tr> * &lt;/table> * @param locale use the case transformation rules for this locale * @return the &#123;@code String&#125;, converted to uppercase. * @see java.lang.String#toUpperCase() * @see java.lang.String#toLowerCase() * @see java.lang.String#toLowerCase(Locale) * @since 1.1 */ public String toUpperCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstLower; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstLower = 0 ; firstLower &lt; len; ) &#123; int c = (int)value[firstLower]; int srcCount; if ((c >= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; c = codePointAt(firstLower); srcCount = Character.charCount(c); &#125; else &#123; srcCount = 1; &#125; int upperCaseChar = Character.toUpperCaseEx(c); if ((upperCaseChar == Character.ERROR) || (c != upperCaseChar)) &#123; break scan; &#125; firstLower += srcCount; &#125; return this; &#125; /* result may grow, so i+resultOffset is the write location in result */ int resultOffset = 0; char[] result = new char[len]; /* may grow */ /* Just copy the first few upperCase characters. */ System.arraycopy(value, 0, result, 0, firstLower); String lang = locale.getLanguage(); boolean localeDependent = (lang == \"tr\" || lang == \"az\" || lang == \"lt\"); char[] upperCharArray; int upperChar; int srcChar; int srcCount; for (int i = firstLower; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar >= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent) &#123; upperChar = ConditionalSpecialCasing.toUpperCaseEx(this, i, locale); &#125; else &#123; upperChar = Character.toUpperCaseEx(srcChar); &#125; if ((upperChar == Character.ERROR) || (upperChar >= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (upperChar == Character.ERROR) &#123; if (localeDependent) &#123; upperCharArray = ConditionalSpecialCasing.toUpperCaseCharArray(this, i, locale); &#125; else &#123; upperCharArray = Character.toUpperCaseCharArray(srcChar); &#125; &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; upperCharArray = Character.toChars(upperChar); &#125; /* Grow result if needed */ int mapLen = upperCharArray.length; if (mapLen > srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = upperCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)upperChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; /** * Converts all of the characters in this &#123;@code String&#125; to upper * case using the rules of the default locale. This method is equivalent to * &#123;@code toUpperCase(Locale.getDefault())&#125;. * &lt;p> * &lt;b>Note:&lt;/b> This method is locale sensitive, and may produce unexpected * results if used for strings that are intended to be interpreted locale * independently. * Examples are programming language identifiers, protocol keys, and HTML * tags. * For instance, &#123;@code \"title\".toUpperCase()&#125; in a Turkish locale * returns &#123;@code \"T\\u005Cu0130TLE\"&#125;, where '\\u005Cu0130' is the * LATIN CAPITAL LETTER I WITH DOT ABOVE character. * To obtain correct results for locale insensitive strings, use * &#123;@code toUpperCase(Locale.ROOT)&#125;. * &lt;p> * @return the &#123;@code String&#125;, converted to uppercase. * @see java.lang.String#toUpperCase(Locale) */ public String toUpperCase() &#123; return toUpperCase(Locale.getDefault()); &#125; /** * Returns a string whose value is this string, with any leading and trailing * whitespace removed. * &lt;p> * If this &#123;@code String&#125; object represents an empty character * sequence, or the first and last characters of character sequence * represented by this &#123;@code String&#125; object both have codes * greater than &#123;@code '\\u005Cu0020'&#125; (the space character), then a * reference to this &#123;@code String&#125; object is returned. * &lt;p> * Otherwise, if there is no character with a code greater than * &#123;@code '\\u005Cu0020'&#125; in the string, then a * &#123;@code String&#125; object representing an empty string is * returned. * &lt;p> * Otherwise, let &lt;i>k&lt;/i> be the index of the first character in the * string whose code is greater than &#123;@code '\\u005Cu0020'&#125;, and let * &lt;i>m&lt;/i> be the index of the last character in the string whose code * is greater than &#123;@code '\\u005Cu0020'&#125;. A &#123;@code String&#125; * object is returned, representing the substring of this string that * begins with the character at index &lt;i>k&lt;/i> and ends with the * character at index &lt;i>m&lt;/i>-that is, the result of * &#123;@code this.substring(k, m + 1)&#125;. * &lt;p> * This method may be used to trim whitespace (as defined above) from * the beginning and end of a string. * * @return A string whose value is this string, with any leading and trailing white * space removed, or this string if it has no leading or * trailing white space. */ public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st > 0) || (len &lt; value.length)) ? substring(st, len) : this; &#125; /** * This object (which is already a string!) is itself returned. * * @return the string itself. */ public String toString() &#123; return this; &#125; /** * Converts this string to a new character array. * * @return a newly allocated character array whose length is the length * of this string and whose contents are initialized to contain * the character sequence represented by this string. */ public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; /** * Returns a formatted string using the specified format string and * arguments. * * &lt;p> The locale always used is the one returned by &#123;@link * java.util.Locale#getDefault() Locale.getDefault()&#125;. * * @param format * A &lt;a href=\"../util/Formatter.html#syntax\">format string&lt;/a> * * @param args * Arguments referenced by the format specifiers in the format * string. If there are more arguments than format specifiers, the * extra arguments are ignored. The number of arguments is * variable and may be zero. The maximum number of arguments is * limited by the maximum dimension of a Java array as defined by * &lt;cite>The Java&amp;trade; Virtual Machine Specification&lt;/cite>. * The behaviour on a * &#123;@code null&#125; argument depends on the &lt;a * href=\"../util/Formatter.html#syntax\">conversion&lt;/a>. * * @throws java.util.IllegalFormatException * If a format string contains an illegal syntax, a format * specifier that is incompatible with the given arguments, * insufficient arguments given the format string, or other * illegal conditions. For specification of all possible * formatting errors, see the &lt;a * href=\"../util/Formatter.html#detail\">Details&lt;/a> section of the * formatter class specification. * * @return A formatted string * * @see java.util.Formatter * @since 1.5 */ public static String format(String format, Object... args) &#123; return new Formatter().format(format, args).toString(); &#125; /** * Returns a formatted string using the specified locale, format string, * and arguments. * * @param l * The &#123;@linkplain java.util.Locale locale&#125; to apply during * formatting. If &#123;@code l&#125; is &#123;@code null&#125; then no localization * is applied. * * @param format * A &lt;a href=\"../util/Formatter.html#syntax\">format string&lt;/a> * * @param args * Arguments referenced by the format specifiers in the format * string. If there are more arguments than format specifiers, the * extra arguments are ignored. The number of arguments is * variable and may be zero. The maximum number of arguments is * limited by the maximum dimension of a Java array as defined by * &lt;cite>The Java&amp;trade; Virtual Machine Specification&lt;/cite>. * The behaviour on a * &#123;@code null&#125; argument depends on the * &lt;a href=\"../util/Formatter.html#syntax\">conversion&lt;/a>. * * @throws java.util.IllegalFormatException * If a format string contains an illegal syntax, a format * specifier that is incompatible with the given arguments, * insufficient arguments given the format string, or other * illegal conditions. For specification of all possible * formatting errors, see the &lt;a * href=\"../util/Formatter.html#detail\">Details&lt;/a> section of the * formatter class specification * * @return A formatted string * * @see java.util.Formatter * @since 1.5 */ public static String format(Locale l, String format, Object... args) &#123; return new Formatter(l).format(format, args).toString(); &#125; /** * Returns the string representation of the &#123;@code Object&#125; argument. * * @param obj an &#123;@code Object&#125;. * @return if the argument is &#123;@code null&#125;, then a string equal to * &#123;@code \"null\"&#125;; otherwise, the value of * &#123;@code obj.toString()&#125; is returned. * @see java.lang.Object#toString() */ public static String valueOf(Object obj) &#123; return (obj == null) ? \"null\" : obj.toString(); &#125; /** * Returns the string representation of the &#123;@code char&#125; array * argument. The contents of the character array are copied; subsequent * modification of the character array does not affect the returned * string. * * @param data the character array. * @return a &#123;@code String&#125; that contains the characters of the * character array. */ public static String valueOf(char data[]) &#123; return new String(data); &#125; /** * Returns the string representation of a specific subarray of the * &#123;@code char&#125; array argument. * &lt;p> * The &#123;@code offset&#125; argument is the index of the first * character of the subarray. The &#123;@code count&#125; argument * specifies the length of the subarray. The contents of the subarray * are copied; subsequent modification of the character array does not * affect the returned string. * * @param data the character array. * @param offset initial offset of the subarray. * @param count length of the subarray. * @return a &#123;@code String&#125; that contains the characters of the * specified subarray of the character array. * @exception IndexOutOfBoundsException if &#123;@code offset&#125; is * negative, or &#123;@code count&#125; is negative, or * &#123;@code offset+count&#125; is larger than * &#123;@code data.length&#125;. */ public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; /** * Equivalent to &#123;@link #valueOf(char[], int, int)&#125;. * * @param data the character array. * @param offset initial offset of the subarray. * @param count length of the subarray. * @return a &#123;@code String&#125; that contains the characters of the * specified subarray of the character array. * @exception IndexOutOfBoundsException if &#123;@code offset&#125; is * negative, or &#123;@code count&#125; is negative, or * &#123;@code offset+count&#125; is larger than * &#123;@code data.length&#125;. */ public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; /** * Equivalent to &#123;@link #valueOf(char[])&#125;. * * @param data the character array. * @return a &#123;@code String&#125; that contains the characters of the * character array. */ public static String copyValueOf(char data[]) &#123; return new String(data); &#125; /** * Returns the string representation of the &#123;@code boolean&#125; argument. * * @param b a &#123;@code boolean&#125;. * @return if the argument is &#123;@code true&#125;, a string equal to * &#123;@code \"true\"&#125; is returned; otherwise, a string equal to * &#123;@code \"false\"&#125; is returned. */ public static String valueOf(boolean b) &#123; return b ? \"true\" : \"false\"; &#125; /** * Returns the string representation of the &#123;@code char&#125; * argument. * * @param c a &#123;@code char&#125;. * @return a string of length &#123;@code 1&#125; containing * as its single character the argument &#123;@code c&#125;. */ public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true); &#125; /** * Returns the string representation of the &#123;@code int&#125; argument. * &lt;p> * The representation is exactly the one returned by the * &#123;@code Integer.toString&#125; method of one argument. * * @param i an &#123;@code int&#125;. * @return a string representation of the &#123;@code int&#125; argument. * @see java.lang.Integer#toString(int, int) */ public static String valueOf(int i) &#123; return Integer.toString(i); &#125; /** * Returns the string representation of the &#123;@code long&#125; argument. * &lt;p> * The representation is exactly the one returned by the * &#123;@code Long.toString&#125; method of one argument. * * @param l a &#123;@code long&#125;. * @return a string representation of the &#123;@code long&#125; argument. * @see java.lang.Long#toString(long) */ public static String valueOf(long l) &#123; return Long.toString(l); &#125; /** * Returns the string representation of the &#123;@code float&#125; argument. * &lt;p> * The representation is exactly the one returned by the * &#123;@code Float.toString&#125; method of one argument. * * @param f a &#123;@code float&#125;. * @return a string representation of the &#123;@code float&#125; argument. * @see java.lang.Float#toString(float) */ public static String valueOf(float f) &#123; return Float.toString(f); &#125; /** * Returns the string representation of the &#123;@code double&#125; argument. * &lt;p> * The representation is exactly the one returned by the * &#123;@code Double.toString&#125; method of one argument. * * @param d a &#123;@code double&#125;. * @return a string representation of the &#123;@code double&#125; argument. * @see java.lang.Double#toString(double) */ public static String valueOf(double d) &#123; return Double.toString(d); &#125; /** * Returns a canonical representation for the string object. * &lt;p> * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p> * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p> * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p> * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite>The Java&amp;trade; Language Specification&lt;/cite>. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern(); &#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"sourecode","slug":"java/sourecode","permalink":"https://blog.newimg.ltd/categories/java/sourecode/"}],"tags":[{"name":"learn","slug":"learn","permalink":"https://blog.newimg.ltd/tags/learn/"}]},{"title":"Git初识教程","slug":"Git初识教程","date":"2022-07-19T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/07/20/Git初识教程/","link":"","permalink":"https://blog.newimg.ltd/2022/07/20/Git%E5%88%9D%E8%AF%86%E6%95%99%E7%A8%8B/","excerpt":"","text":"Git简介关于GitGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git的优点 版本库本地化，支持离线提交，相对独立不影响协同开发。每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。 更少的“仓库污染”。git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。 把内容按元数据方式存储，完整克隆版本库。所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。 支持快速切换分支方便合并，比较合并性能好。在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。 分布式版本库，无单点故障，内容完整性好。内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git的缺点 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 Github与GiteeGithubGitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。 优点 pull request，issue都是杀手级的feature 强调个人，符合hacker更看重名誉&#x2F;成就感的天性 缺点 国内访问速度太慢，经常出现connect time-out 原因（貌似）：github的CDN被某墙屏了，由于网络代理商的原因，所以访问下载很慢。ping github.com 时，速度只有300多ms。 不能很好的解决GB2312/GBK，对中文不够友好 wiki功能太弱，直接导致文档（对于开源项目很重要）经常被分离到一个独立站点 Gitee优点速度快 缺点来自某位网友的评价 非常不建议使用 下载个开源代码还要注册登录、上传点啥东西还要绑定手机号、上传文件数量有很大的限制 当然，你可以有一万个理由告诉我这些都是合理的。但是作为后来者，使用便利性，功能等没有超过github的话，我就有一万零一个理由不用你 Github的使用注册要想使用github第一步当然是注册github账号了。 之后就可以创建仓库了，Create a New Repository，填好名称后Create，之后会出现一些仓库的配置信息，这也是一个git的简单教程。 官网注册 建议学习如何科学上网 配置ssh为什么使用ssh：链接 首先在本地创建ssh key ssh-keygen -t rsa -C \"your_email@youremail.com\" 后面的your_email@youremail.com改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。 回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key，title随便填，粘贴在你电脑上生成的key。 为了验证是否成功，在git bash下输入： ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You&#39;ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 git config --global user.name \"your name\" git config --global user.email \"your_email@youremail.com\" 进入要上传的仓库，右键git bash，添加远程地址： git remote add origin git@github.com:yourName/yourRepo.git 后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote &quot;origin&quot;内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。 创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 分支使用git branch 显示分支一览表 git checkout -b 创建、切换分支 git merge 合并分支","categories":[{"name":"git","slug":"git","permalink":"https://blog.newimg.ltd/categories/git/"},{"name":"command","slug":"git/command","permalink":"https://blog.newimg.ltd/categories/git/command/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.newimg.ltd/tags/git/"}]},{"title":"Week4-Java总结","slug":"Week4-Java总结","date":"2022-06-19T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/06/20/Week4-Java总结/","link":"","permalink":"https://blog.newimg.ltd/2022/06/20/Week4-Java%E6%80%BB%E7%BB%93/","excerpt":"转载自博客https://blog.csdn.net/qq_36226453/article/details/82790375 一、反射的概述","text":"转载自博客https://blog.csdn.net/qq_36226453/article/details/82790375 一、反射的概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. 以上的总结就是什么是反射 反射就是把java类中的各种成分映射成一个个的Java对象 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述） 如图是类的正常加载过程：反射的原理在与class对象。 熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。 其中这个Class对象很特殊。我们先了解一下这个Class类 二、查看Class类在java中的api详解（1.7的API）如何阅读java中的api详见java基础之——String字符串处理 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型） Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。 没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧 三、反射的使用（这里使用Student类做演示）先写一个Student类。 1、获取Class对象的三种方式1.1 Object ——&gt; getClass(); 1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 1.3 通过Class类的静态方法：forName（String className）(常用)其中1.1是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取 package fanshe; /** * 获取Class对象的三种方式 * 1 Object ——> getClass(); * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 * 3 通过Class类的静态方法：forName（String className）(常用) * */ public class Fanshe &#123; public static void main(String[] args) &#123; //第一种方式获取Class对象 Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。 Class stuClass = stu1.getClass();//获取Class对象 System.out.println(stuClass.getName()); //第二种方式获取Class对象 Class stuClass2 = Student.class; System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个 //第三种方式获取Class对象 try &#123; Class stuClass3 = Class.forName(\"fanshe.Student\");//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 注意：在运行期间，一个类，只有一个Class对象产生。三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 2、通过反射获取构造方法并使用：student类： package fanshe; public class Student &#123; //---------------构造方法------------------- //（默认的构造方法） Student(String str)&#123; System.out.println(\"(默认)的构造方法 s = \" + str); &#125; //无参构造方法 public Student()&#123; System.out.println(\"调用了公有、无参构造方法执行了。。。\"); &#125; //有一个参数的构造方法 public Student(char name)&#123; System.out.println(\"姓名：\" + name); &#125; //有多个参数的构造方法 public Student(String name ,int age)&#123; System.out.println(\"姓名：\"+name+\"年龄：\"+ age);//这的执行效率有问题，以后解决。 &#125; //受保护的构造方法 protected Student(boolean n)&#123; System.out.println(\"受保护的构造方法 n = \" + n); &#125; //私有构造方法 private Student(int age)&#123; System.out.println(\"私有的构造方法 年龄：\"+ age); &#125; &#125; 共有6个构造方法； 测试类： package fanshe; import java.lang.reflect.Constructor; /* * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员； * * 1.获取构造方法： * 1).批量的方法： * public Constructor[] getConstructors()：所有\"公有的\"构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) * 2).获取单个的方法，并调用： * public Constructor getConstructor(Class... parameterTypes):获取单个的\"公有的\"构造方法： * public Constructor getDeclaredConstructor(Class... parameterTypes):获取\"某个构造方法\"可以是私有的，或受保护、默认、公有； * * 调用构造方法： * Constructor-->newInstance(Object... initargs) */ public class Constructors &#123; public static void main(String[] args) throws Exception &#123; //1.加载Class对象 Class clazz = Class.forName(\"fanshe.Student\"); //2.获取所有公有构造方法 System.out.println(\"**********************所有公有构造方法*********************************\"); Constructor[] conArray = clazz.getConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(\"************所有的构造方法(包括：私有、受保护、默认、公有)***************\"); conArray = clazz.getDeclaredConstructors(); for(Constructor c : conArray)&#123; System.out.println(c); &#125; System.out.println(\"*****************获取公有、无参的构造方法*******************************\"); Constructor con = clazz.getConstructor(null); //1>、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型 //2>、返回的是描述这个无参构造函数的类对象。 System.out.println(\"con = \" + con); //调用构造方法 Object obj = con.newInstance(); // System.out.println(\"obj = \" + obj); // Student stu = (Student)obj; System.out.println(\"******************获取私有构造方法，并调用*******************************\"); con = clazz.getDeclaredConstructor(char.class); System.out.println(con); //调用构造方法 con.setAccessible(true);//暴力访问(忽略掉访问修饰符) obj = con.newInstance('男'); &#125; &#125; 后台输出： **********************所有公有构造方法********************************* public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() ************所有的构造方法(包括：私有、受保护、默认、公有)*************** private fanshe.Student(int) protected fanshe.Student(boolean) public fanshe.Student(java.lang.String,int) public fanshe.Student(char) public fanshe.Student() fanshe.Student(java.lang.String) *****************获取公有、无参的构造方法******************************* con = public fanshe.Student() 调用了公有、无参构造方法执行了。。。 ******************获取私有构造方法，并调用******************************* public fanshe.Student(char) 姓名：男 调用方法： 1.获取构造方法： 1).批量的方法：public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有) 2).获取单个的方法，并调用：public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； 调用构造方法： Constructor–&gt;newInstance(Object… initargs) 2、newInstance是 Constructor类的方法（管理构造函数的类） api的解释为： newInstance(Object… initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用 3、获取成员变量并调用student类： package fanshe.field; public class Student &#123; public Student()&#123; &#125; //**********字段*************// public String name; protected int age; char sex; private String phoneNum; @Override public String toString() &#123; return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \", phoneNum=\" + phoneNum + \"]\"; &#125; &#125; 测试类： package fanshe.field; import java.lang.reflect.Field; /* * 获取成员变量并调用： * * 1.批量的 * 1).Field[] getFields():获取所有的\"公有字段\" * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有； * 2.获取单个的： * 1).public Field getField(String fieldName):获取某个\"公有的\"字段； * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) * * 设置字段的值： * Field --> public void set(Object obj,Object value): * 参数说明： * 1.obj:要设置的字段所在的对象； * 2.value:要为字段设置的值； * */ public class Fields &#123; public static void main(String[] args) throws Exception &#123; //1.获取Class对象 Class stuClass = Class.forName(\"fanshe.field.Student\"); //2.获取字段 System.out.println(\"************获取所有公有的字段********************\"); Field[] fieldArray = stuClass.getFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(\"************获取所有的字段(包括私有、受保护、默认的)********************\"); fieldArray = stuClass.getDeclaredFields(); for(Field f : fieldArray)&#123; System.out.println(f); &#125; System.out.println(\"*************获取公有字段**并调用***********************************\"); Field f = stuClass.getField(\"name\"); System.out.println(f); //获取一个对象 Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, \"刘德华\");//为Student对象中的name属性赋值--》stu.name = \"刘德华\" //验证 Student stu = (Student)obj; System.out.println(\"验证姓名：\" + stu.name); System.out.println(\"**************获取私有字段****并调用********************************\"); f = stuClass.getDeclaredField(\"phoneNum\"); System.out.println(f); f.setAccessible(true);//暴力反射，解除私有限定 f.set(obj, \"18888889999\"); System.out.println(\"验证电话：\" + stu); &#125; &#125; 后台输出： 1. `************获取所有公有的字段********************` 2. `public java.lang.String fanshe.field.Student.name` 3. `************获取所有的字段(包括私有、受保护、默认的)********************` 4. `public java.lang.String fanshe.field.Student.name` 5. `protected int fanshe.field.Student.age` 6. `char fanshe.field.Student.sex` 7. `private java.lang.String fanshe.field.Student.phoneNum` 8. `*************获取公有字段**并调用***********************************` 9. `public java.lang.String fanshe.field.Student.name` 10. `验证姓名：刘德华` 11. `**************获取私有字段****并调用********************************` 12. `private java.lang.String fanshe.field.Student.phoneNum` 13. `验证电话：Student [name=刘德华, age=0, sex=` 由此可见 调用字段时：需要传递两个参数： Object obj &#x3D; stuClass.getConstructor().newInstance();&#x2F;&#x2F;产生Student对象–》Student stu &#x3D; new Student();&#x2F;&#x2F;为字段设置值f.set(obj, “刘德华”);&#x2F;&#x2F;为Student对象中的name属性赋值–》stu.name &#x3D; “刘德华” 第一个参数：要传入设置的对象，第二个参数：要传入实参 4、获取成员方法并调用student类： package fanshe.method; public class Student &#123; //**************成员方法***************// public void show1(String s)&#123; System.out.println(\"调用了：公有的，String参数的show1(): s = \" + s); &#125; protected void show2()&#123; System.out.println(\"调用了：受保护的，无参的show2()\"); &#125; void show3()&#123; System.out.println(\"调用了：默认的，无参的show3()\"); &#125; private String show4(int age)&#123; System.out.println(\"调用了，私有的，并且有返回值的，int参数的show4(): age = \" + age); return \"abcd\"; &#125; &#125; 测试类： package fanshe.method; import java.lang.reflect.Method; &#x2F;* * 获取成员方法并调用： * * 1.批量的： * public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类） * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) * 2.获取单个的： * public Method getMethod(String name,Class&lt;?&gt;... parameterTypes): * 参数： * name : 方法名； * Class ... : 形参的Class类型对象 * public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) * * 调用方法： * Method --&gt; public Object invoke(Object obj,Object... args): * 参数说明： * obj : 要调用方法的对象； * args:调用方式时所传递的实参； ): *&#x2F; public class MethodClass &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;1.获取Class对象 Class stuClass &#x3D; Class.forName(&quot;fanshe.method.Student&quot;); &#x2F;&#x2F;2.获取所有公有方法 System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;); stuClass.getMethods(); Method[] methodArray &#x3D; stuClass.getMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;); methodArray &#x3D; stuClass.getDeclaredMethods(); for(Method m : methodArray)&#123; System.out.println(m); &#125; System.out.println(&quot;***************获取公有的show1()方法*******************&quot;); Method m &#x3D; stuClass.getMethod(&quot;show1&quot;, String.class); System.out.println(m); &#x2F;&#x2F;实例化一个Student对象 Object obj &#x3D; stuClass.getConstructor().newInstance(); m.invoke(obj, &quot;刘德华&quot;); System.out.println(&quot;***************获取私有的show4()方法******************&quot;); m &#x3D; stuClass.getDeclaredMethod(&quot;show4&quot;, int.class); System.out.println(m); m.setAccessible(true);&#x2F;&#x2F;解除私有限定 Object result &#x3D; m.invoke(obj, 20);&#x2F;&#x2F;需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(&quot;返回值：&quot; + result); &#125; &#125; 控制台输出： ***************获取所有的”公有“方法******************* public void fanshe.method.Student.show1(java.lang.String) public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait() throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() ***************获取所有的方法，包括私有的******************* public void fanshe.method.Student.show1(java.lang.String) private java.lang.String fanshe.method.Student.show4(int) protected void fanshe.method.Student.show2() void fanshe.method.Student.show3() ***************获取公有的show1()方法******************* public void fanshe.method.Student.show1(java.lang.String) 调用了：公有的，String参数的show1(): s = 刘德华 ***************获取私有的show4()方法****************** private java.lang.String fanshe.method.Student.show4(int) 调用了，私有的，并且有返回值的，int参数的show4(): age = 20 返回值：abcd 由此可见： m &#x3D; stuClass.getDeclaredMethod(“show4”, int.class);&#x2F;&#x2F;调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。System.out.println(m);m.setAccessible(true);&#x2F;&#x2F;解除私有限定Object result &#x3D; m.invoke(obj, 20);&#x2F;&#x2F;需要两个参数，一个是要调用的对象（获取有反射），一个是实参System.out.println(“返回值：” + result);&#x2F;&#x2F; 控制台输出： ***************获取所有的”公有“方法******************* public void fanshe.method.Student.show1(java.lang.String) public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait() throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() ***************获取所有的方法，包括私有的******************* public void fanshe.method.Student.show1(java.lang.String) private java.lang.String fanshe.method.Student.show4(int) protected void fanshe.method.Student.show2() void fanshe.method.Student.show3() ***************获取公有的show1()方法******************* public void fanshe.method.Student.show1(java.lang.String) 调用了：公有的，String参数的show1(): s = 刘德华 ***************获取私有的show4()方法****************** private java.lang.String fanshe.method.Student.show4(int) 调用了，私有的，并且有返回值的，int参数的show4(): age = 20 返回值：abcd 其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解 5、反射main方法student类： package fanshe.main; public class Student &#123; public static void main(String[] args) &#123; System.out.println(\"main方法执行了。。。\"); &#125; &#125; 测试类： package fanshe.main; import java.lang.reflect.Method; /** * 获取Student类的main方法、不要与当前的main方法搞混了 */ public class Main &#123; public static void main(String[] args) &#123; try &#123; //1、获取Student对象的字节码 Class clazz = Class.forName(\"fanshe.main.Student\"); //2、获取main方法 Method methodMain = clazz.getMethod(\"main\", String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型， //3、调用main方法 // methodMain.invoke(null, new String[]&#123;\"a\",\"b\",\"c\"&#125;); //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数 //这里拆的时候将 new String[]&#123;\"a\",\"b\",\"c\"&#125; 拆成3个对象。。。所以需要将它强转。 methodMain.invoke(null, (Object)new String[]&#123;\"a\",\"b\",\"c\"&#125;);//方式一 // methodMain.invoke(null, new Object[]&#123;new String[]&#123;\"a\",\"b\",\"c\"&#125;&#125;);//方式二 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 控制台输出： main方法执行了。。。 6、反射方法的其它使用之—通过反射运行配置文件内容student类： public class Student &#123; public void show()&#123; System.out.println(\"is show()\"); &#125; &#125; 配置文件以txt文件为例子（pro.txt）： className &#x3D; cn.fanshe.Student methodName &#x3D; show 测试类： import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.lang.reflect.Method; import java.util.Properties; /* * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改 * 我们只需要将新类发送给客户端，并修改配置文件即可 */ public class Demo &#123; public static void main(String[] args) throws Exception &#123; //通过反射获取Class对象 Class stuClass = Class.forName(getValue(\"className\"));//\"cn.fanshe.Student\" //2获取show()方法 Method m = stuClass.getMethod(getValue(\"methodName\"));//show //3.调用show()方法 m.invoke(stuClass.getConstructor().newInstance()); &#125; //此方法接收一个key，在配置文件中获取相应的value public static String getValue(String key) throws IOException&#123; Properties pro = new Properties();//获取配置文件的对象 FileReader in = new FileReader(\"pro.txt\");//获取输入流 pro.load(in);//将流加载到配置文件对象中 in.close(); return pro.getProperty(key);//返回根据key获取的value值 &#125; &#125; 控制台输出： is show() 需求：当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动 要替换的student2类： public class Student2 &#123; public void show2()&#123; System.out.println(\"is show2()\"); &#125; &#125; 配置文件更改为： className = cn.fanshe.Student2 methodName = show2 控制台输出： is show2(); 7、反射方法的其它使用之—通过反射越过泛型检查泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的 测试类： import java.lang.reflect.Method; import java.util.ArrayList; /* * 通过反射越过泛型检查 * * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？ */ public class Demo &#123; public static void main(String[] args) throws Exception&#123; ArrayList&lt;String> strList = new ArrayList&lt;>(); strList.add(\"aaa\"); strList.add(\"bbb\"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod(\"add\", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125; &#125; &#125; 控制台输出： aaa bbb 100 Java类集框架^2类集框架简介从JDK1.2开始，Java中引入了类集开发框架，所谓的类集指的是一套动态对象数组的实现方案，在实际开发中，没有任何一项开发可以离开数组，但是传统的数组实现起来非常的繁琐，而且长度是其致命伤，正是因为长度问题，所以传统的数组是不可能大范围使用的，但是开发又离不开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构：链表、树。但是面对这些数据结构的实现，又不得不面对如下的一些问题： 数据结构的代码实现困难，对于一般的开发者是无法进行使用的； 对于链表或二叉树当进行更新处理的时候，维护是非常麻烦的； 对于链表或二叉树还需要尽可能保证其操作的性能； 正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并提供了一系列的接口与实现子类，来帮助用户减少数据结构所带来的开发困难。但是最初的类集实现由Java本身的技术所限，所以对于数据的控制并不严格，全部采用了Object类型进行数据接收，而在JDK1.5后由于泛型将技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集的实现算法也得到了良好的性能提升。 在整个类集框架中，提供了如下几个核心接口：Collection、List、Set、Map、Iterator、Enumeration、Queue、ListIterator。 Collection集合接口java.util.Collection是单值集合操作的最大的父接口，在该接口中定义有所有的单值数据的处理操作，这个接口中定义了如下的核心操作方法： No. 方法名称 类型 描述 01 public boolean add(E e) 普通 向集合保存数据 02 public boolean addAll(Collection&lt;? extends E&gt; c) 普通 追加一组数据 03 public void clear() 普通 清空集合，让根节点为空，同时执行GC处理 04 public boolean contains(Object o) 普通 查询数据是否存在，需要equals()方法支持 05 public boolean remove(Object o) 普通 数据删除，需要equals()方法支持 06 public int size() 普通 获取数据长度，最大值为Integer.MAX_VALUE 07 public Object[] toArray() 普通 将集合变为对象数组返回 08 public Iterator&lt;E&gt; iterator() 普通 将集合变为Iterator接口返回 在进行集合操作时，有两个方法最为常用：【增加】add()、【输出】iterator()。 在JDK1.5版本之前，Collection只是一个独立的接口，但是从JDK1.5后，提供了Iterable父接口，并且在JDK1.8后针对于Iterable接口也得到了一些扩充。另外，在JDK1.2~JDK1.4的时代里面，如果要进行集合的使用往往会直接操作Collection接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口：允许重复的List子接口、不允许重复的Set子接口； Collection接口 List接口List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下： public interface List&lt;E&gt; extends Collection&lt;E&gt; 但是需要清楚的是List子接口对于Collection接口进行了方法扩充。 No. 方法名称 类型 描述 01 public E get(int index) 普通 获取指定索引上的数据 02 public E set(int index, E element) 普通 修改指定索引数据 03 public ListIterator&lt;E&gt; listIterator() 普通 返回ListIterator接口对象 但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类：ArrayList、Vector、LinkedList。 List子接口 从JDK1.9开始，List接口中追加有一些static方法，以方便用户的处理。范例：观察List的静态方法 import java.util.Arrays; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; List.of(&quot;Hello&quot;, &quot;World&quot;, &quot;你好&quot;, &quot;MLDN&quot;, &quot;饿了么？&quot;); Object result []&#x3D; all.toArray(); for(Object temp : result) &#123; System.out.println(temp + &quot;、&quot;); &#x2F;&#x2F;[Hello、World、你好、MLDN、饿了么？] &#125; &#125; &#125; 这些操作方法并不是List的传统用法，是在新版本之后添加的新功能。 ArrayList子类ArrayList是List子接口中使用最多的一个子类，但是这个子类在使用时也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在Java里面ArrayList类的定义如下： public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; mplements List&lt;E&gt;, RandomAccess, Cloneable, Serializable ArrayList的继承结构 范例：使用ArrayList实例化List父接口 import java.util.ArrayList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;为List父接口进行实例化 all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); &#x2F;&#x2F;重复数据 all.add(&quot;Wolrd&quot;); all.add(&quot;MLDN&quot;); System.out.println(all); &#x2F;&#x2F;[Hello, Hello, Wolrd, MLDN] &#125; &#125; 通过本程序可以发现List的存储特征： 保存的顺序就是其存储的顺序； List集合里面允许存在有重复数据； 在以上的程序中虽然实现了集合的输出，但是这种输出的操作是直接利用了每一个类提供的toString()方法实现的，为了方便地进行输出处理，在JDK1.8之后Iterable父接口之中定义有一个forEach()方法，方法定义如下： 输出支持：default void forEach(Consumer&lt;? super T&gt; action)范例：利用forEach()方法进行输出（不是标准输出） import java.util.ArrayList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;为List父接口进行实例化 all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); &#x2F;&#x2F;重复数据 all.add(&quot;Wolrd&quot;); all.add(&quot;MLDN&quot;); all.forEach((str) -&gt; &#123; System.out.print(str + &quot;、&quot;); &#125;); &#x2F;&#x2F;Hello、Hello、Wolrd、MLDN、 &#125; &#125; 需要注意的是，此种输出并不是正常开发情况下要考虑的操作形式。范例：观察List集合的其它操作方法 import java.util.ArrayList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F;为List父接口进行实例化 System.out.println(&quot;集合是否为空？&quot; + all.isEmpty() + &quot;、集合元素个数：&quot; + all.size()); &#x2F;&#x2F;集合是否为空？true、集合元素个数：0 all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;);&#x2F;&#x2F;重复数据 all.add(&quot;Wolrd&quot;); all.add(&quot;MLDN&quot;); all.remove(&quot;Hello&quot;); &#x2F;&#x2F;删除元素 System.out.println(&quot;集合是否为空？&quot; + all.isEmpty() + &quot;、集合元素个数：&quot; + all.size()); &#x2F;&#x2F;集合是否为空？false、集合元素个数：3 all.forEach((str) -&gt; &#123; System.out.print(str + &quot;、&quot;); &#125;); &#x2F;&#x2F;Hello、Wolrd、MLDN、 &#125; &#125; 如果以方法的功能为例，那么ArrayList中操作支持与之前编写的链表形式是非常相似的，但是它并不是使用链表来实现的，通过类名称实际上就已经可以清楚的发现了，ArrayList应该封装的是一个数组。 ArrayList构造：public ArrayList() public ArrayList() &#123; this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;; ArrayList构造：public ArrayList(int initialCapacity) public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData &#x3D; new Object[initialCapacity]; &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123; this.elementData &#x3D; EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; 通过有参构造方法可以发现，在ArrayList中所包含的数据实际上就是一个对象数组。在进行数据追加时发现ArrayList集合中保存的对象数组长度不够的时候将会开辟新的数组，同时将原始的旧数组内容拷贝到新数组中。而后数组的开辟操作： private int newCapacity(int minCapacity) &#123; &#x2F;&#x2F; overflow-conscious code int oldCapacity &#x3D; elementData.length; int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;&#x3D; 0) &#123; if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) &#x2F;&#x2F; overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;&#x3D; 0) ? newCapacity : hugeCapacity(minCapacity); &#125; 如果在实例化ArrayList类对象时没有传递初始化的长度，则默认情况下会使用空数组，但是如果在进行数据增加时，发现数组容量不够，则会判断当前的增长容量与默认的容量的大小，使用较大的一个数值进行新的数组开辟，所以可以得出结论： JDK1.9之后：ArrayList默认的构造只会使用默认的空数组，使用时才会开辟数组，默认的开辟长度为10； JDK1.9之前：ArrayList默认的构造实际上就会默认开辟大小为10的数组 当ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10 ，下次的增长就是20，如果在使用ArrayList子类的时候一定要估算出数据量有多少，如果超过了10个，那么采用有参构造的方法进行创建，以避免垃圾数组的空间产生。 ArrayList保存自定义类对象通过之前的分析已经清楚了ArrayList子类的实现原理以及List核心操作，但是在测试的时候使用的是系统提供的String类，这是一个设计非常完善的类，而对于类集而言也可以实现自定义类对象的保存。范例：实现自定义类对象保存 import java.util.ArrayList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;Person&gt; all &#x3D; new ArrayList&lt;Person&gt;(); all.add(new Person(&quot;张三&quot;, 30)); all.add(new Person(&quot;李四&quot;, 16)); all.add(new Person(&quot;小强&quot;, 78)); System.out.println(all.contains(new Person(&quot;小强&quot;, 78))); all.remove(new Person(&quot;小强&quot;, 78)); all.forEach(System.out::println); &#x2F;&#x2F;方法引用代替了消费型的接口 &#x2F;** * false * 姓名：张三、年龄：30 * 姓名：李四、年龄：28 * 姓名：小强、年龄：78 *&#x2F; &#125; &#125; class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; &#x2F;&#x2F; setter、getter、构造略 public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age; &#125; &#125; 在使用List保存自定义对象时，如果需要使用到contains()、remove()方法进行查询或删除处理时一定要保证类中已经覆写了equals()方法。 class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; @Override public boolean equals(Object obj) &#123; if (this &#x3D;&#x3D; obj) &#123; return true; &#125; if (obj &#x3D;&#x3D; null) &#123; return false; &#125; if (!(obj instanceof Person)) &#123; return false; &#125; Person per &#x3D; (Person) obj; return this.name.equals(per.name) &amp;&amp; this.age &#x3D;&#x3D; per.age; &#125; &#x2F;&#x2F; setter、getter、构造略 public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age; &#125; &#125; &#x2F;** * true * 姓名：张三、年龄：30 * 姓名：李四、年龄：28 *&#x2F; LinkedList子类在List接口中还有一个比较常用的子类：LinkedList，这个类通过名称就可以发现其特点：基于链表的实现。那么首先观察一下LinkedList的定义： public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable LinkedList类的继承关系 范例：使用LinkedList实现集合操作 import java.util.LinkedList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; new LinkedList&lt;String&gt;(); all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); all.add(&quot;Wolrd&quot;); all.add(&quot;MLDN&quot;); all.forEach(System.out::println); &#x2F;&#x2F;Hello Hello World MLDN &#125; &#125; 如果现在只是观察程序的功能会发现和ArrayList使用是完全一样的，但是其内部实现机制是完全不同的，首先观察LinkedList构造方法里面并没有提供像ArrayList那样的初始化大小的方法，而只是提供了无参构造处理：“public LinkedList()”。随后观察add()方法的具体实现。 public boolean add(E e) &#123; linkLast(e); return true; &#125; 在之前编写自定义链表时，是判断了传入数据是否为null，如果为null则不进行保存，但在LinkedList中并没有做这样的处理，而是所有的数据都可以保存,而后此方法调用了linkLast()方法（在最后一个节点后追加）。 void linkLast(E e) &#123; final Node&lt;E&gt; l &#x3D; last; final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null); last &#x3D; newNode; if (l &#x3D;&#x3D; null) first &#x3D; newNode; else l.next &#x3D; newNode; size++; modCount++; &#125; 在LinkedList类中保存的数据都是利用Node节点进行的封装处理，同时为了提高程序执行性能，每一次都会保存上一个追加的节点（最后一个节点），就可以在增加数据的时候避免递归处理，在增加数据时要进行数据保存个数的追加。 通过上面的分析，可以发现LinkedList封装的就是一个链表实现。面试题：请问ArrayList与LinkedList有什么区别？ ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作； 在使用List集合中的get()方法根据索引获取数据时，ArrayList的时间复杂度为“O(1)”、而LinkedList时间复杂度为“O(n)”（n为集合的长度）； ArrayList在使用时默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降，但是这时候可以使用LinkedList类保存。 Vector子类Vector是一个原始古老的程序类，这个类是在JDK1.0时提供的。到了JDK1.2时由于许多开发者已经习惯于使用Vector，并且许多系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保留了下来，并让其多实现了一个List接口，观察Vector的定义结构： public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable 继承结构与ArrayList是相同的，所以来讲这个类继承结构如下。 Vector继承结构 范例：Vector类使用 import java.util.List; import java.util.Vector; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; all &#x3D; new Vector&lt;String&gt;(); all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); all.add(&quot;Wolrd&quot;); all.add(&quot;MLDN&quot;); all.forEach(System.out::println); &#x2F;&#x2F; Hello Hello World MLDN &#125; &#125; 下面可以进一步的观察Vector类实现： public Vector() &#123; this(10); &#125; public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData &#x3D; new Object[initialCapacity]; this.capacityIncrement &#x3D; capacityIncrement; &#125; Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的。通过源代码分析可以发现，Vector类中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。 Set接口Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。 在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下： public interface Set&lt;E&gt; extends Collection&lt;E&gt; 需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()方法，也就是说无法实现指定索引数据的获取，Set接口的继承关系如下。 图片被清理Set接口继承关系 从JDK1.9后，Set集合也提供了像List集合中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。范例：验证Set集合特征 import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; &#x2F;&#x2F;进行Set集合数据的保存，并设置有重复的内容 Set&lt;String&gt; all&#x3D;Set.of(&quot;Hello&quot;,&quot;World&quot;,&quot;MLDN&quot;,&quot;Hello&quot;,&quot;World&quot;); all.forEach(System.out::println); &#x2F;&#x2F;直接输出 &#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate element: Hello &#125; &#125; 当使用of()这个新方法的时候，如果发现集合中存在重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。 Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用的子类：HashSet、TreeSet。 HashSet子类HashSet是Set接口中使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下： public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable 这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下类的继承结构： 图片被清理HashSet子类 范例：观察HashSet类 import java.util.HashSet; import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String&gt; all &#x3D; new HashSet&lt;String&gt;(); all.add(&quot;MLDN&quot;); all.add(&quot;NiHao&quot;); all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); &#x2F;&#x2F;重复元素 all.add(&quot;World&quot;); all.forEach(System.out::println); &#125; &#125; &#x2F;** * NiHao * Hello * World * MLDN *&#x2F; 通过执行结果就可以发现HashSet的操作特点：不允许保存重复元素（Set接口定义的），另外一个特点就是HashSet中保存的数据是无序的。 TreeSet子类Set接口的另外一个子接口就是TreeSet，与HashSet最大区别在于TreeSet集合里面保存的数据是有序的，首先来观察TreeSet类的定义： public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable 在这个子类中依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。 图片被清理TreeSet 范例：使用TreeSet子类 import java.util.TreeSet; import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String&gt; all &#x3D; new TreeSet&lt;String&gt;(); all.add(&quot;MLDN&quot;); all.add(&quot;NiHao&quot;); all.add(&quot;Hello&quot;); all.add(&quot;Hello&quot;); &#x2F;&#x2F;重复元素 all.add(&quot;World&quot;); all.forEach(System.out::println); &#125; &#125; &#x2F;** * Hello * MLDN * NiHao * World *&#x2F; 当利用TreeSet保存数据的时候，所有的数据将按照数据的升序进行自动排序处理。 TreeSet子类排序操作经过分析后发现，TreeSet子类中保存的数据是允许排序的，但是这个类必须要实现Comparable接口，只有实现了此接口才能够确认出对象的大小关系。 提示：TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap（树）就需要根据Comparable来确定对象的大小关系。 那么下面就使用一个自定义的类来实现排序的处理操作。范例：使用自定义的类实现排序的处理操作 import java.util.Set; import java.util.TreeSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;Person&gt; all&#x3D;new TreeSet&lt;Person&gt;(); all.add(new Person(&quot;张三&quot;,19)); all.add(new Person(&quot;李四&quot;,19)); &#x2F;&#x2F;年龄相同，但姓名不同 all.add(new Person(&quot;王五&quot;,20)); &#x2F;&#x2F;数据重复 all.add(new Person(&quot;王五&quot;,20)); &#x2F;&#x2F;数据重复 all.add(new Person(&quot;小强&quot;,78)); all.forEach(System.out::println); &#125; &#125; class Person implements Comparable&lt;Person&gt;&#123; &#x2F;&#x2F;比较器 private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age; &#125; @Override public int compareTo(Person per) &#123; if(this.age &lt; per.age)&#123; return -1 ; &#125;else if(this.age &gt; per.age) &#123; return 1; &#125;else &#123; return this.name.compareTo(per.name); &#125; &#125; &#125; &#x2F;** * 姓名：张三、年龄：19 * 姓名：李四、年龄：19 * 姓名：王五、年龄：20 * 姓名：小强、年龄：78 *&#x2F; 在使用自定义类对象进行比较处理的时候，一定要将该类中所有属性都依次进行大小关系的匹配，否则某一个或者几个属性相同的时候也会被认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。 由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发中应该首选HashSet子类进行存储。 重复元素消除TreeSet类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的： 对象编码：public int hashCode(); 对象比较：public boolean equals(Object obj); 在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果该编码不存在，则表示数据不存在，证明没有重复，如果该编码存在，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建HashCode()与equals()方法。 图片被清理图片被清理 范例：实现重复元素处理 import java.util.Set; import java.util.HashSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;Person&gt; all&#x3D;new TreeSet&lt;Person&gt;(); all.add(new Person(&quot;张三&quot;,19)); all.add(new Person(&quot;李四&quot;,19)); &#x2F;&#x2F;年龄相同，但姓名不同 all.add(new Person(&quot;王五&quot;,20)); &#x2F;&#x2F;数据重复 all.add(new Person(&quot;王五&quot;,20)); &#x2F;&#x2F;数据重复 all.add(new Person(&quot;小强&quot;,78)); all.forEach(System.out::println); &#125; &#125; class Person implements Comparable&lt;Person&gt;&#123; &#x2F;&#x2F;比较器 private String name; private int age; public Person(String name, int age) &#123; this.name &#x3D; name; this.age &#x3D; age; &#125; @Override public int hashCode() &#123; final int prime &#x3D; 31; int result &#x3D; 1; result &#x3D; prime * result +age; result &#x3D; prime * result + ((name &#x3D;&#x3D; null)? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this &#x3D;&#x3D; obj) return true; if (obj &#x3D;&#x3D; null) return false; if (getClass() !&#x3D; obj.getClass()) return false; Person other &#x3D; (Person) obj; if (age !&#x3D; other.age) return false; if (name &#x3D;&#x3D; null) &#123; if (other.name !&#x3D; null) return false; &#125;else if (!name.equals(other.name)) return false; return true; &#125; public String toString() &#123; return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age; &#125; @Override public int compareTo(Person per) &#123; if(this.age &lt; per.age)&#123; return -1 ; &#125;else if(this.age &gt; per.age) &#123; return 1; &#125;else &#123; return this.name.compareTo(per.name); &#125; &#125; &#125; &#x2F;** * 姓名：小强、年龄：78 * 姓名：李四、年龄：19 * 姓名：王五、年龄：20 * 姓名：张三、年龄：19 *&#x2F; 在Java程序中，真正的重复元素的判断处理利用的就是hashCode和equals()两个方法共同作用完成的，而只有在排序要求的情况下（TreeSet）才会利用Comparable接口来实现。","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"关于Github基础指令","slug":"关于Github基础指令","date":"2022-06-19T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/06/20/关于Github基础指令/","link":"","permalink":"https://blog.newimg.ltd/2022/06/20/%E5%85%B3%E4%BA%8EGithub%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/","excerpt":"","text":"背景知识^1下文[]中的均为相关变量名，大多数均为自定义或已存在。 $ 后默认为指令，行开头无 $ 的默认为指令的输出 可以使用 git help 查看相关的文档 git 命令和编程一样，我认为要愿意去尝试，有了疑惑可以考虑先自己在测试环境中尝试，或许你会恍然大悟 通过实际操作学习git^2基本操作git init初始化git仓库，如果创建成功目录下则会生成 .git 目录（默认隐藏）， 其中含有之前的历史快照。 git status查看当前仓库的状态。 $ git status On branch main Your branch is up to date with 'origin/main'. Changes to be committed: (use \"git restore --staged &lt;file>...\" to unstage) modified: Folder1/1-1.txt git add向暂存区中添加文件，commit 前的必要操作，将文件移入暂存区。 git commit保存仓库的历史记录，能够帮助我们更好的进行版本控制，可以使用 -m 选项记述一行提交信息，或不加 -m 记述详细的提交信息。 $ git commit -m \"Test\" [main aa34371] Test 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 Folder2/2-1.txt git log查看仓库的提交日志，包括什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。 -pretty=short 只显示提交信息的第一行 [fileName] 只显示该目录或文件的日志 -p 显示文件的前后差别 $ git log commit aa343**********99b6d8**********bffc0b225a (HEAD -> main, origin/main, origin/HEAD) Author: **** &lt;********@*****.com> Date: Wed Apr 13 19:46:52 2022 +0800 Test commit f**********5455a486**********ff09cbf6aea Merge: 186b6f5 1cdd417 Author: **** &lt;********@*****.com> Date: Wed Apr 13 19:44:33 2022 +0800 Merge branch 'main' of github.com:Fuxx-1/test_repository commit 186b6f5721f51**********1070afe**********19 Author: **** &lt;********@*****.com> Date: Wed Apr 13 19:43:01 2022 +0800 insert new flie 1-1.txt commit 1cdd417980**********bdb9**********fcfeac Author: **** &lt;********@*****.com> Date: Wed Apr 13 19:37:54 2022 +0800 add file 1-1 git diff查看更改前后的差别，不加选项默认查看工作树和暂存区的差别，加 Head 选项后可查看工作树和最新提交的差别 diff --git a/Folder1/1-1.txt b/Folder1/1-1.txt index 2319ba4..7c5a75b 100644 --- a/Folder1/1-1.txt +++ b/Folder1/1-1.txt @@ -1 +1,2 @@ -1-1 \\ No newline at end of file +1-1 +test \\ No newline at end of file 分支操作git branch显示分支一览表，将分支名列表显示，同时可以确定当前所在分支，带 * 的为当前所在分支。 $ git branch * main git checkout -b [branchName]创建并切换分支，以当前分支为基础创建新的分支 $ git checkout -b featureA Switched to a new branch 'featureA' 以上命令等同 $ git branch featureA $ git checkout featureA 此时显示分支一览表 $ git branch * featureA main git merge将 HotFix 分支合并到主分支 $ git checkout main Switched to branch 'main' Your branch is up to date with 'origin/main'. $ git merge hotFixBug Updating 7d050ad..1bcbe8a Fast-forward Folder1/1-1.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) $ git push Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Delta compression using up to 8 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 357 bytes | 89.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:****/test_rep****ory.git 7d050ad..1bcbe8a main -> main 将 featureA 分支合并到主分支 $ git merge featureA Merge made by the 'recursive' strategy. featureA.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 featureA.txt $ git push Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 8 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (2/2), 294 bytes | 294.00 KiB/s, done. Total 2 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (1/1), completed with 1 local object. To github.com:****/test_rep****ory.git 1bcbe8a..fd33b74 main -> main $ git log --graph * commit fd33b74371b0*****7a88*****2f56*****c59f8 (HEAD -> main, origin/main, origin/HEAD) |\\ Merge: 1bcbe8a fab1fc2 | | Author: **** &lt;********@*****.com> | | Date: Wed Apr 13 20:45:20 2022 +0800 | | | | Merge branch 'featureA' | | | * commit fab1fc2c*****2b2ae1a*****51a4c222*****b0 (origin/featureA, featureA) | | Author: **** &lt;********@*****.com> | | Date: Wed Apr 13 20:18:43 2022 +0800 | | | | add true featureA | | * | commit 1bcbe8acb*****656d154e*****4fb60*****5ed |/ Author: **** &lt;********@*****.com> | Date: Wed Apr 13 20:41:21 2022 +0800 | | hotFixBug | * commit 7d050a*****350478d*****ae1acaf*****75755 | Author: **** &lt;********@*****.com> | Date: Wed Apr 13 20:09:47 2022 +0800 | | add featureA | 相关问题问题1：撤销 commit 或 add 已经commit -m &quot;&quot;了，代码进入了本地仓库和远端仓库的中间站，需要撤回： $ git reset --soft HEAD^ （HEAD^的意思是上一个版本，也可以写成HEAD1 ；如果你进行了2次commit，想都撤回，可以使用HEAD2） 已经git add. 了，想撤回： $ git reset HEAD 补充选项： –mixed意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 –soft不删除工作空间改动代码，撤销commit，不撤销git add . –hard删除工作空间改动代码，撤销commit，撤销git add . 问题2：修改commit$ git commit --amend 后记相关知识可参考[git官方教程](Git - 关于版本控制 (git-scm.com))和[廖雪峰的Git教程](Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)) 实际环境往往比学习环境更复杂","categories":[{"name":"git","slug":"git","permalink":"https://blog.newimg.ltd/categories/git/"},{"name":"command","slug":"git/command","permalink":"https://blog.newimg.ltd/categories/git/command/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"更改并导入自定义字体","slug":"更改并导入自定义字体","date":"2022-06-19T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/06/20/更改并导入自定义字体/","link":"","permalink":"https://blog.newimg.ltd/2022/06/20/%E6%9B%B4%E6%94%B9%E5%B9%B6%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/","excerpt":"","text":"本博客之前的使用的字体为主题默认字体，为避免各种纠纷，本站将采用开源的霞鹜文楷 关于这个字体霞鹜文楷An open-source Chinese font derived from Fontworks’ Klee One. 一款开源中文字体，基于 FONTWORKS 出品字体 Klee One 衍生。 链接该字体LxgwWenKai@Github | 该字体Webfont@Github | unpkg | jsdelivr 使用方式电脑访问该字体官网，并在 Release 中下载最新版字体的 .ttf 文件。 安装字体并使用软件实现系统字体更改。 手机进入 永硕Ｅ盘、蓝奏云(密码: 8ppk)找到 magisk 模块并刷入，需要手机有 root 权限。 网站方式一使用 NPM 包管理器First, install the package via npm or yarn. npm install --save lxgw-wenkai-webfont # or Lite version npm install --save lxgw-wenkai-lite-webfont # or TC version npm install --save lxgw-wenkai-tc-webfont # or Screen version npm install --save lxgw-wenkai-screen-webfont Then import style.css to your main css style file and update the font-family. @import 'lxgw-wenkai-webfont/style.css'; /* Lite version */ @import 'lxgw-wenkai-lite-webfont/style.css'; /* TC version */ @import 'lxgw-wenkai-tc-webfont/style.css'; /* Screen version */ @import 'lxgw-wenkai-screen-webfont/style.css'; body &#123; font-family: \"LXGW WenKai\", sans-serif; /* Lite version */ font-family: \"LXGW WenKai Lite\", sans-serif; /* TC version */ font-family: \"LXGW WenKai TC\", sans-serif; /* Screen version */ font-family: \"LXGW WenKai Screen\", sans-serif; &#125; /* Mono font (optional) */ pre,code &#123; font-family: \"LXGW WenKai Mono\", sans-serif; /* Lite version */ font-family: \"LXGW WenKai Mono Lite\", sans-serif; /* TC version */ font-family: \"LXGW WenKai Mono TC\", sans-serif; &#125; 方式二使用 CDN 引入Put the jsDelivr &lt;link&gt; into your html head, then update the font-family. &lt;html> &lt;head> &lt;link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css\" /> &lt;!-- Lite version --> &lt;link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css\" /> &lt;!-- TC version --> &lt;link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css\" /> &lt;!-- Screen version --> &lt;link rel=\"stylesheet\" href=\"https://fastly.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css\" /> &lt;style> body &#123; font-family: \"LXGW WenKai\", sans-serif; /* Lite version */ font-family: \"LXGW WenKai Lite\", sans-serif; /* TC version */ font-family: \"LXGW WenKai TC\", sans-serif; /* Screen version */ font-family: \"LXGW WenKai Screen\", sans-serif; &#125; &lt;/style> &lt;/head> &lt;body> &lt;!-- Your code --> &lt;/body> &lt;/html> 方式三使用特定粗细的字体@import 'lxgw-wenkai-webfont/lxgwwenkai-regular.css'; @import 'lxgw-wenkai-webfont/lxgwwenkai-bold.css'; body &#123; font-family: \"LXGW WenKai\", sans-serif; &#125;","categories":[{"name":"web","slug":"web","permalink":"https://blog.newimg.ltd/categories/web/"},{"name":"custom","slug":"web/custom","permalink":"https://blog.newimg.ltd/categories/web/custom/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Code-Server","slug":"Code-Server","date":"2022-06-06T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/06/07/Code-Server/","link":"","permalink":"https://blog.newimg.ltd/2022/06/07/Code-Server/","excerpt":"关于Code-Server使用 Code-Server (VSCode) 可以搭建在线IDE，在任意机器通过浏览器运行 VS Code 。","text":"关于Code-Server使用 Code-Server (VSCode) 可以搭建在线IDE，在任意机器通过浏览器运行 VS Code 。 官网|项目地址|Docker项目地址 搭建Docker拉取镜像docker pull codercom/code-server 部署docker run -it \\ --name code-server \\ -p 18080:8080 \\ -v \"/data/coder/.config:/home/coder/.config\" \\ -v \"/data/coder/project:/home/coder/project\" \\ -u \"$(id -u):$(id -g)\" \\ -e \"DOCKER_USER=coder\" \\ -e PASSWORD='a-test-password' \\ -d codercom/code-server:latest 安装脚本如果使用安装脚本，则可以预览安装过程中发生的情况： curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run 要安装，请运行： curl -fsSL https://code-server.dev/install.sh | sh 完成后，安装脚本将打印出有关运行和启动代码服务器的说明。","categories":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/categories/experience/"},{"name":"linux","slug":"experience/linux","permalink":"https://blog.newimg.ltd/categories/experience/linux/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"备份和恢复Hexo博客","slug":"备份和恢复Hexo博客","date":"2022-06-06T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2022/06/07/备份和恢复Hexo博客/","link":"","permalink":"https://blog.newimg.ltd/2022/06/07/%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8DHexo%E5%8D%9A%E5%AE%A2/","excerpt":"前言由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。","text":"前言由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。 目前假设Git和Github环境已经配置好了，如果没有配置好详见「Ubuntu16.04下Github配置」。Git相关操作请参考廖雪峰的Git教程。 备份博客目前假设本地Hexo博客已经初始化，如果没有配置好Hexo博客详见「Ubuntu16.04下从零起步搭建配置github.io博客——Hexo」。 创建新分支在Github.io上建立博客时已经开了一个新仓库了，如果再开另一个仓库存放源代码有点浪费，因此采用建立新分支的方法备份博客。 虽然理论上什么时候创建新分支来备份都可以，但是还是建议在建立博客的时候就创建备份分支。（然而我中途才想起来-.-） 不过在建立新分支前请确保仓库内已有master分支（Hexo本地建站后第一次上传时会自动生成），否则后期再添加master分支比较麻烦（请自行搜索git命令）。 本地Git建立新分支命令如下： $ git checkout -b BRANCHNAME BRANCHNAME是自定义的新分支的名字，建议起为hexo。 建立.gitignore文件建立.gitignore文件将不需要备份的文件屏蔽。个人的.gitignore文件如下： .gitignore.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 在Github上备份通过如下命令将本地文件备份到Github上。 假设目前在hexo博客的根目录下。 $ git add . $ git commit -m \"Backup\" $ git push origin hexo 这样就备份完博客了且在Github上能看到两个分支(master和hexo)。 设置默认分支在Github上你的github.io仓库中设置默认分支为hexo。这样有助于之后恢复博客。master分支时默认的博客静态页面分支，在之后恢复博客的时候并不需要。 个人备份习惯个人而言习惯于先备份文件再生成博客。即先执行git add .,git commit -m &quot;Backup&quot;,git push origin hexo将博客备份完成，然后执行hexo g -d发布博客。 恢复博客目前假设本地Hexo博客基础环境已经搭好，如果没有配置好Hexo博客基础环境详见「Ubuntu16.04下从零起步搭建配置github.io博客——Hexo」。 克隆项目到本地输入下列命令克隆博客必须文件(hexo分支)： $ git clone https://github.com/yourgithubname/yourgithubname.github.io 恢复博客在克隆的那个文件夹下输入如下命令恢复博客： $ npm install hexo-cli $ npm install $ npm install hexo-deployer-git 在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。 完成喵～ Post author: Ruosen Li Post link: https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.newimg.ltd/categories/hexo/"},{"name":"backup","slug":"hexo/backup","permalink":"https://blog.newimg.ltd/categories/hexo/backup/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"练习题题解","slug":"题解","date":"2021-11-25T16:00:00.000Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"2021/11/26/题解/","link":"","permalink":"https://blog.newimg.ltd/2021/11/26/%E9%A2%98%E8%A7%A3/","excerpt":"","text":"java变量命名规则线程的各种状态并发和并行的区别解释一你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。 所以我认为它们最关键的点就是：是否是『同时』。 解释二Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别 并发是两个队列交替使用一台咖啡机，并行是两个队列同时使用两台咖啡机，如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人便秘了去厕所呆半天，后面的人也只能死等着他回来才能去接咖啡，这效率无疑是最低的。有评论里说，并发是不是一个线程，并行是多个线程？答：并发和并行都可以是很多个线程，就看这些线程能不能司时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu轮流切换着执行。 JVM JRE和JDK区别与联系首先 三者之间存在包含关系JVM + 核心类库 &#x3D; JRE JRE + java开发工具（javac.exe&#x2F;jar.exe) &#x3D; JDK 什么是JVM？Java Virtual Machine 即Java虚拟机 我们知道Java语言有一个独特的优点就是可以跨平台 像其它语言，比如C，我们要针对不同操作系统windows，mac……各出一套应用程序 而Java则可以做到一个软件在任何的操作系统中都能执行，这就是JVM的功劳 如下图 图片来自高新强老师JAVA课程 本来我们编写的Java代码计算机还是不认识的，但是我们在每一个操作系统上都会配置一个与之相对应的JVM，会帮我们把我们的Java代码翻译成对应操作系统可以识别的内容。 所以说我们在第一次写Java程序时都要先把JVM给装好。 什么是JRE？Java Runtime Environment 即Java运行环境 JVM + 核心类库 &#x3D; JRE 刚才不是说只需要装JVM吗？那这个JRE是个什么鬼东西？ 是因为只有JVM不能运行，它还需要核心类库，才能保证Java运行 由于JRE包含JVM 因此我们只要直接安装JRE 就顺便把JVM安装了 图片来自高新强老师JAVA课程 什么是JDK?Java Development Kit 即Java开发工具包 JRE + java开发工具（javac.exe&#x2F;jar.exe) &#x3D; JDK 这是因为我们是开发人员,我们是写软件的,软件光能运行不行啊,得给我们一个地方让我们来写代码吧?所以就需要java开发工具给我们腾出一个地儿来,好让我们coding 图片来自高新强老师Java网课 面向过程和面向对象的区别1. 面向过程面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。 举个例子，下五子棋，面向过程的设计思路是首先分析解决这个问题的步骤： （1）开始游戏（2）黑子先走（3）绘制画面（4）判断输赢（5）轮到白子（6）绘制画面（7）判断输赢（8）返回步骤（2） （9）输出最后结果。 用函数实现上面一个一个的步骤，然后在下五子棋的主函数里依次调用上面的函数（不同的编程语言有不同的调用方法，我这里写的是直接调用）： 下五子棋&#123; 开始游戏（）； 黑子先走（）； 绘制画面（）； 判断输赢（）； 轮到白子（）； 绘制画面（）； 判断输赢（）； 返回到 黑子先走（）； 输出最后结果； &#125; 可见，面向过程始终关注的是怎么一步一步地判断棋局输赢的，通过控制代码，从而实现函数的顺序执行。 2. 面向对象在日常生活或编程中，简单的问题可以用面向过程的思路来解决，直接有效，但是当问题的规模变得更大时，用面向过程的思想是远远不够的。所以慢慢就出现了面向对象的编程思想。世界上有很多人和事物，每一个都可以看做一个对象，而每个对象都有自己的属性和行为，对象与对象之间通过方法来交互。面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。 在下五子棋的例子中，用面向对象的方法来解决的话，首先将整个五子棋游戏分为三个对象: （1）黑白双方，这两方的行为是一样的。 （2）棋盘系统，负责绘制画面 （3）规则系统，负责判定犯规、输赢等。 然后赋予每个对象一些属性和行为： （4）第一类对象（黑白双方）负责接受用户输入，并告知第二类对象（棋盘系统）棋子布局的变化，棋盘系统接收到了棋子的变化，并负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。 可以看出，面向对象是以功能来划分问题，而不是以步骤解决。比如绘制画面这个行为，在面向过程中是分散在了多个步骤中的，可能会出现不同的绘制版本，所以要考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘系统这个对象中出现，从而保证了绘图的统一。 3. 优缺点比较面向过程优点： 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。 效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。 缺点： 需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。 面向对象优点: 结构清晰，程序是模块化和结构化，更加符合人类的思维方式； 易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统； 易维护，系统低耦合的特点有利于减少程序的后期维护工作量。 缺点： 开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。 性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。 举例说明两者的优缺点，比如在五子棋游戏中增加悔棋的功能。在面向过程中，从输入到显示再到最后判断的整个步骤都要改动，甚至函数的调用顺序也要改动，而在面向对象的设计中，只需在棋盘系统中增加一个回溯的功能就可以了，黑白双方和规则系统的属性和行为都不需改动。这个例子说明了面向对象程序设计中代码间的相关性低（低耦合特性），使得代码很容易被复用和扩展，同时也说明了面向过程的代码重用性低、扩展能力差。 Java程序编译运行过程java程序执行过程分为两步，下图为流程示意图 ​ 第一步：将java源码(.java文件)通过编译器(javac.exe)编译成JVM文件(.class文件) ​ 第二步：将JVM文件通过java.exe执行，输出结果 ​ 通过如上分析，我们发现JVM至关重要，其向上屏蔽了操作系统的差异，也正因为JVM的该作用，才使java这门编程语言能够实现跨平台， 其原理大致可描述为如下： Java抽象类abstract抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 通常只有继承才能实现类的功能。 Java访问修饰符通过以下表来说明访问权限： 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y&#x2F;N（说明） N default Y Y Y N N private Y N N N N 说明： 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"learn","slug":"learn","permalink":"https://blog.newimg.ltd/tags/learn/"}]},{"title":"2020-12-18-赛前总结","slug":"2020-12-18-比赛前总结","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/2020-12-18-比赛前总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/2020-12-18-%E6%AF%94%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93/","excerpt":"","text":"技巧1.getchar放回ungetc(val, stdin); 2.二分查首位#include &lt;stdio.h> #include &lt;algorithm> int a[1000000]; int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); int b[100000]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d\", &amp;b[i]); &#125; int mid; int *temp; for (int i = 0; i &lt; m; i++) &#123; temp = std::lower_bound(a, a + n, b[i]); mid = temp - &amp;a[0]; if (std::binary_search(a, a + n, b[i])) printf(\"%d \", mid + 1); else if (a[0] == 0 &amp;&amp; b[i] == 0) printf(\"1\"); else printf(\"-1 \"); &#125; return 0; &#125; 3.排序std::sort(a, a + n); 4.最大公约数std::__gcd(i, j); 5.最小公倍数i * j / std::__gcd(i, j); 6.斐波那契博弈有一堆个数为n的石子，游戏双方轮流取石子，满足：1)先手不能在第一次把所有的石子取完；2)之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。约定取走最后一个石子的人为赢家，求必败态。 结论：先手胜当且仅当n不是斐波那契数（n为物品总数） 7.威佐夫博弈有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 我们有如下公式：a表示第一堆的个数，b表示第二堆的个数，c表示二者之差，当然a必须小于b;再找规律的话我们会发现，a&#x3D; c* 1.618 部分模板素数筛法（运行时间约1.2s）char pend[100000005]; int odd[7123456]; void count() &#123; int count = 1; /* 定义 */ pend[1] = 1; //特判 for (int i = 2; i * i &lt;= 100000005; i++) &#123; if (!pend[i]) &#123; for (int j = i * i; j &lt;= 100000005; j += i) &#123; pend[j] = 1; &#125; &#125; &#125; /* 线筛 */ for (int i = 1; i &lt; 100000005; i++) &#123; if (!pend[i]) &#123; odd[count++] = i; &#125; &#125; /* 储存 */ return; &#125; 螺旋数列#include &lt;stdio.h> int main(void) &#123; int n; int value = 1; int i, j; scanf(\"%d\", &amp;n); int m[100][100]; /* 数组大小 */ for (i = 0; i &lt; (n + 1) / 2; i++) &#123; for (j = i; j &lt; n - i; j++) &#123; m[i][j] = value++; &#125; for (j = i + 1; j &lt; n - i; j++) &#123; m[j][n - i - 1] = value++; &#125; for (j = n - i - 2; j >= i; j--) &#123; m[n - i - 1][j] = value++; &#125; for (j = n - i - 2; j > i; j--) &#123; m[j][i] = value++; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123;/* 输出格式 */ printf(\"%5d\", m[i][j]) &#125; printf(\"\\n\"); &#125; return 0; &#125; #include &lt;stdio.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); if (n == 0) &#123; return 0; &#125; int m = n + n - 1; int q = n - 1; int t = 1; int a[n][n]; int *p; p = &amp;a[0][0]; int time = 1; for (int i = 0; i &lt; (n + n - 1); i++) &#123; if (time % 4 == 1) &#123; for (int j = 0; j &lt; q; j++) &#123; *p = t; p += 1; t++; *p = t; &#125; &#125; else if (time % 4 == 2) &#123; for (int j = 0; j &lt; q; j++) &#123; *p = t; p += n; t++; *p = t; &#125; &#125; else if (time % 4 == 3) &#123; for (int j = 0; j &lt; q; j++) &#123; *p = t; p -= 1; t++; *p = t; &#125; &#125; else if (time % 4 == 0) &#123; for (int j = 0; j &lt; q; j++) &#123; *p = t; p -= n; t++; *p = t; &#125; &#125; if (time % 2 &amp;&amp; time != 1) q -= 1; time++; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(\"%5d\", a[i][j]); &#125; printf(\"\\n\"); &#125; return 0; &#125; 刺痛值输入第一行有两个用空格隔开的整数，分别代表 n 和 m。第 22 到第 (n + 1) 行，每行一个整数，第 (i + 1) 行的整数 a_i代表第 i 件事的刺痛值 a_i。输出输出一行一个整数，表示连续 m 个刺痛值的和的最小值是多少。 #include &lt;stdio.h> int main(void) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); int a[n]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; int b = 0, min; for (int i = 0; i &lt; n - m; i++) &#123; b = 0; for (int j = 0; j &lt; m; j++) &#123; b += a[i + j]; &#125; if (b &lt;= min || i == 0) min = b; &#125; if (!m || !n) &#123; min = 0; &#125; else if(!(m - n)) &#123; for (int j = 0; j &lt; m; j++) &#123; b += a[j]; &#125; min = b; &#125; printf(\"%d\", min); return 0; &#125; 观察下面的数字金字塔。写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 7 3 8 8 1 0 2 7 4 44 5 2 6 5 #include &lt;stdio.h> #include &lt;algorithm> int a[1200][1200]; int b; int sum; int main(void) &#123; int m, t, o, temp; scanf(\"%d\", &amp;m); o = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; o; j++) &#123; scanf(\"%d\", &amp;a[i][j]); &#125; o++; &#125; t = m; for (int j = 0; j &lt; m; j++) &#123; for (int i = 0; i &lt; t; i++) &#123; temp = std::max(a[m - j][i], a[m - j][i + 1]); a[m - j - 1][i] += temp; &#125; t--; &#125; b = a[0][0]; printf(\"%d\\n\", b); return 0; &#125; 火柴棒等式#include &lt;stdio.h> int main() &#123; int a[2001] = &#123;6&#125;, b, c[10] = &#123;6, 2, 5, 5, 4, 5, 6, 3, 7, 6&#125;, s = 0, i, j; scanf(\"%d\", &amp;b); for (i = 1; i &lt;= 2000; i++) &#123; j = i; while (j >= 1) //求每个数所用的火柴棒 &#123; a[i] = a[i] + c[j % 10]; j = j / 10; &#125; &#125; for (i = 0; i &lt;= 1000; i++) &#123; for (j = 0; j &lt;= 1000; j++) if (a[i] + a[j] + a[i + j] + 4 == b) s++; //还有加号与等号 &#125; printf(\"%d\", s); return 0; &#125; 彩票摇奖in223 31 1 14 19 17 1812 8 9 23 1 16 711 7 10 21 2 9 31out0 0 0 0 0 1 1 #include &lt;stdio.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); int a[n + 2][7]; int count; for (int i = 0; i &lt; n + 1; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; scanf(\"%d\", &amp;a[i][j]); &#125; &#125; for (int i = 0; i &lt; 7; i++) &#123; a[n + 1][i] = 0; &#125; for (int i = 1; i &lt; n + 1; i++) &#123; count = 0; for (int j = 0; j &lt; 7; j++) &#123; for (int k = 0; k &lt; 7; k++) &#123; if (a[i][j] == a[0][k]) &#123; count++; &#125; &#125; &#125; a[n + 1][7 - count]++; &#125; for (int i = 0; i &lt; 7; i++) &#123; printf(\"%d\", a[n + 1][i]); if (i != 6) &#123; printf(\" \"); &#125; &#125; return 0; &#125; 移动字符串in1qweoutrxf #include &lt;stdio.h> #include &lt;string.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); char a[60]; scanf(\"%s\", &amp;a); int m = strlen(a); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (a[j] == 'z') &#123; a[j] = 'a'; &#125; else if (a[j] == 'Z') &#123; a[j] = 'A'; &#125; else &#123; a[j]++; &#125; &#125; &#125; puts(a); return 0; &#125; dp#include &lt;stdio.h> #include &lt;algorithm> int main() &#123; int w[110], val[110]; int dp[110][110]; int t, m, res = -1; scanf(\"%d%d\", &amp;t, &amp;m);/* t为时间，m为数目 */ for (int i = 1; i &lt;= m; i++) &#123;/* 时间，价值 */ scanf(\"%d%d\", &amp;w[i], &amp;val[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = t; j >= 0; j--) &#123; if (j >= w[i]) &#123;/* dp */ dp[i][j] = std::max(dp[i - 1][j - w[i]] + val[i], dp[i - 1][j]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; printf(\"%d\", dp[m][t]); return 0; &#125; 杨辉三角#include &lt;stdio.h> int a[21][21]; int main(void) &#123; int n = 0, count = 1; scanf(\"%d\", &amp;n); a[0][0] = a[1][0] = a[1][1] =1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; count; j++) &#123; if (i != 0 &amp;&amp; i != 1) &#123; a[i][j] = a[i - 1][j] + a[i - 1][j - 1]; &#125; printf(\"%d\", a[i][j]); if (i - 1 != count) &#123; printf(\" \"); &#125; &#125; printf(\"\\n\"); count++; &#125; return 0; &#125; 回文质数// #include &lt;stdio.h> // char pend[100000005]; // void odd() // &#123; // int count = 1; // /* 定义 */ // pend[1] = 1; //特判 // for (int i = 2; i * i &lt;= 100000005; i++) // &#123; // if (!pend[i]) // &#123; // for (int j = i * i; j &lt;= 100000005; j += i) // &#123; // pend[j] = 1; // &#125; // &#125; // &#125; // /* 线筛 */ // return; // &#125; // int pend2(int num) // &#123; // int temp = num, ans = 0; // while (temp) // &#123; // ans = ans * 10 + temp % 10; // temp /= 10; // &#125; // if (ans == num) // return 1; // else // return 0; // &#125; // int main(void) // &#123; // odd(); // for (int i = 4; i &lt; 100000000; i++) // &#123; // if (pend2(i) &amp;&amp; !pend[i]) // &#123; // printf(\"%d, \", i); // &#125; // &#125; // return 0; // &#125; #include &lt;stdio.h> int odd[100000] = &#123;&#125;;//略 int main(void) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); for (int i = 0; odd[i]; i++) &#123; if (odd[i] &lt;= b &amp;&amp; odd[i] >= a) &#123; printf(\"%d\\n\", odd[i]); &#125; &#125; return 0; &#125; 与 n 互质的第 k 个正整数。#include &lt;stdio.h> #include &lt;algorithm> int a[1000005]; int main(void) &#123; int n, k, ans = 0; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) &#123; if (std::__gcd(i, n) == 1) &#123; a[ans++] = i; &#125; &#125; printf(\"%d\", (k - 1) / ans * n + a[(k - 1) % ans]); return 0; &#125; 深搜&amp;质数7 3 3 1 全部肋骨上的数字 7331 是质数；三根肋骨 733733 是质数；二根肋骨 73 是质数；当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。 #include &lt;stdio.h> #include &lt;math.h> int a[4] = &#123;1, 3, 7, 9&#125;; int n; int pend(int x) &#123; if (x == 1) return 0; if (x == 2) return 1; for (int i = 2; i &lt;= sqrt(x); i++) if (x % i == 0) &#123; return 0; &#125; return 1; &#125; void DFS(int k, int sum) &#123; int p; if (!(sum - n)) &#123; printf(\"%d\\n\", k); &#125; else &#123; for (int i = 0; i &lt; 4; i++) &#123; p = k * 10 + a[i]; if (pend(p)) &#123; DFS(p, sum + 1); &#125; &#125; &#125; &#125; int main(void) &#123; scanf(\"%d\", &amp;n); DFS(2, 1); DFS(3, 1); DFS(5, 1); DFS(7, 1); return 0; &#125; Nim博弈#include &lt;stdio.h> int main(void) &#123; int t, n, val, ans; scanf(\"%d\", &amp;t); for (int i = 0; i &lt; t; i++) &#123; ans = 0; scanf(\"%d\", &amp;n); for (int j = 0; j &lt; n; j++) &#123; scanf(\"%d\", &amp;val); ans ^= val; &#125; if (!ans) &#123; printf(\"No\\n\"); &#125; else &#123; printf(\"Yes\\n\"); &#125; &#125; return 0; &#125; 阶乘之乘#include &lt;stdio.h> int main(void) &#123; long long int n, ans = 0; scanf(\"%lld\", &amp;n); for (int i = n; i > 4; i--) &#123; ans += i / 5 + i / 25 + i / 125 + i / 625 + i / 3125 + i / 15625 + i / 78125 + i / 390625 + i / 1953125 + i / 9765625 + i / 48828125; // while (temp) // &#123; // ans += temp / 5; // temp /= 5; // &#125; &#125; printf(\"%lld\", ans); return 0; &#125; 阶乘之和(Python)num = int(input()) ans = 0 while num > 0 : fact = 1 for i in range(1, num + 1): fact = fact * i ans += fact num = num - 1 print(ans) 取数游戏有一个取数的游戏。初始时，给出一个环，环上的每条边上都有一个非负整数。这些整数中至少有一个0。然后，将一枚硬币放在环上的一个节点上。两个玩家就是以这个放硬币的节点为起点开始这个游戏，两人轮流取数，取数的规则如下： （1）选择硬币左边或者右边的一条边，并且边上的数非0； （2）将这条边上的数减至任意一个非负整数(至少要有所减小)； （3）将硬币移至边的另一端。 如果轮到一个玩家走，这时硬币左右两边的边上的数值都是0，那么这个玩家就输了。 如下图，描述的是Alice和Bob两人的对弈过程，其中黑色节点表示硬币所在节点。结果图(d)中，轮到Bob走时，硬币两边的边上都是0，所以Alcie获胜。 （a）Alice （b）Bob （c）Alice （d）Bob 现在，你的任务就是根据给出的环、边上的数值以及起点（硬币所在位置），判断先走方是否有必胜的策略。 #include &lt;stdio.h> int main() &#123; int n, a[30], left = 0, right = 0, flag1 = 1, flag2 = 1; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[left] &amp;&amp; flag1) &#123; left++; &#125; else &#123; flag1 = 0; &#125; if (a[n - right - 1] &amp;&amp; flag2) &#123; right++; &#125; else &#123; flag2 = 0; &#125; &#125; if (left % 2) &#123; printf(\"YES\\n\"); &#125; else if (right % 2) &#123; printf(\"YES\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125; return 0; &#125; 博弈B游戏要求在一个有 nn 个顶点凸多边形上进行，这个凸多边形的 n-3n−3 条对角线将多边形分成 n-2n−2 个三角形，这 n-3n−3 条对角线在多边形的顶点相交。三角形中的一个被染成黑色，其余是白色。 双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。胖子一看觉得确实很有趣，不如就一起玩玩吧。假设游戏由野猫先开始，那么野猫是否有必胜的策略呢？请写一个程序帮助野猫算一算。 #include &lt;cstdio> #include &lt;algorithm> using namespace std; int n, a, b, c, aa, bb, cc; void Sort(int &amp;x, int &amp;y, int &amp;z) &#123; if (x > y) swap(x, y); if (x > z) swap(x, z); if (y > z) swap(y, z); &#125; int main() &#123; scanf(\"%d\", &amp;n); //读入黑色三角形的三个顶点编号 scanf(\"%d %d %d\", &amp;aa, &amp;bb, &amp;cc); //将三个编号从小到大排序，方便判断 Sort(aa, bb, cc); //读入剩下的三角形编号 for (int i = 2; i &lt;= n - 2; i++) scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); //判断黑色三角形是否能够第一刀切到 if (aa + 1 == bb &amp;&amp; bb + 1 == cc) &#123; //编号连续代表三角形在外边 puts(\"JMcat Win\"); return 0; &#125; //当黑色三角形顶点最小是0是需要特判3种情况 if (aa == 0) &#123; if ((bb == 1 &amp;&amp; cc == n - 1) || (bb == 1 &amp;&amp; cc == 2) || (bb == n - 2 &amp;&amp; cc == n - 1)) &#123; puts(\"JMcat Win\"); return 0; &#125; &#125; //这里思路已经说过 if ((n - 2) % 2 == 1) puts(\"PZ Win\"); else puts(\"JMcat Win\"); return 0; &#125; 进制转化#include &lt;stdio.h> #include &lt;math.h> #include &lt;string.h> int main(void) &#123; int val1, val2, val = 0; char num[50]; scanf(\"%d\", &amp;val1); /* 输入进制 */ scanf(\"%s\", &amp;num); scanf(\"%d\", &amp;val2); /* 输出进制 */ int n = strlen(num) - 1; for (int i = 0; i &lt; strlen(num); i++) &#123; if (num[i] >= 'A') &#123; val += pow(val1, n) * (num[i] - 'A' + 10); &#125; else &#123; val += pow(val1, n) * (num[i] - '0'); &#125; n--; &#125; for (int i = 0; 1; i++) &#123; if (val / pow(val2, i) &lt;= 1) &#123; n = i; break; &#125; &#125; char a[50]; for (int i = 0; i &lt; n; i++) &#123; a[i] = (int)(val / pow(val2, n - i - 1)) % val2; if (a[i] >= 10) &#123; a[i] = a[i] - 10 + 'A'; &#125; else &#123; a[i] = a[i] + '0'; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%c\", a[i]); &#125; return 0; &#125; 汉诺塔#include &lt;stdio.h> int k = 1; int move(char getone, int n, char putone) &#123; k++; return 0; &#125; int hanoi(int n, char x, char y, char z) &#123; if (n == 1) move(x, 1, z); else &#123; hanoi(n - 1, x, z, y); move(x, n, z); hanoi(n - 1, y, x, z); &#125; return 0; &#125; int main() &#123; int n, counter; scanf(\"%d\", &amp;n); counter = hanoi(n, 'A', 'B', 'C'); printf(\"%d\\n\", k - 1); return 0; &#125; 全排列7-3-2-10123 #include &lt;iostream> #include &lt;algorithm> using namespace std; int main() &#123; int n; cin >> n; int a[100]; for (int i = 0; i &lt; n; i++) &#123; a[i] = i + 1; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%5d\", a[i]); &#125; printf(\"\\n\"); while (next_permutation(a, a + n)) &#123; for (int i = 0; i &lt; n; i++) &#123; printf(\"%5d\", a[i]); &#125; printf(\"\\n\"); &#125; return 0; &#125; 3个数和为0#include &lt;stdio.h> #include &lt;algorithm> #include &lt;string.h> int main(void) &#123; int n, count = 0, t; scanf(\"%d\", &amp;n); int a[10000], temp[3]; int ans[10000][3]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; std::sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; for (int k = j + 1; k &lt; n; k++) &#123; if (a[i] + a[j] + a[k] == 0) &#123; printf(\"%d %d %d\\n\", a[i], a[j], a[k]); count++; &#125; &#125; &#125; &#125; if (!count) &#123; printf(\"No Solution\\n\"); &#125; return 0; &#125; 区间合并55 61 510 106 98 10 #include &lt;stdio.h> #include &lt;algorithm> #include &lt;string.h> int main(void) &#123; int n, count = 0, t; scanf(\"%d\", &amp;n); int a[10000], temp[3]; int ans[10000][3]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; std::sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; for (int k = j + 1; k &lt; n; k++) &#123; if (a[i] + a[j] + a[k] == 0) &#123; printf(\"%d %d %d\\n\", a[i], a[j], a[k]); count++; &#125; &#125; &#125; &#125; if (!count) &#123; printf(\"No Solution\\n\"); &#125; return 0; &#125; 数列有序3 31 2 40 0 #include &lt;stdio.h> #include &lt;algorithm> #include &lt;string.h> int main(void) &#123; int n, count = 0, t; scanf(\"%d\", &amp;n); int a[10000], temp[3]; int ans[10000][3]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; std::sort(a, a + n); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; for (int k = j + 1; k &lt; n; k++) &#123; if (a[i] + a[j] + a[k] == 0) &#123; printf(\"%d %d %d\\n\", a[i], a[j], a[k]); count++; &#125; &#125; &#125; &#125; if (!count) &#123; printf(\"No Solution\\n\"); &#125; return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Java基础类库","slug":"Java基础类库","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Java基础类库/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/","excerpt":"该博客转载自温柔的养猫人，仅供学习参考。 StringBuffer类","text":"该博客转载自温柔的养猫人，仅供学习参考。 StringBuffer类 String类时在所有项目开发之中一定会使用的功能类，这个类拥有如下的特点： 每一个字符串的常量都属于String类的匿名对象，并且不可更改； String有两个常量池，静态常量池、运行时常量池； String类对象实例化建议使用直接赋值的形式完成，这样可以直接将对象保存在对象池之中以方便下次重用； 虽然String类很好使用，但是如果认真去思考也会发现其最大的弊端：内容不允许修改。虽然大部分情况下不会涉及到字符串内容的频繁修改，但是依然可能会存在有这样的情况，所以为了解决此问题，专门提供有一个StringBuffer类可以实现字符串内容的修改处理。 StringBuffer并不像String类那样拥有两种对象实例化方式，StringBuffer必须像普通类对象那样首先进行对象实例化，而后才可以调用方法执行处理，而这个时候可以考虑使用StringBuffer类中的如下方法： 构造方法：public StringBuffer()； 构造方法：public StringBuffer(String str)，接收初始化字符串内容； 数据追加：public StringBuffer append(数据类型 变量)，相当于字符串中“+”操作； 范例：观察String和StringBuffer对比String类对象引用传递 public class JavaAPIDemo &#123; public static void main(String[] args) &#123; String str = \"Hello\"; change(str); System.out.println(str); //Hello &#125; public static void change(String temp) &#123; temp += \"World !\"; //内容并没有发生改变 &#125; &#125; StringBuffer类对象引用传递 public class JavaAPIDemo &#123; public static void main(String[] args) &#123; StringBuffer buf = new StringBuffer(\"Hello\") ; change(buf) ; System.out.println(buf.toString()); //Hello World ! &#125; public static void change(StringBuffer temp) &#123; temp.append(\" World !\"); //内容已改变 &#125; &#125; 实际上大部分的情况下，很少会出现有字符串内容的改变，这种改变并不是针对静态常量池的改变。范例：分析一下已有问题 public class JavaAPIDemo &#123; public static void main(String[] args) &#123; String strA = \"www.mldn.cn\"; String strB = \"www.\" + \"mldn\" + \".cn\"; System.out.println(strA == strB) ; //true &#125; &#125; 这时的strB对象的内容并不是改变，从更加严格的意义上说，对于现在的strB当程序编译后会变成如下的形式： public class JavaAPIDemo &#123; public static void main(String[] args) &#123; // String strB = \"www.\" + \"mldn\" + \".cn\"; //等同于 StringBuffer strB=new StringBuffer(); strB.append(\"www.\").append(\"mldn\").append(\".cn\"); &#125; &#125; 所有的“+” 在编译后都变为了StringBuffer中的append()方法，并且在程序之中StringBuffer和String类对象之间本来就可以直接互相转换： String类对象变为StringBuffer可以依靠StringBuffer类的构造方法或者使用append()方法； 所有的类对象都可以通过toString()方法将其变为String类型； 在StringBuffer类中除了可以支持有字符串内容的修改之外，实际上还提供了一些String类不具备的方法：1、插入数据：public StringBuffer insert(int offset, 数据类型 b)； public class JavaAPIDemo &#123; public static void main(String[] args) &#123; StringBuffer buf=new StringBuffer(); buf.append(\".cn\").insert(0,\"www.\").insert(4,\"mldn\"); System.out.println(buf.toString()); //www.mldn.cn &#125; &#125; 2、删除指定范围的数据：public StringBuffer delete(int start, int end)； public class JavaAPIDemo &#123; public static void main(String[] args) &#123; StringBuffer buf=new StringBuffer() ; buf.append(\"Hello World !\").delete(6,12).insert(6, \"MLDN\") ; //Hello MLDN ! System.out.println(buf) ; &#125; &#125; 3、字符串内容反转：public StringBuffer reverse()； public class JavaAPIDemo &#123; public static void main(String[] args) &#123; StringBuffer buf=new StringBuffer(); buf.append(\"Hello World !\"); System.out.println(buf.reverse()); //! dlroW olleH &#125; &#125; 实际上与StringBuffer类还有一个类似的功能类：StringBuilder类，这个类是在JDK1.5的时候提供的，该类中提供的方法与StringBuffer功能相同，最大区别在于StringBuffer类中的方法属于线程安全的，全部使用了synchronized关键字进行标注，而StringBuilder类属于非线程安全的， 面试题：请解释String、StringBuffer、StringBuilder的区别？ 1）String类是字符串的首选类型，其最大的特点是内容不允许修改； 2）StringBuffer与StringBuilder类的内容允许修改； 3）StringBuffer是在JDK1.0时提供的，属于线程安全的操作，而StringBuilder是JDK1.5之后提供的，属于非线程安全的操作； CharSequence接口CharSequence是一个描述字符串结构的接口，在这个接口中有三种常用子类： String类： public final class String extends Object implements Serializable, Comparable&lt;String>, CharSequence； StringBuffer类： public final class StringBuffer extends Object implements Serializable, CharSequence； StringBuilder类： public final class StringBuilder extends Object implements Serializable, CharSequence； 图一 CharSequence 现在只要有字符串就可以为CharSequence接口实例化。 public class JavaAPIDemo &#123; public static void main(String[] args) &#123; CharSequence str=\"www.mldn.cn\" ; //子类实例向父接口转型 &#125; &#125; CharSequence本身是一个接口，在该接口中定义了如下操作方法： 获取指定索引字符：public char charAt(int index)；获取字符串长度：public int length()；截取部分字符串：public CharSequence subSequence(int start, int end)；范例：字符串截取 public class JavaAPIDemo &#123; public static void main(String[] args) &#123; CharSequence str=\"www.mldn.cn\" ; //子类实例向父接口转型 CharSequence sub=str.subSequence(4,8) ; System.out.println(sub) ; //mldn &#125; &#125; 以后只要看见CharSequence描述的就是一个字符串。 AutoCloseable接口AutoCloseable主要是用于日后进行资源开发的处理上，以实现资源的自动关闭（释放资源），例如：在以后进行文件、网络以及数据库开发的过程中，由于服务器的资源有限，所以使用之后一定要关闭资源，这样才可以被更多的使用者所使用。下面为了更好的说明资源的问题，将通过一个消息的发送处理来完成。范例：手工实现资源处理 interface IMessage &#123; public void send(); //消息发送 &#125; class NetMessage implements IMessage &#123; //实现消息的处理机制 private String msg; public NetMessage(String msg) &#123; this.msg = msg; &#125; @Override public void send() &#123; if (this.open()) &#123; System.out.println(\"【*** 发送消息 ***】\" + this.msg); &#125; &#125; public boolean open() &#123; //获取资源连接 System.out.println(\"【OPEN】获取消息发送连接资源\") ; return true ; &#125; public void close() &#123; System.out.println(\"【CLOSE】关闭消息发送通道\") ; &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) &#123; NetMessage nm = new NetMessage(\"www.mldn.cn\") ; //定义要发送的处理 nm.send() ; //消息发送 nm.close() ; //关闭连接 &#125; &#125; 图一 手工实现资源处理 此时有人说，既然所有的资源完成处理后都必须进行关闭操作，那么能否实现一种自动关闭呢？在这样的要求下，由此推出了AutoCloseable访问接口，这个接口是在JDK1.7的时候提供的，并且该接口只提供有一个方法： 关闭方法：public void close() throws Exception； 图二 AutoCloseable 要想实现自动关闭处理，除了要使用AutoCloseable外，还需要结合异常处理语句才可以正常调用。范例：实现自动关闭处理 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; try (IMessage nm = new NetMessage(\"www.mldn.cn\"))&#123; nm.send(); //消息发送 &#125;catch (Exception e)&#123;&#125; &#125; &#125; interface IMessage extends AutoCloseable&#123; void send(); //消息发送 &#125; class NetMessage implements IMessage &#123; //实现消息的处理机制 private String msg; public NetMessage(String msg) &#123; this.msg = msg; &#125; @Override public void send() &#123; if (this.open()) &#123; System.out.println(\"【*** 发送消息 ***】\" + this.msg); &#125; &#125; public boolean open() &#123; //获取资源连接 System.out.println(\"【OPEN】获取消息发送连接资源\"); return true; &#125; @Override public void close() throws Exception&#123; System.out.println(\"【CLOSE】关闭消息发送通道\"); &#125; &#125; 图三 实现自动关闭处理 在以后的章节之中会接触到资源的关闭问题，往往都会见到AutoCloseable接口的使用。 Runtime类Runtime描述的是运行时的状态，也就是说在整个JVM中，Runtime类是唯一一个与JVM运行状态有关的类，并且都会默认提供有一个该类的实例化对象。 由于在每一个JVM进程里面只允许提供有一个Runtime类的对象，所以这个类的构造方法被默认私有化了，那么就证明该类使用的是单例设计模式，并且单例设计模式一定会提供一个static方法获取本类实例。 Runtime 由于Runtime类属于单例设计模式，如果想要获取实例化对象，那么就可以依靠类中的getRuntime()方法完成： 获取实例化对象： public static Runtime getRuntime()； 通过这个类中的availableProcessors()方法可以获取本机的CPU内核数：public int availableProcessors()； 范例：获取Runtime对象 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; Runtime run=Runtime.getRuntime(); //获取实例化对象 System.out.println(run.availableProcessors()); &#125; &#125; 但是除了以上的方法之外，在Runtime类里面还提供有以下四个重要的操作方法： 获取最大可用内存空间：public long maxMemory()，默认的配置为本机系统内存的4分之1； 获取可用内存空间：public long totalMemory()，默认的配置为本机系统内存的64分之1； 获取空闲内存空间：public long freeMemory(); 手工进行GC处理：public void gc(); 范例：观察内存状态 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; Runtime run=Runtime.getRuntime(); //获取实例对象 System.out.println(\"【1】MAX_MEMORY：\"+run.maxMemory()); System.out.println(\"【1】TOTAL_MEMORY：\"+run.totalMemory()); System.out.println(\"【1】FREE_MEMORY：\"+run.freeMemory()); String str=\"\"; for (int x = 0; x &lt; 30000; x++) &#123; str += x; //产生大量的垃圾空间 &#125; System.out.println(\"【2】MAX_MEMORY：\"+run.maxMemory()); System.out.println(\"【2】TOTAL_MEMORY：\"+run.totalMemory()); System.out.println(\"【2】FREE_MEMORY：\"+run.freeMemory()); Thread.sleep(2000); run.gc(); System.out.println(\"【3】MAX_MEMORY：\"+run.maxMemory()); System.out.println(\"【3】TOTAL_MEMORY：\"+run.totalMemory()); System.out.println(\"【3】FREE_MEMORY：\"+run.freeMemory()); &#125; &#125; 运行结果图 面试题：请问什么是GC？如何处理？GC（Garbage Collector）垃圾收集器，是可以由系统自动调用的垃圾释放功能，或者使用Runtime类中的gc()手工调用。 System类System类是一直陪伴着我们学习的程序类，之前使用的系统输出采用的就是System类中的方法，而后在System类里面也定义有一些其他的处理方法： 数组拷贝：public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)； 获取当前的日期时间数值：public static long currentTimeMillis()； 进行垃圾回收：public static void gc()； 范例：操作耗时的统计 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; long start=System.currentTimeMillis(); String str=\"\"; for (int x = 0; x &lt; 30000; x++) &#123; str += x;//产生大量的垃圾空间 &#125; long end = System.currentTimeMillis(); System.out.println(\"操作耗时：\"+(end - start)); //操作耗时：984 &#125; &#125; 在System类里面也提供有一个gc()方法。但是这个gc()方法并不是重新定义的新方法，而是继续调用Runtime类中的gc()操作（Runtime.getRuntime().gc();）。 Cleaner类Cleaner是在JDK1.9之后提供的一个对象清理操作，其主要的功能是进行finalize()方法的替代。在C++语言里面有两种特殊的函数：构造函数、析构函数（对象手工回收），在Java里面所有的垃圾空间都是通过GC自动回收的，所以很多情况下是不需要使用这类析构函数的，也正是因为如此，所以Java并没有提供这方面支持。但是Java本身依然提供了给用户收尾的操作，每一个实例化对象在回收之前至少给它一个喘息的机会。最初实现对象收尾处理的方法是Object类中所提供的finalize()方法，这个方法的定义如下： @Deprecated(since=\"9\") protected void finalize() throws Throwable 该替换指的是不建议继续使用这个方法了，而是说子类可以继续使用这个方法名称。 但是这个方法上最大的特点就是抛出了一个Throwable异常类型，而这个异常类型分为两个子类型：Error、Exception，平常所处理的都是Exception。 范例：观察传统回收 class Member&#123; public Member() &#123; System.out.println(\"【构造】在一个雷电交加的日子里面，林强诞生了。\"); &#125; @Override protected void finalize() throws Throwable &#123; System.out.println(\"【回收】最终你一定要死的\"); throw new Exception(\"我还要再活500年...\"); &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; Member mem=new Member(); //诞生 mem = null; //成为垃圾 System.gc(); System.out.println(\"太阳照常升起，地球照样转动。\"); &#125; &#125; 运行结果一 但是从JDK1.9开始，这一操作已经不建议使用了，而对于对象回收释放，从JDK1.9开始建议开发者使用AutoCloseable或者使用java.lang.ref.Cleaner类进行回收处理（Cleaner也支持有AutoCloseable处理）； class Member implements Runnable&#123; public Member() &#123; System.out.println(\"【构造】在一个雷电交加的日子里面，林强诞生了。\"); &#125; @Override public void run() &#123;//执行清除的时候执行的是此操作 System.out.println(\"【回收】最终你一定要死的\"); &#125; &#125; class MemberCleaning implements AutoCloseable&#123; //实现清除的处理 private static final Cleaner cleaner=Cleaner.create(); //创建一个清除处理 private Member member; private Cleaner.Cleanable cleanable; public MemberCleaning() &#123; this.member = new Member();//创建新对象 this.cleanable=this.cleaner.register(this,this.member); //注册使用的对象 &#125; @Override public void close() throws Exception &#123; this.cleanable.clean(); //启动多线程 &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception&#123; try(MemberCleaning mc=new MemberCleaning()) &#123; //中间可以执行一些相关的代码 &#125;catch (Exception e)&#123;&#125; &#125; &#125; 运行结果二 在新一代的清除回收处理的过程之中，更多的情况下考虑的是多线程的使用，即：为了防止有可能造成的延迟处理，所以许多对象回收前的处理都是单独通过一个线程完成的。 对象克隆所谓的对象克隆指的就是对象的复制，而且属于全新的复制。即：使用已有对象内容创建一个新的对象，如果要想使用对象克隆需要使用到Object类中提供的clone()方法： protected Object clone() throws CloneNotSupportedException； 所有的类都会继承Object父类，所以所有的类都一定会有clone()方法，但是并不是所有的类都希望被克隆。所以如果要想实现对象克隆，那么对象所在的类需要实现一个Cloneable接口，此接口并没有任何的方法提供，是因为它描述的是一种能力。 范例：实现对象克隆 class Member implements Cloneable &#123; private String name; private int age; public Member(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"【\" + super.toString() + \"】name = \" + this.name + \"、age = \" + this.age; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); //调用父类提供的clone()方法 &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Member memberA=new Member(\"林强\",30); Member memberB=(Member)memberA.clone(); System.out.println(memberA); System.out.println(memberB); &#125; &#125; 运行结果三","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Java多线程/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"简介重要性及开发历史在Java语言里面最大的特点是支持多线程的开发（也是为数不多支持多线程的编程语言），所以在整个的java技术的学习里面，如果你不能够对多线程的概念有一个全面并且细致的了解，则在日后进行些项日设计的过程之中尤其是并发访问设计的过程之中就会出现严重的技术缺漏。 如果要想理解线程，那么首先就需要了解一下进程的概念，在传统的DOS系统的时代，其本身有一个特征：如果你电脑上出现了病毒，那么所有的程序将无法执行，因为传统的DOS采用的是单进程处理，而单进程处理的最大特点：在同一个时间段上只允许一个程序在执行。","text":"简介重要性及开发历史在Java语言里面最大的特点是支持多线程的开发（也是为数不多支持多线程的编程语言），所以在整个的java技术的学习里面，如果你不能够对多线程的概念有一个全面并且细致的了解，则在日后进行些项日设计的过程之中尤其是并发访问设计的过程之中就会出现严重的技术缺漏。 如果要想理解线程，那么首先就需要了解一下进程的概念，在传统的DOS系统的时代，其本身有一个特征：如果你电脑上出现了病毒，那么所有的程序将无法执行，因为传统的DOS采用的是单进程处理，而单进程处理的最大特点：在同一个时间段上只允许一个程序在执行。 那么后来到了 Windows时代就开启了多进程的设计，于是就表示在一个时间段上可以同时运行多个程序，并且这些程序将进行资源的轮流抢占，所以在同一个时间段上会有多个程序依次执行，但是在同一个时间点上只会有一个进程执行，而后来到了多核的CPU,由于可以处理的CPU多了，那么即便有再多的进程出现，也可以比单核CPU处理的速度有所提升。 线程是在进程基础之上划分的更小的程序单元，线程是在进程基础上创建并且使用的，所以线程依赖进程的支持，但是线程的启动速度要比进程快许多，所以当使用多线程进行并发处理的时候其执行的性能要高于进程。 Java是多线程的编程语言，所以Java在进行并发访问处理时可以得到更高的性能。 如果要想在Java之中实现多线程的定义，那么就需要有一个专门的线程主体类进行线程的执行任务的定义，而这个主体类的 定义是有要求的，必须实现特定的接口或者继承特定的父类オ可以完成。 作用多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 创建一个线程Java 提供了三种创建线程的方法： 通过 Runnable 接口实现； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过继承 Thread 类本身创建线程的主体类Java里面提供有一个java.lang.Thread的程序类，那么一个类只要继承了此类就表示这个类为线程的主体类；但是并不是说这个类就可以直接实现多线程处理了，因为还需要覆写 Thread类中提供的一个 run()（public void run()）方法，而这个方法就属于线程的主方法。 /ThreadDemo.javaclass Mythread extends Thread &#123; //线程的主体类 private String title; public Mythread(String title) &#123; this.title = title; &#125; @Override public void run() &#123; //线程的主体方法 //IntStream.range(0, 19).mapToObj(x -> this.title + \"运行，x=\" + x).forEach(System.out::println); for (int x = 0; x &lt; 19; x++) &#123; System.out.println(this.title + \"运行，x=\" + x); &#125; &#125; &#125; 调用方法多线程要执行的功能都应该在run()方法中进行定义。需要说明的是：在正常情况下如果要想使用一个类中的方法，那么肯定要产生实例化对象，而后去调用类中提供的方法，但是run()方法是不能够被直接调用的，因为这里面牵扯到一个操作系统的资源调度问题，所以要想启动多线程必须使用 start()方法完成（public void start()）。 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; - new MyThread(\"线程A\").run(); - new MyThread(\"线程B\").run(); - new MyThread(\"线程C\").run(); + new MyThread(\"线程A\").start(); + new MyThread(\"线程B\").start(); + new MyThread(\"线程C\").start(); &#125; &#125; 为什么多线程必须使用 Thread类中的star()方法启动通过以上的调用你可以发现，虽然调用了是 start()方法，但是最终执行的是run()方法，并且所有的线程对象都是交替执行的。 为什么多线程的启动不直接使用run()方法而必须使用 Thread类中的star()方法呢？ 如果要想清楚这个问题，可以直接观察源代码。 /SourceCodepublic synchronized void start() &#123; if (threadStatus != 0) //判断线程的状态。 throw new IllegalThreadStateException(); //抛出了一个异常 group.add(this); boolean started = false; try &#123; start0(); //在start()方法里面调用了 start0()方法 started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; private native void start0(); //只定义了方法名称，但是没有实现 发现在start()方法里面会抛出一个&quot;Illegal Thread State Exception&quot;异常类对象，但是整个的程序并没有使用 throws或者是明确的try..catch处理，因为该异常一定是 RuntimeException的子类，每一个线程类的对象只允许启动一次，如如果重复启动则就抛出此异常。 例如：下面的代码就会抛出异常。 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(\"线程A\"); mt.start(); mt.start(); &#125; &#125; 异常Exception in thread \"main\" java.lang.IllegalThreadStateExcepton 在Java程序执行的过程之中考虑到对于不同层次开发者的需求，所以其支持有本地的操作系统函数调用，而这项技术就被称为JNI( Java Native Inteface)技术，但是Java开发过程之中并不推荐这样使用，利用这项技术可以使用一些操作系统提供的底层函数进行一些特殊的处理，而在Thread类里面提供的 start00就表示需要将此方法依赖于不同的操作系统实现。 任何情况下，只要定义了多线程，多线程的启动永远只有一种方案： Thread类中的 start方法 ✦通过 Runnable 接口实现虽然可以通过Thread类的继承来实现多线程的定义，但是在Java程序里面对于继承永远都是存在有单继承局限的，所以在Java里面又提供有第二种多线程的主体定义结构形式：实现 java.lang.Runnable接口，此接口定义如下： /SourceCode@FunctionalInterface //从JDK1.8引入了Lambda表达式之后就变为了函数式接口 public interface Runnable &#123; public void run(); &#125; 创建线程的主体类范例：通过 Runnable实现多线程的主体类 /ThreadDemo.javaclass MyThread implements Runnable &#123; //线程的主体类 private String title; public MyThread(String title) &#123; this.title = title; &#125; @Override public void run() &#123; //线程的主体方法 //IntStream.range(0, 6).mapToObj(x -> this.title + \"运行，x=\" + x).forEach(System.out::println); for (int x = 0; x &lt; 6; x++) &#123; System.out.println(this.title + \"运行，x=\" + x); &#125; &#125; &#125; 但是此时由于不再继承Thread父类了，那么对于此时的MyThread类中也就不再支持有start()这个继承的方法，可是如果不使用Thread.start()方法是无法进行多线程启动的，那么这个时候需要观察Thread类所提供的构造方法： 构造方法：public Thread(Runnable target); 启动多线程范例：启动多线程 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread threadA = new Thread(new MyThread(\"线程A\")); Thread threadB = new Thread(new MyThread(\"线程B\")); Thread threadC = new Thread(new MyThread(\"线程C\")); threadA.start(); threadB.start(); threadC.start(); &#125; &#125; 这个时候的多线程实现里面可以发现，由于只是实现了 Runnable接口对象，所以此时线程主体类上就不再有单继承局限了，那么这样的设计才是一个标准型的设计。 可以发现从JDK1.8开始， Runnable接口使用了函数式接口定义，所以也可以直接利用 Lambda表达式进行线程类实现。 范例：利用 Lambda实现多线程定义 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; for (int x = 0; x &lt; 2; x++) &#123; String title = \"线程对象_\" + x; Runnable run = () -> &#123; for (int y = 0; y &lt; 6; y++) System.out.println(title + \"运行，y=\" + y); &#125;; new Thread(run).start(); &#125; &#125; &#125; 改进版： /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; for (int x = 0; x &lt; 2; x++) &#123; String title = \"线程对象_\" + x; new Thread(() -> &#123; for (int y = 0; y &lt; 6; y++) System.out.println(title + \"运行，y=\" + y); &#125;).start(); &#125; &#125; &#125; 在以后的开发之中对于多线程的实现，优先考虑的就是Runnable接口实现，并且永恒都是通过Thread类对象启动多线程。 ✦Thread与 Runnable关系经过一系列的分析之后可以发现，在多线程的实现过程之中已经有了两种做法：Thread类、Runnable接口，如果从代码的结构本身来讲肯定使用Runnable是最方便的，因为其可以避免单继承的局限，同时也可以更好的进行功能的扩充。 但是从结构上也需要来观察Thread与Runnable的联系，Thread类的定义： /SourceCodepublic class Thread extends Object implements Runnable &#123;&#125; 发现现在Thread类也是Runnable接口的子类，那么在之前继承 Thread类的时候实际上覆写的还是Runnable接口的run()方法，于是此时来观察一下程序的类结构。 /ThreadDemo.javaimport java.util.stream.IntStream; class MyThread implements Runnable &#123; //线程的主体类 private String title; public MyThread(String title) &#123; this.title = title; &#125; @Override public void run() &#123; //线程的主体方法 //IntStream.range(0, 6).mapToObj(x -> this.title + \"运行，x=\" + x).forEach(System.out::println); for (int x = 0; x &lt; 6; x++) &#123; System.out.println(this.title + \"运行，x=\" + x); &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread threadA = new Thread(new MyThread(\"线程A\")); Thread threadB = new Thread(new MyThread(\"线程B\")); Thread threadC = new Thread(new MyThread(\"线程C\")); threadA.start(); threadB.start(); threadC.start(); &#125; &#125; 多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交由 Thread类来处理。 在进行 Thread启动多线程的时候调用的是start()方法，而后找到的是run()方法，但通过 Thread类的构造方法传递了一Runnable接口对象的时候，那么该接口对象将被Thread类中的 target()属性所保存，在start()方法执行的时候会调用Thread类中的run()方法，而这个run()方法去调用Runnable接口子类被覆写过的run()方法。 多线程开发的本质实质上是在于多个线程可以进行同一资源的抢占，那么Thread主要描述的是线程，而资源的描述是通过Runnable完成的。 范例：利用卖票程序来实现多个线程的资源并发访问 /ThreadDemo.javaimport java.util.stream.IntStream; class MyThread implements Runnable &#123; //线程的主体类 private int ticket = 5; @Override public void run() &#123; //线程的主体方法 //IntStream.range(0, 6).mapToObj(x -> this.title + \"运行，x=\" + x).forEach(System.out::println); for (int x = 0; x &lt; 100; x++) &#123; if (this.ticket > 0) &#123; System.out.println(\"买票，ticket = \" + this.ticket--); &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt).start(); //第一个线程启动 new Thread(mt).start(); //第二个线程启动 new Thread(mt).start(); //第三个线程启动 &#125; &#125; 通过内存分析图来分析本程序的执行结构： ✧通过Callable接口实现从最传统的开发来讲如果要进行多线程的实现肯定依靠的就是Runnable,但是Runnable接口有一个缺点：当线程执行完毕之后无法获取一个返回值，所以从JDK1.5之后就提出了个新的线程实现接口：javautil.concurrent.Callable接口，首先来观察这个接口的定义： SourceCode@Functionalinterface public interface Callable&lt;V> &#123; public V call() throws Exception; &#125; 可以发现Callable定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的好处是可以避免向下转型所带来的安全隐患。 创建线程的主体类范例：使用Callable实现多线程处理 /ThreadDemo.javaimport java.util.concurrent.Callable; import java.util.concurrent.FutureTask; class MyThread implements Callable&lt;String> &#123; //线程的主体类 @Override public String call() throws Exception &#123; for (int x = 0; x &lt; 10; x++) &#123; System.out.println(\"_____ 线程执行 __ x = \" + x + \"_____\"); &#125; return \"线程执行完毕。\"; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String> task = new FutureTask&lt;>(new MyThread()); new Thread(task).start(); System.out.println(\"【线程返回数据】\" + task.get()); &#125; &#125; 面试题：请解释Runnable与Callable的区别？ Runnable是在JDK1.0的时候提出的多线程的实现接口，而Callable是在JDK1.5之后提出的 java.lang.Runnable接口之中只提供有一个run()方法，并且没有返回值 java.util.concurrent.Callable接口提供有call()方法，可以有返回值 线程运行状态对于多线程的开发而言，编写程序的过程之中总是按照：定义线程主体类，而后通过Thread类进行线程的启动，但是并不意味着你调用了start()方法，线程就已经开始运行了，因为整体的线程处理有自己的一套运行的状态。 任何一个线程的对象都应该使用Thread类进行封装，所以线程的启动使用的是start()，但是启动的时候实际上若干个线程都将进入到一种就绪状态，现在并没有执行； 进入到就绪状态之后就需要等待进行资源调度，当某一个线程调度成功之后则进入到运行状态（run()方法），但是所有的线程不可能一致持续执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源，而后这个线程就将进入到阻塞状态，随后重新回归到就绪状态； 当run()方法执行完毕之后，实际上该线程的主要任务也就结東了，那么此时就可以直接进入到停止状态； 线程常用操作方法多线程的主要操作方法都在 Thread类中定义了。 ✦线程的命名和取得多线程的运行状态是不确定的，那么在程序的开发之中为了可以获取到一些需要使用到线程就只能够依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在 Thread类之中就提供有线程名称的处理： 构造方法：public Thread(Runnable target, String name); 设置名字：public final String setName(); 取得名字：public final String getName(); 对于线程对象的获得是不可能只是依靠一个this来完成的，因为线程的状态不可控，但是有一点是明确的，所有的线程对象定要执行run()方法，那么这个时候可以考虑获取当前线程，在Thread类里面提供有获取当前线程的方法: 获取当前线程：public static Thread currentThread() 范例：观察线程的命名操作 /ThreadDemo.javaclass MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; MyThread mt = new MyThread(); new Thread(mt, \"线程A\").start(); //设置了线程名字 new Thread(mt).start(); //未设置 new Thread(mt).start(); //未设置 new Thread(mt).start(); //未设置 new Thread(mt, \"线程B\").start(); //设置了线程名字 &#125; &#125; 当开发者为线程设置名字的时候就使用设置的名字，而如果没有设置名字，则会自动生成一个不重复的名字，这种自动的属性命名主要是依靠了 static属性完成的，在 Thread类里面定义有如下操作： SourceCodeprivate static int threadInitNumber; private static synchronized int nextThreadNum() &#123; return threadInitNumber++; &#125; 范例：观察一个程序 /ThreadDemo.javaclass MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; MyThread mt = new MyThread(); new Thread(mt, \"线程对象\").start(); //设置了线程名字 mt.run(); //对象直接调用run()方法 &#125; &#125; 通过此时的代码可以发现当使用了mt.run()直接在主方法之中调用线程类对象中的run()方法所获得的线程对象的名字为“main”，所以可以得出一个结论：主方法也是一个线程。 所有的线程都是在进程上的划分，那么进程在哪里？ 每当使用java命令执行程序的时候就表示启动了一个JVM的进程，一台电脑可以同时启动若干个JVM进程，所以每一个JVM进程都会有各自的线程。 在任何的开发之中，主线程可以创建若干个子线程，创建子线程的目的是可以将一些复杂逻辑或者比较耗时的逻辑交由子线程处理； 范例：子线程处理/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"执行操作任务1\"); System.out.println(\"执行操作任务2\"); - int temp = 0; - for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123; - temp += x; - &#125; + new Thread(() -> &#123; + int temp = 0; + for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123; + temp += x; + &#125; &#125;); System.out.println(\"执行操作任务3\"); System.out.println(\"执行操作任务4\"); &#125; &#125; 主线程负责处理整体流程，而子线程负责处理耗时操作。 ✦线程休眠如果说现在希望某一个线程可以暂缓执行一次，那么就可以使用休眠的处理，在 Thread类之中定义的休眠方法如下： 休眠：public static void sleep(long millis) throws InterruptedException 休眠：public static void sleep(long millis, int nanos) throws InterruptedException 在进行休眠的时候有可能会产生中断异常InterruptedException，中断异常属于Exception的子类，所以证明该异常必须进行处理。 范例：观察休眠处理/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; new Thread(() -> &#123; for (int x = 0; x &lt; 10; x++) &#123; try &#123; Thread.sleep(100); //暂缓执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" _ x = \" + x); &#125; &#125;, \"线程对象\").start(); &#125; &#125; 休眠的主要特点是可以自动实现线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在有多个线程对象，那么休眠也是有先后顺序的。 范例：产生多个线程对象进行休眠处理/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; for (int m = 0; m &lt; 5; m++) &#123; new Thread(() -> &#123; for (int x = 0; x &lt; 10; x++) &#123; try &#123; Thread.sleep(100); //暂缓执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" _ x = \" + x); &#125; &#125;, \"线程对象 - \" + m).start(); &#125; &#125; &#125; 代码清晰化 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Runnable run = () -> &#123; for (int x = 0; x &lt; 10; x++) &#123; try &#123; Thread.sleep(100); //暂缓执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" _ x = \" + x); &#125; &#125;; for (int m = 0; m &lt; 5; m++) &#123; new Thread(run, \"线程对象 - \" + m).start(); &#125; &#125; &#125; 此时将产生五个线程对象，并且这五个线程对象执行的方法体是相同的。 线程中断在之前发现线程的休眠里面提供有一个中断异常，实际上就证明线程的休眠是可以被打断的，而这种打断肯定是由其它线程完成的在 Thread类里面提供有这种中断执行的处理方法： 判断线程是否被中断：public boolean isInterrupted() 中断线程执行：public void interrupt() 范例：观察线程的中断处理操作/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread thread = new Thread(()->&#123; System.out.println(\"*** 72个小时的疯狂我需要睡觉补充精力 ***\"); try &#123; Thread.sleep(10000); //预计准备休眠10秒 System.out.println(\"*** 睡足了，可以出去继续祸害别人了 ***\"); &#125; catch (InterruptedException e) &#123; System.out.println(\"*** 敢打扰我睡觉，老子宰了你 ***\"); &#125; &#125;); thread.start(); //开始睡觉 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (!thread.isInterrupted()) &#123; //该线程中断了吗？ System.out.println(\"*** 我偷偷打扰一下你的睡眠 ***\"); thread.interrupt(); //中断执行 &#125; &#125; &#125; 所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理。 线程强制运行所谓的线程的强制执行指的是当满足于某些条件之后，某一个线程对象将可以一直独占资源，直到该线程的程序执行结束。 范例：观察一个没有强制执行的程序/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread thread = new Thread(() -> &#123; for (int i = 0; i &lt; 101; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"执行 __ number = \" + i); &#125; &#125;, \"玩耍的线程\"); thread.start(); for (int i = 0; i &lt; 101; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"【霸道的main线程】number = \" + i); &#125; &#125; &#125; 这个时候主线程和子线程都在交替执行着，但是如果说现在你希望主线程独占执行。那么就可以利用 Thread类中的方法： 强制执行： public final void join() throws InterruptedException; /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread mainThread = Thread.currentThread(); //获得主线程 Thread thread = new Thread(() -> &#123; for (int i = 0; i &lt; 101; i++) &#123; if (i == 3) &#123; //【霸道的线程】来了 try &#123; mainThread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"执行 __ number = \" + i); &#125; &#125;, \"玩耍的线程\"); thread.start(); for (int i = 0; i &lt; 101; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"【霸道的main线程】number = \" + i); &#125; &#125; &#125; 在进行线程强制执行的时候一定要获取强制执行线程对象之后才可以执行join()调用。 线程礼让线程的礼让指的是先将资源让出去让别的线程先执行。线程的礼让可以使用Thread类中提供的方法： 礼让：public static void yield() 范例：使用礼让操作/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread mainThread = Thread.currentThread(); //获得主线程 Thread thread = new Thread(() -> &#123; for (int i = 0; i &lt; 11; i++) &#123; if (i % 2 == 0) &#123; //线程礼让 Thread.yield(); System.out.println('\\n' + \"*** 线程礼让执行 ***\"); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"执行 __ number = \" + i); &#125; &#125;, \"线程\"); thread.start(); for (int i = 0; i &lt; 11; i++) &#123; if (i % 2 != 0) &#123; //线程礼让 Thread.yield(); System.out.println('\\n' + \"*** 【main线程】礼让执行 ***\"); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"【main线程】number = \" + i); &#125; &#125; &#125; 礼让执行的时候每一次调用yield()方法都只会礼让一次当前的资源。 ✦线程优先级从理论上来讲线程的优先级越高越有可能先执行（越有可能先抢占到资源）。在 Thread类里面针对于优先级的操作提供有如下的两个处理方法： 设置优先级： public final void setPriority(int newPriority) 获取优先级： public final int getPriority() 在进行优先级定义的时候都是通过int型的数字来完成的，而对于此数字的选择在Thread类里面就定义有三个常量： 最高优先级（10）：public static final int MAX_PRIORITY; 中等优先级（5）：public static final int NORM_PRIORITY; 最低优先级（1）：public static final int MIN_PRIORITY; 范例：优先级/ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Runnable run = (() -> &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"执行\"); &#125; &#125;); Thread threadA = new Thread(run, \"线程对象A\"); Thread threadB = new Thread(run, \"线程对象B\"); Thread threadC = new Thread(run, \"线程对象C\"); threadA.setPriority(Thread.MIN_PRIORITY); threadB.setPriority(Thread.MIN_PRIORITY); threadC.setPriority(Thread.MAX_PRIORITY); threadA.start(); threadB.start(); threadC.start(); &#125; &#125; 主方法和默认线程也是一个主线程，那么他们的优先级呢？ /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; System.out.println(new Thread().getPriority()); System.out.println(Thread.currentThread().getPriority()); &#125; &#125; 主线程是属于中等优先级，而默认创建的线程也是中等优先级。 线程的同步与死锁在多线程的处理之中，可以利用Runnable描述多个线程操作的资源，而Thread描述每一个线程对象，于是当多个线程访问同一资源的时候如果处理不当就会产生数据的错误操作。 线程同步下面编写一个简单的卖票程序，将创建若干个线程对象实现卖票的处理操作 范例：实现卖票操作（问题引出）/ThreadDemo.javaclass MyThread implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; while (true) &#123; if (this.ticket > 0) &#123; System.out.println(Thread.currentThread().getName() + \"买票， ticket = \" + this.ticket--); &#125; else &#123; System.out.println(\"**** 票已抢光 ****\"); break; &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt, \"票贩子A\").start(); new Thread(mt, \"票贩子B\").start(); new Thread(mt, \"票贩子C\").start(); &#125; &#125; 此时的程序将创建三个线程对象，并且这三个线程对象将进行5张票的出售。此时的程序在进行卖票处理的时候并没有任何的问题（假象），下面可以模拟一下卖票中的延迟操作。 /ThreadDemo.javaclass MyThread implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; while (true) &#123; if (this.ticket > 0) &#123; try &#123; Thread.sleep(100); //模拟网络延迟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"买票， ticket = \" + this.ticket--); &#125; else &#123; System.out.println(\"**** 票已抢光 ****\"); break; &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt, \"票贩子A\").start(); new Thread(mt, \"票贩子B\").start(); new Thread(mt, \"票贩子C\").start(); &#125; &#125; 经过分析之后己经可以确认同步问题所产生的主要原因了，那么下面就需要进行同步问题的解决，但是解决同步问题的关键是锁，指的是当某一个线程执行操作的时候，其它线程外面等待。 如果要想在程序之中实现这把锁的功能，就可以使用synchronized关键字米实现，利用此关键字可以定义同步方法或同步代码块，在同步代码块的操作里面的代码只允许一个线程执行。 利用同步代码块进行处理：Logicsynchronized(同步对象) &#123; 同步代码操作 &#125; 一般要进行同步对象处理的时候可以采用当前对象this进行同步。 范例：利用同步代码块解决数据同步访问问题 /ThreadDemo.javaclass MyThread implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; while (true) &#123; synchronized (this) &#123; if (this.ticket > 0) &#123; try &#123; Thread.sleep(100); //模拟网络延迟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"买票， ticket = \" + this.ticket--); &#125; else &#123; System.out.println(\"**** 票已抢光 ****\"); break; &#125; &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt, \"票贩子A\").start(); new Thread(mt, \"票贩子B\").start(); new Thread(mt, \"票贩子C\").start(); &#125; &#125; 加入同步处理之后，程序的整体的性能下降了。同步实际上会造成性能的降低。 ✦利用同步方法解决只需要在方法定义上使用synchronized关键字即可。 /ThreadDemo.javaclass MyThread implements Runnable &#123; private int ticket = 10; public synchronized boolean sale() &#123; if (this.ticket > 0) &#123; try &#123; Thread.sleep(100); //模拟网络延迟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"买票， ticket = \" + this.ticket--); return true; &#125; else &#123; System.out.println(\"**** 票已抢光 ****\"); return false; &#125; &#125; @Override public void run() &#123; while (this.sale()) &#123; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt, \"票贩子A\").start(); new Thread(mt, \"票贩子B\").start(); new Thread(mt, \"票贩子C\").start(); &#125; &#125; 在日后学习Java类库的时候会发现，系统中许多的类上使用的同步处理采用的都是同步方法。 线程死锁 死锁是在进行多线程同步的处理之中有可能产生的一种问题，所谓的死锁指的是若干个线程彼此互相等待的状态。下面通过一个简单的代码来观察一下死锁的表现形式，但是对于此代码不作为重点。 /ThreadDemo.javaclass Person1 &#123; public synchronized void say(Person2 Per2) &#123; System.out.println(\"交钱！\"); Per2.get(); &#125; public synchronized void get() &#123; System.out.println(\"好的\"); &#125; &#125; class Person2 &#123; public synchronized void say(Person1 Per1) &#123; System.out.println(\"不给！！\"); Per1.get(); &#125; public synchronized void get() &#123; System.out.println(\"给你\"); &#125; &#125; public class ThreadDemo implements Runnable &#123; private Person1 Per1 = new Person1(); private Person2 Per2 = new Person2(); public ThreadDemo() &#123; new Thread(this).start(); Per1.say(Per2); &#125; public static void main(String[] args) &#123; new ThreadDemo(); &#125; @Override public void run() &#123; Per2.say(Per1); &#125; &#125; 现在死锁造成的主要原因是因为彼此都在互相等待着，等待着对方先让出资源。死锁实际上是一种开发中出现的不确定的状态，有的时候代码如果处理不当则会不定期出现死锁，这是属于正常开发中的调试问题。 若干个线程访问同一资源时一定要进行同步处理，而过多的同步会造成死锁。 实例生产者与消费者基本程序模型在多线程的开发过程之中最为著名的案例就是生产者与消费者操作，该操作的主要流程如下 生产者负责信息内容的生产 每当生产者生产完成一项完整的信息之后消费者要从这里面取走信息 如果生产者没有生产者则消费者要等待它生产完成，如果消费者还没有对信息进行消费，则生产者应该等待消费处理完成后再继续生产。 程序基本实现：可以将生产者与消费者定义为两个独立的线程类对象。 数据一： title &#x3D; 王建、content &#x3D; 宇宙大帅哥 数据二： title &#x3D; 小高、content &#x3D; 猥琐第一人 既然生产者与消费者是两个独立的线程，那么这两个独立的线程之间就需要有一个数据的保存集中点，那么可以定义一个Messga类实现数据的保存。 /ThreadDemo.javaclass Producer implements Runnable &#123; private Message msg; public Producer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; this.msg.setTitle(\"Person1\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.msg.setContent(\"111\"); &#125; else &#123; this.msg.setTitle(\"Person2\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.msg.setContent(\"222\"); &#125; &#125; &#125; &#125; class Message &#123; private String title; private String content; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; &#125; class Consumer implements Runnable &#123; private Message msg; public Consumer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(this.msg.getTitle() + \" - \" + this.msg.getContent()); &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producer(msg)).start(); new Thread(new Consumer(msg)).start(); &#125; &#125; 通过整个代码的执行你会发现此时有两个主要问题： 问题一：数据不同步了 问题二：生产一个取走一个，但是发现有了重复生产和重复取出问题 解决同步问题如果要解决问题，首先解決的就是数据同步的处理问题，如果要想解决数据同步最简单的做法是使用synchronized关键字定义同步代码块或同步方法，于是这个时候对于同步的处理就可以直接在Message类中完成。 /ThreadDemo.javaclass Producer implements Runnable &#123; private Message msg; public Producer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; this.msg.set(\"Person1\", \"111\"); &#125; else &#123; this.msg.set(\"Person2\", \"222\"); &#125; &#125; &#125; &#125; class Message &#123; private String title; private String content; public synchronized void set(String title, String content) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.title = title; this.content = content; &#125; public synchronized String get() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return this.title + \" - \" + this.content; &#125; &#125; class Consumer implements Runnable &#123; private Message msg; public Consumer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(this.msg.get()); &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producer(msg)).start(); //启动生产者线程 new Thread(new Consumer(msg)).start(); //启动消费者线程 &#125; &#125; 在进行同步处理的时候肯定需要有一个同步的处理对象，那么此时肯定要将同步操作交由Message类处理是最合适的。这个时候发现数据已经可以正常的保持一致了，但是对于重复操作的问题依然存在。 ✦利用Object类解决重复操作如果说现在要想解决生产者与消费者的问题，那么最好的解决方案就是使用等待与唤醒机制。 主要依靠的是 Object类中提供的方法处理的： 等待机制： 死等：public final void wait() throws InterruptedException 设置等待时间：public final void wait(long timeout) throws InterruptedException 设置等待时间：public final void wait(long timeout, int nanos) throws InterruptedException 唤醒第一个等待线程：public final void notify() 唤醒全部等待线程：public final void notifyAll() 如果此时有若干个等待线程的话，那么notify()表示的是唤醒第一个等待的线程，而其它的线程继续等待，,而notifyAll()表示会唤醒所有等待的线程，那个线程的优先级高就有可能先执行。 对于当前的问题主要的解決应该通过Message类完成处理。 范例：修改Message类 /ThreadDemo.javaclass Producer implements Runnable &#123; private Message msg; public Producer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; this.msg.set(\"Person1\", \"111\"); &#125; else &#123; this.msg.set(\"Person2\", \"222\"); &#125; &#125; &#125; &#125; class Message &#123; private String title; private String content; + private boolean flag = true; //表示生产或消费的形式 + /* + flag=true，允许生产，但是不允许消费 + flag= false，允许消费，不允许生产 + */ public synchronized void set(String title, String content) &#123; + if (!this.flag) &#123; //无法进行生产，应该等待被消费 + try &#123; + super.wait(); + &#125; catch (InterruptedException e) &#123; + e.printStackTrace(); + &#125; + &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.title = title; this.content = content; + this.flag = false; //已经生产过了 + super.notify(); //唤酲等待的线程 &#125; public synchronized String get() &#123; + if (this.flag) &#123; //还未生产，需要等待 + try &#123; + super.wait(); + &#125; catch (InterruptedException e) &#123; + e.printStackTrace(); + &#125; + &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; + try &#123; return this.title + \" - \" + this.content; + &#125; finally &#123; + this.flag = true; + super.notify(); + &#125; &#125; &#125; class Consumer implements Runnable &#123; private Message msg; public Consumer(Message msg) &#123; this.msg = msg; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(this.msg.get()); &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Message msg = new Message(); new Thread(new Producer(msg)).start(); //启动生产者线程 new Thread(new Consumer(msg)).start(); //启动消费者线程 &#125; &#125; 这种处理形式就是在进行多线程开发过程之中最原始的处理方案，整个的等待、同步、唤醒机制都由开发者自行通过原生代码实现控制。 ✦多线程深入优雅的停止线程在多线程操作之中如果要启动多线程肯定使用的是Thread类中的 start()方法，而如果对于多线程需要进行停止处理，Thread类原本提供有stop()方法，但是对于这些方法从JDK1.2版本开始就已经将其废除了，而且一直到现在也不再建议出现在你的代码之中，而除了 stop()之外还有儿个方法也被禁用了 停止多线程： public void stop() 销毁多线程： public void destroy() 挂起线程： public final void suspend()、暂停执行； 恢复挂起的线程执行： public final void resume() 之所以废除掉这些方法，主要的原因是因为这些方法有可能导致线程的死锁，所以从JDK1.2开始就都不建议使用了，如果这个时候要想实现线程的停止需要通过一种柔和的方式来进行。 范例：实现线程柔和的停止 /ThreadDemo.javapublic class ThreadDemo &#123; public static boolean flag = true; public static void main(String[] args) &#123; new Thread(() -> &#123; long num = 0; while (flag) &#123; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在运行！_ num = \" + num++); &#125; &#125;, \"执行线程\").start(); try &#123; Thread.sleep(200); //运行200毫秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; flag = false; &#125; &#125; 万一现在有其它的线程去控制这个flag的内容，那么这个时候对于线程的停止也不是说停就立刻停止的，而是会在执行中判断flag的内容来判断。 后台守护线程现在假设有一个人并且这个人有一个保镖，那么这个保镖一定是在这个人活着的时候进行守护，如果这个人已经死了，保镖就没用，所以在多线程里面可以进行守护线程的定义，也就是说如果现在主线程的程序或者其它的线程还在执行的时候，那么守护线程将一直存在，并且运行在后台状态。 在 Thread类里面提供有如下的守护线程的操作方法： 设置为守护线程：public final void setDaemon(boolean on) 判断是否为守护线程：public final boolean isDaemon() 范例：使用守护线程。 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) &#123; Thread userThread = new Thread(() -> &#123; for (int x = 0; x &lt; 10; x++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在运行！_ x = \" + x); &#125; &#125;, \"用户线程\"); //完成核心的业务 Thread deamonThread = new Thread(() -> &#123; for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在运行！_ x = \" + x); &#125; &#125;, \"守护线程\"); deamonThread.setDaemon(true); //设置为守护线程 userThread.start(); deamonThread.start(); &#125; &#125; 可以发现所有的守护线程都是围绕在用户线程的周围，如果程序执行完毕，守护线程也就消失了，在整个的JVM里面最大的守护线程就是GC线程程序执行中GC线程会一直存在，如果程序执行完毕，GC线程也将消失。 volatile关键字在多线程的定义之中， volatile关键字主要是在属性定义上使用的，表示此属性为直接数据操作，而不进行副本的拷贝处理，这样的话在一些书上就将其错误的理解为同步属性了。 在正常进行变量处理的时候往往会经历如下的几个步骤： 获取变量原有的数据内容副木 利用副本为变量进行数学计算 将计算后的变量，保存到原始空间之中 而如果一个属性上追加了 volatile关键字，表示的就是不使用副本，而是直接操作，相当于节约了：拷贝副本、重新保存的时间 /ThreadDemo.javaclass MyThread implements Runnable &#123; private volatile int ticket = 10; @Override public void run() &#123; while (true) &#123; if (this.ticket > 0) &#123; try &#123; Thread.sleep(100); //模拟网络延迟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"买票， ticket = \" + this.ticket--); &#125; else &#123; System.out.println(\"**** 票已抢光 ****\"); break; &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); new Thread(mt, \"票贩子A\").start(); new Thread(mt, \"票贩子B\").start(); new Thread(mt, \"票贩子C\").start(); &#125; &#125; 面试题：请解释 volatile与 synchronized的区别？ volatile主要在属性上使用，面、”cd是在代码块与方法上使用的； volatile无法描述同步的处理，它只是一种直接内存的处理，避免了副本的操作，而 synchronized是实现同步的； 多线程综合案例数字加减设计4个线程对象，两个线程执行减操作，两个线程执行加操作。 /ThreadDemo.javaclass Resource &#123; //定义一个操作的资源 private int num = 0; //这个要进行加减操作的数据 private boolean flag = true; //加减的切换 //flag=true:表示可以进行加法操作，但是无法进行减法操作 //flag=false:表示可以进行碱法操作，但是无法进行加法操作 public synchronized void add() throws InterruptedException &#123; //加法 if (!this.flag) &#123; //现在需要执行的是减法操作，加法操作要等待 super.wait(); &#125; Thread.sleep(100); this.num++; System.out.println(\"【加法操作 - \" + Thread.currentThread().getName() + \"】 &amp; num = \" + this.num); this.flag = false; super.notifyAll(); //唤酲全部等待线程 &#125; public synchronized void sub() throws InterruptedException &#123; //减法 if (this.flag) &#123; //现在需要执行的是加法操作，减法操作要等待 super.wait(); &#125; Thread.sleep(200); this.num--; System.out.println(\"【减法操作 - \" + Thread.currentThread().getName() + \"】 &amp; num = \" + this.num); this.flag = true; super.notifyAll(); &#125; &#125; class AddThread implements Runnable &#123; private Resource resource; public AddThread(Resource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; try &#123; this.resource.add(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; class SubThread implements Runnable &#123; private Resource resource; public SubThread(Resource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 50; i++) &#123; try &#123; this.resource.sub(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Resource res = new Resource(); SubThread st = new SubThread(res); AddThread at = new AddThread(res); new Thread(at, \"加法线程 - A\").start(); new Thread(at, \"加法线程 - B\").start(); new Thread(st, \"减法线程 - X\").start(); new Thread(st, \"减法线程 - Y\").start(); &#125; &#125; 这是一个经典的多线程开发操作，这一个程序里面一定要考虑的核心本质在于：加一个、减一个，整体的计算结果应该在0、-1、1 中循环出现才是合理的。 生产电脑设计一个生产电脑和搬运电脑类，要求生产出一台电脑就搬走一台电脑，如果没有新的电脑生产出来，则搬运工要等待新电脑产出：如果生产出的电脑没有搬走，则要等待电脑搬走之后再生产，并统计出生产的电脑数量。 在本程序中，就是一个标准的生产者与消费者的处理模型，那么下面实现具体的程序代码。 /ThreadDemo.javapublic class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; Resource res = new Resource() ; new Thread(new Producer(res)).start() ; new Thread(new Consumer(res)).start() ; new Thread(st).start() ; new Thread(st).start() ; &#125; &#125; class Producer implements Runnable &#123; private Resource resource ; public Producer(Resource resource) &#123; this.resource = resource ; &#125; @Override public void run() &#123; for (int x = 0; x &lt; 50; x++) &#123; try &#123; this.resource.make() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; &#125; &#125; &#125; &#125; class Consumer implements Runnable &#123; private Resource resource ; public Consumer(Resource resource) &#123; this.resource = resource ; &#125; @Override public void run() &#123; for (int x = 0 ; x &lt; 50 ; x++) &#123; try &#123; this.resource.get() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; &#125; &#125; &#125; &#125; class Resource &#123; private Computer computer ; private boolean flag = true ; //标记 public synchronized void make() throws Exception &#123; if (this.computer != null) &#123; //已经生产过了 super.wait() ; &#125; Thread.sleep(100) ; this.computer = new Computer(\"MLDN牌电脑\", 1.1) ; System.out.println(\"【生产电脑】\"+ this.computer) ; super.notifyAll() ; &#125; public synchronized void get() throws Exception &#123; if (this.computer == null) &#123; //没有生产过 super.wait() ; &#125; Thread.sleep(10) ; System.out.println(\"【取走电脑】\"+ this.computer) ; this.computer = null ; //已经取走了 super.notifyAll() ; &#125; &#125; class Computer &#123; private static int count = 0 ; //表示生产的个数 private String name ; private double price ; public Computer(String name, double price) &#123; this.name = name ; this.price = price ; count++ ; &#125; public String toString() &#123; return \"【第\" + count + \"台电脑】电脑名字：\" + this.name + \"价值:\" + this.price ; &#125; &#125; 竞争抢答实现一个竞拍抢答程序：要求设置三个抢答者（三个线程），而后同时发出抢答指令，抢答成功者给出成功提示，未抢答成功者给出失败提示。 对于这个多线程操作，由于里面需要牵扯到数据返回问题，那么现在最好使用Callable是比较方便的一种处理形式。 import java.util.concurrent.Callable; import java.util.concurrent.FutureTask; public class ThreadDemo &#123; public static void main(String[] args) throws Exception &#123; MyThread mt &#x3D; new MyThread(); FutureTask&lt;String&gt; taskA &#x3D; new FutureTask(mt); FutureTask&lt;String&gt; taskB &#x3D; new FutureTask(mt); FutureTask&lt;String&gt; taskC &#x3D; new FutureTask(mt); new Thread(taskA, &quot;竞赛者A&quot;).start(); new Thread(taskB, &quot;竞赛者B&quot;).start(); new Thread(taskC, &quot;竞赛者C&quot;).start(); System.out.println(taskA.get()); System.out.println(taskB.get()); System.out.println(taskC.get()); &#125; &#125; class MyThread implements Callable&lt;String&gt; &#123; private boolean flag &#x3D; false; &#x2F;&#x2F;抢到处理 @Override public String call() throws Exception &#123; synchronized (this) &#123; &#x2F;&#x2F;数据同步 if (this.flag &#x3D;&#x3D; false) &#123; &#x2F;&#x2F;抢答成功 this.flag &#x3D; true; return Thread.currentThread().getName() + &quot;抢答成功!&quot;; &#125; else &#123; return Thread.currentThread().getName() + &quot;抢答失败!&quot;; &#125; &#125; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"thread","slug":"java/thread","permalink":"https://blog.newimg.ltd/categories/java/thread/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Java环境配置","slug":"Java环境配置","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Java环境配置/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"[^1]:Windows10 20H2 及 Java 11.0.9亲测成功","text":"[^1]:Windows10 20H2 及 Java 11.0.9亲测成功 准备工作选择需要的版本并下载JDK（JDK的相关介绍），网站比较慢，做好等待的准备。 开始配置环境变量右键此电脑 → 属性 → 高级系统设置（或按下Windows + S，搜索编辑系统环境变量）出现下图 按照上图所示，单击环境变量，出现下图 配置Java_Home 建议 Java_Home 改为 JAVA_HOME ，方便后期其余软件使用 按照上图所示，单击新建，按照下图输入红框内信息。 JAVA_HOME //安装Java的路径及版本 例：C:\\Program Files\\Java\\jdk-11.0.9 出现下图 配置Path 按照上图所示，单击Path → 单击编辑出现下图 按照上图所示，分别单击新建，加入绿框内两项。 %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 后单击确定 配置CLASSPATH 配置CLASSPATH按照上图所示，单击新建，按照下图输入红框内信息。 CLASSPATH .;%JAVA_HOME%\\bin;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 后单击确定。 检查Java配置情况Windows + R → 输入cmd后确定利用以下三条命令确认是否配置完毕。 java javac java -version 以java -version为例，出现下图即配置成功。 Java开发利用以下命令开发（如果你懒得再配置IDE） //利用cd命令进入目录省略 //example为编写好的java源代码文件 javac example.java java example","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"environment","slug":"java/environment","permalink":"https://blog.newimg.ltd/categories/java/environment/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Linux运维-计算机基础","slug":"Linux运维-计算机基础","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Linux运维-计算机基础/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Linux%E8%BF%90%E7%BB%B4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","excerpt":"链接","text":"链接 计算机系统计算机硬件组成操作系统Linux相关介绍Linux哲学思想获取Linux虚拟机 计算机基础计算机硬件计算机能接受、存储、处理和输出数据 硬件： CPU ROM、RAM 外部设备软件： 系统软件（操作系统、程序语言处理系统、数据库管理系统、服务程序）应用软件（通用&#x2F;专用应用软件） 按规模： 巨&#x2F;大&#x2F;小&#x2F;微型计算机 发展历史电子管时代晶体管时代集成电路时代大规模集成电路时代 冯诺依曼体系结构 &#x3D;&#x3D;熟练掌握进制转换方法&#x3D;&#x3D; &#x2F;&#x2F;Linux（计算器） $ bc obase &#x3D; 2 &#x2F;&#x2F;输出的进制 &#x2F;&#x2F;ibase &#x3D; 10 97 1100001 quit 服务器服务器Serνer是计算机的—种，是网络中&#x3D;&#x3D;为客户端计算机提供各种服务&#x3D;&#x3D;的高性能的计算机，服务器在网络操作系统的控制下，将与其相连的硬盘、磁带、打印机及昂贵的专用通讯设备提供给网络上的客户站点共享，也能为网络用户提供&#x3D;&#x3D;集中计算、信息发布及数据管理&#x3D;&#x3D;等服务 服务器按应用功能可分为： Web服务器、数据库服务器、文件服务器、中间件应用服务器、日志服务器、监控服务器，程序版本控制服务器、虚拟机服务器、邮件服务器、打印服务器、域控制服务器、多媒体服务器、通讯服务器、ERP服务器等服务器 按外形分类：&#x3D;&#x3D;机架式&#x3D;&#x3D;服务器、塔式服务器、刀片式服务器 去IOE（IBM、Oracle、EMC） NFS、SAMBA、FTP、TOMCAT、RSYSLOG、ZABBIX、GIT、KV、DOCKER、K8S、SENDMAIL、DC(DOMAIN CONTROLLER) 计算机硬件CPU主频∶ 主频是CPU的时钟频率（ CPU Clock speed），是CPU运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是Hz。一般说来，主频越高，CPU的速度越快，由于內部结构不同，并非所有的时钟频率相同的￠P∪的性能都一样 外频： 系统总线的工作频率，CPU与外部（主板芯片组）交换数据、指令的工作时钟频率 倍频： 倍频则是指CPU外频与主频相差的倍数三者关系是：主频 &#x3D; 外频 × 倍频 高速缓存（cache）： 高速交换的存储器。CPU缓存分为一级，二级，三级缓存，即L1、L2、L3内存 总线速度 （Memory- Bus Speed）： 一般等同于CPU的外频，指CPU与二级（L2）高速缓存和内存之间的通信速度 地址总线宽度决定了CPU可以访问的物理地址空间（现一般为&#x3D;&#x3D;64位&#x3D;&#x3D;） &#x2F;&#x2F;Linux查看CPU参数 $ lscpu 从CPU体系架构区分服务器：&#x3D;&#x3D;非x86&#x3D;&#x3D;服务器： 使用RISC（精简指令集）或EPIC（并行指令代码）处理器，并且主要采用UNIX和其它专用操作系统的服务器，指令系统相对简单，它只要求硬件执行很有限且最常用的那部分执令，CPU主要有 Compaq的Alpha、HP的PA-RISC、IBM的 IPower Pc、MIPS的MPS和SUN的 spare、Intel研发的EPIC安腾处理器等。这种服务器价格昂贵，体系封闭，但是稳定性好，性能强，主要用在金融、电信等大型企业的核心系统。&#x3D;&#x3D;x86&#x3D;&#x3D;服务器： 又称csSC（复杂指令集）架构服务器，即通常所讲的PC服务器它是基于PC机体系结构，使用nte或其它兼容ⅹ86指令集的处理器芯片的服务噩。目前主要为intel的Xeon E3，E5，E7系列，价格相对便宜、兼容性好、稳定性较差、安全性不算太高。 内存容量： 即该内存的存储容量，单位一般为”MB”或”GB” 内存带宽： 内存带宽是指内存与北桥芯片之间的数据传输率 单通道内存节制器一般都是64-bi的，8个二进制位相当于1个字节，换算成字节是64&#x2F;8&#x3D;8，再乘以内存的运行频率，如果是DDR内存就要再乘以2 计算公式： 内存带宽&#x3D;内存总线频率×数据总线位数&#x2F;8 数据存储单位转换 硬盘机械硬盘存储介质-&#x3D;&#x3D;盘片&#x3D;&#x3D;： 盘片的基板是金属或玻璃材质制成，为达到高空度高稳定的质量，基板要求表面光滑平整，不可有任何暇疵读写头-&#x3D;&#x3D;磁头&#x3D;&#x3D;： 磁头是硬盘读取数据的关键部件，它的主要作用就是将存储在硬盘盘片上的磁信息转化为电信号向外传输马达： 马达上装有一至多片盘片，以7200、10000、15000RM等定速旋转，为保持其平衡不可抖动，所以其质量要求严谨，不产生高温躁音 硬盘基本参数容量 容量是硬盘最主要的参数。单位有MB、GB、TB转速 转速是指硬盘盘片每分钟转动的圈数，单位为rpm。现在硬盘的转速已经达到10000rpm，15000rpm传输速率 传输速率（ Data transfer rate）。硬盘的数据传输率是指硬盘读写数据的速度，单位为兆字节每秒（MB&#x2F;s）缓存 硬盘缓存的目的是为了解决系统前后级读写速度不匹配的问题，以提高硬盘的读写速度接口类型 IDE接口：硬盘接口规范，采用ATA技术规范 SCSI接口：应用于小型机上的高速数据传输技术 SATA接口：提高传输速率，支持热插拔 SAS接口：兼容SATA目前主流的硬盘接口为SATA和SAS接口 SSD硬盘SSD泛指使用 NAND Flash组成的固态硬盘。基特别之处在于没有机械结构，以区块写入和抹除的方式作读写的功能，因此在读写的效率上，非常依赖读写技术上的设计SSD读写存取速度快，性能稳定，防震性高，发热低，耐低温，电耗低，无噪音。因为没有机械部分所以长时使用也出现故障几率也较小。缺点：价格高，容量小，在普通硬盘前毫无性价比优势。 阵列卡Raid卡： 用来实现RAID的建立和重建，检测和修复多位错淏，错误磁盘自动检测等功能。RAID芯片使CPU的资源得以释放阵列卡（RAID卡）的作用 阵列卡把若干硬盘驱动器按照一定要求组成个整体、由阵列控制器管理的系统。 阵列卡用来提高磁盘子系统的性能及可靠性阵列卡参数 支持的RAID级别 阵列卡缓存 电池保护 电源电源和风扇 支持服务器的电力负载支持冗余，防止电源故障 故障预警和防止 故障之前的预防性维护 保证服务器持续运行电源子系统包括 智能电源和风扇冗余电源和风扇 热插拔技术称为热交换技术，允许在不关机的状态下更换故障热插拔设备常见的热插拔设备：硬盘，电源，PCI设备，风扇等热插拔硬盘技术与RAID技术配合起来，可以使服务器在不关机的状态下恢复故障硬盘上的数据，同时并不影响网络用户对数据的使用 机柜机架式服务器-服务错放置在机柜中通常使用的机柜是42U（约2米高）机柜（1U&#x3D;44.45mm）外观尺寸一般为：宽600深1000高2000（mm） 存储网络用于存放数据信息的设备和介质，是计算机系统的外部存储，数据可安全存放，长期驻留 传统的存储（略）磁盘阵列（略）储存网络： DAS–直接连接存储 NAS–网络连接存储 SAN–存储区域网络 存储区域网络 利用高速的光纤网络链接服务器与存储设备，基于SCSI,IP,ATM等多种高级协议，实现存储共享 服务器跟储存装置两者各司其职利用光纤信道来传输数据，以达到一个服务器与储存裝置之间多对多的高效能、高稳定度的存储环境实施复杂，管理成本高 DAS NAS SAN 传输类型 SCs、FC IP IP、FC、sAS 数据类型 数据块文件数据块 典型应用 任何 文件服务器 数据库应用 优点 磁盘与服务器分离，便于统一管理 不占用应用服务器资源，广泛支持操作系统，扩展较容易，即插即用、安装简单方便 高扩展性，高可用性，数据集中、易管理 缺点 连接距离短，数据分散，共享困难，存储仝间利用率不高，扩展性有限 不适合存储量大的块级应用，数据备份及恢复占用网络带宽 相比NAS成本较，高安装和升级比NAS复杂 计算机软件操作系统OS:通用目的的软件程序 硬件驱动 进程管理 内存管理 网络管理 安全管理 文件管理OS分类： 服务器OS:RHEL, Centos, windows server, AIX; 桌面OS:Windows10, Windows7,Mac OS, Fedora; 移动设备OS:Andriod, ios, YunOs; 开发接口标准ABI ABI描述了应用程序与OS之间的底层接口允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行oAPI 定义了源代码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译POSIX IEEE在操作系统上定义的一系列AP标准 POSIX兼容的程序可在其它POSIX操作系统编译执行运行程序格式： Windows:EXE,.dll（dynamic link library）,.ib Linux:ELF,.so（shared object）,.a Library function 和 system call用户和内核空间&#x2F;&#x2F;Linux time sleep 1 编程语言低级语言 机器语言：0和1 汇编语言：和机器语言—对应，与硬件相关的特有代码、驱动程序开发中级语言：C 系统级应用、驱动程序高级语言：java, python, go, php, Objective-C, C# 应用级程序开发 服务器三大操作系统Windows:Linux:GNU&#x2F;LinuxUnix：1969年Ken Thompson System: Bell Lab、AIX （IBM）、Solaris（SUN）、HP-UX（HP） BSD:（BSRG）Berkeley System Distribution、NetBSD、OpenBSD、FreeBSD 兼容分时系统公用电脑时相关进程的管理系统 GNULinux发行版Linux参考网站：http://futurist.se/gldt/http://www.mindpin.com/dbjs-demo/linux/ 开源开源协议Linux哲学思想一切都是一个文件（包括硬件）小型，单一用途的程序链接程序，共同完成复杂的任务避免令人困惑的用户界面配置数据存储在文本中","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"knowledge","slug":"linux/knowledge","permalink":"https://blog.newimg.ltd/categories/linux/knowledge/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/tags/linux/"}]},{"title":"Week2-Java总结","slug":"Week2-Java总结","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Week2-Java总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Week2-Java%E6%80%BB%E7%BB%93/","excerpt":"","text":"部分资源来自温柔的养猫人，仅供学习参考。 文件I&#x2F;O流的概念用于处理文件内部的数据 字节处理流：OutputStream()（输出字节流）、InputStream()（输入字节流）； 字符处理流：Writer（输出字符流）、Reader（输入字符流）； OutputStreampublic abstract class OutputStream extends Object implements Closeable, Flushable&#123;&#125; Closeablepublic interface Closeable extends AutoCloseable&#123; public void close() throws IOException; &#125; Flushablepublic interface Flushable&#123; void flush() throws IOException; &#125; No 方法 类型 描述 01 public abstract void write(int b) throws IOException； 普通 输出单个字节数据 02 public void write(byte[] b) throws IOException； 普通 输出一组字节数据 03 public void write(byte[] b, int off, int len) throws IOException； 普通 输出部分字节数据 将数据写入文件 【覆盖】构造方法：public FileOutputStream(File file) throws FileNotFoundException； 【追加】构造方法：public FileOutputStream(File file, boolean append) throws FileNotFoundException 例子： /JavaAPIDemo.javaimport java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); //1.指定要操作文件的路径 if(!file.getParentFile().exists())&#123; //文件不存在 file.getParentFile().mkdirs(); //创建父目录 &#125; OutputStream output=new FileOutputStream(file); //2.通过子类实例化 String str=\"www.mldn.cn\"; //要输出的文件内容 output.write(str.getBytes()); // 3.将字符串变为字节数组 output.close(); //4.关闭资源 &#125; &#125; 加入自动关闭处理： /JavaAPIDemo.javaimport java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); //1.指定要操作文件的路径 if(!file.getParentFile().exists())&#123; //文件不存在 file.getParentFile().mkdirs(); //创建父目录 &#125; try(OutputStream output=new FileOutputStream(file,true)) &#123; //2.通过子类实例化 String str=\"www.mldn.cn\\r\\n\"; //要输出的文件内容 output.write(str.getBytes()); // 3.将字符串变为字节数组 &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; InputStreampublic abstract class InputStream extends Object implements Closeable No 方法 类型 描述 01 public abstract int read() throws IOException 普通 读取单个字节数据，如果现在已经读取到底了，返回-1 02 public int read(byte[] b) throws IOException 普通 读取一组字节数据，返回的是读取的个数，如果数据已经读取到底了则返回-1 03 public int read(byte[] b, int off, int len) throws IOException 普通 读取一组字节数据（只占数组的部分） 例：读取文件数据 /JavaAPIDemo.javaimport java.io.File; import java.io.FileInputStream; import java.io.InputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); InputStream input=new FileInputStream(file); byte[] data=new byte[1024]; //开辟一个缓冲区读取数据 int len = input.read(data); //读取数据,数据全部保存在字节数组中，返回读取个数 System.out.println(\"【\"+new String(data,0,len)+\"】\"); input.close(); &#125; &#125; 新方法 /JavaAPIDemo.javaimport java.io.File; import java.io.FileInputStream; import java.io.InputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); InputStream input=new FileInputStream(file); byte[] data=input.readAllBytes(); //读取全部数据 System.out.println(\"【\"+new String(data)+\"】\"); input.close(); &#125; &#125; Writerpublic abstract class Writer extends Object implements Appendable, Closeable, Flushable 输出字符数组：public void write(char[] cbuf) throws IOException； 输出字符串：public void write(String str) throws IOException； 使用Writer类输出： 覆盖： /JavaAPIDemo.javaimport java.io.File; import java.io.FileWriter; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); //父目录必须存在 &#125; // Writer out =new FileWriter(file, true);//内容追加 Writer out = new FileWriter(file); //内容覆盖 String str = \"www.mldn.cn\"; out.write(str); out.close(); &#125; &#125; 追加： /JavaAPIDemo.javaimport java.io.File; import java.io.FileWriter; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); //父目录必须存在 &#125; Writer out = new FileWriter(file); //内容覆盖 String str = \"www.mldn.cn\\r\\n\"; out.write(str); out.append(\"中国人民万岁。\"); //追加输出内容 out.close(); &#125; &#125; Readerpublic abstract class Reader extends Object implements Readable, Closeable 数据读取： /JavaAPIDemo.javaimport java.io.File; import java.io.FileReader; import java.io.Reader; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); if(file.exists())&#123; //文件存在则进行读取 Reader in= new FileReader(file); char data[]=new char[1024]; int len=in.read(data); System.out.println(\"读取内容：\"+new String(data,0,len)); //读取内容：www.mldn.cn 中国人民万岁。 in.close(); &#125; &#125; &#125; 字节流与字符流的区别在使用OutputStream类输出的时候，如果没有使用close()方法关闭输出流会发现内容依然可以实现正常的输出；但是如果在使用Writer的时候没有使用close()方法关闭输出流，那么这个时候内容将无法进行输出，因为Writer使用到了缓冲区，当使用close()方法的时候实际上会出现有强制刷新缓冲区的情况，所以这个时候会将内容进行输出，如果没有关闭，那么将无法进行输出操作，所以此时如果在不关闭的情况下想将全部的内容进行输出可以使用flush()方法强制性清空。 使用Writer并强制性清空： /JavaAPIDemo.javaimport java.io.File; import java.io.FileWriter; import java.io.Writer; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); //父目录必须存在 &#125; Writer out = new FileWriter(file); String str = \"www.mldn.cn\"; out.write(str); out.flush();//强制性刷新 www.mldn.cn &#125; &#125; 字节流在进行处理的时候并不会使用到缓冲区，而字符流会使用到缓冲区，另外使用缓冲区的字符流更加适合进行中文数据的处理，所以在日后的开发中如果要涉及到包含有中文信息的输出，一般都会使用字符流进行处理，但是从另外一方面来讲，字节流和字符流的基本处理形式是相似的，由于IO很多情况下都是进行数据的传输使用（二进制），所以我们的重点将以字节流为主。 转换流转换流可以实现字节流和字符流操作的功能转换。 类：OutputStreamWriter：定义： public class OutputStreamWriter extends Writer构造方法：public OutputStreamWriter(OutputStream out); 类：InputStreamReader：定义：public class InputStreamReader extends Reader构造方法： public InputStreamReader(InputStream in); 观察转换 /JavaAPIDemo.javaimport java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.Writer; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\"+ File.separator + \"hello\" + File.separator + \"mldn.txt\"); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs();//父目录必须存在 &#125; OutputStream output=new FileOutputStream(file); Writer out=new OutputStreamWriter(output); //字节流变为字符流 out.write(\"www.mldn.cn\"); //直接输出字符串，字符流适合于处理中文 out.close(); &#125; &#125; 继承关系： FileWriter： public class FileWriter extends OutputStreamWriter FileReader： public class FileReader extends InputStreamReader I&#x2F;O操作深入字符编码常用编码格式： GBK&#x2F;GB2312：国标编码，可以描述中文信息，其中GB2312只描述简体中文，而GBK包含简体中文和繁体中文； ISO8859-1：国际通用编码，可以用其描述所有的字母信息，如果是象形文字，则需要进行编码处理； UNICODE编码：采用十六进制的方式存储，可以描述所有文字信息； UTF编码：象形文字部分使用十六进制编码，而普通的字母采用 ISO8859-1编码，它的优势在于适合快速的传输，节约带宽，也就成为了开发中首选的编码，主要使用“UTF-8”编码。 内存操作流ByteArrayInputStream 构造：public ByteArrayInputStream(byte[] buf)； ByteArrayOutputStream 构造：public ByteArrayOutputStream()； ByteArrayOutputStream类中的两个重要的方法： 获取数据：public byte[] toByteArray()； 使用字符串的形式获取：public String toString()； 利用内存流实现一个小写字母转大写字母的操作 /JavaAPIDemo.javaimport java.io.ByteArrayOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.io.ByteArrayInputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; String str=\"www.mldn.cn\"; //小写字母 InputStream input=new ByteArrayInputStream(str.getBytes()); //将数据保存到内存流 OutputStream output=new ByteArrayOutputStream();//读取内存中的数据 int data = 0; while ((data = input.read())!= -1)&#123; //每次读取一个字节 output.write(Character.toUpperCase((char)data)); //保存数据 &#125; System.out.println(output); //WWW.MLDN.CN input.close(); output.close(); &#125; &#125; 管道流管道流主要功能是实现两个线程之间的IO处理操作。 字节管道流：PipedOutputStream、PipedInputStream 连接处理：public void connect(PipedInputStream snk) throws IOException； 字符管道流：PipedWriter、PipedReader 连接处理：public void connect(PipedReader snk) throws IOException； RandomAccessFile处理超大型文件时有优势 构造方法： public RandomAccessFile(File file, String mode) throws FileNotFoundException 跳字节读取： 向下跳： public int skipBytes(int n) throws IOException； 向回跳：public void seek(long pos) throws IOException； 输入与输出打印流打印流设计思想： /JavaAPIDemo.javaimport java.io.File; import java.io.FileOutputStream; import java.io.Exception; import java.io.OutputStream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; File file = new File(\"d:\" + File.separator +\"mldn.txt\"); //定义操作文件 PrintUtil pu= new PrintUtil(new FileOutputStream(file)); pu.println(\"姓名：小强子\"); pu.print(\"年龄：\"); pu.println(78); pu.close(); &#125; &#125; class PrintUtil implements AutoCloseable &#123; //实现一些常用数据的输出 private OutputStream output; //不管现在如何进行输出操作，核心使用的就是OutputStream public PrintUtil(OutputStream output) &#123; //由外部来决定输出的位置 this.output = output; &#125; @Override public void close() throws Exception &#123; this.output.close(); &#125; public void print(String str) &#123; //输出字符串 try &#123; this.output.write(str.getBytes()); //输出 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void println(String str) &#123; this.print(str + \"\\r\\n\"); &#125; public void print(long num) &#123; this.print(String.valueOf(num)); &#125; public void println(long num) &#123; this.println(String.valueOf(num)); &#125; &#125; PrintStream： public class PrintStream extends FilterOutputStream implements Appendable, Closeable 构造方法：public PrintStream(OutputStream out); PrintWriter： public class PrintWriter extends Writer 构造方法：public PrintWriter(OutputStream out); System类对IO的支持System类是一个系统类，而且是一个从头到尾一直都在使用的系统类，而在这个系统类之中提供有三个常量： 标准输出（显示器）：public static final PrintStream out； 错误输出：public static final PrintStream err； 标准输入（键盘）：public static final InputStream in； BufferedReader类读取一行数据： public String readLine() throws IOException; Scanner类Scanner类的返回值可以为String类型，相较于其他输入方式有优势，Scanner类中有如下几种方法： 构造：public Scanner(InputStream source); 判断是否有数据：public boolean hasNext(); 取出数据：public String next(); 设置分隔符：public Scanner useDelimiter(String pattern); 序列化序列化基本定义注意：需继承Serializable父接口。 序列化与反序列化有了序列化的支持类后，如果想要实现序列化和反序列化操作则可以利用以下两个类完成。 序列化：ObjectOutputStream： 类定义：public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants 构造方法： public ObjectOutputStream(OutputStream out) throws IOException 操作方法： public final void writeObject(Object obj) throws IOException 反序列化：ObjectInputStream： 类定义：public class ObjectInputStream extends InputStream implements ObjectInput,ObjectStreamConstants 构造方法： public ObjectInputStream(InputStream in) throws IOException 操作方法： public final Object readObject() throws IOException, ClassNotFoundException transient关键字该关键字可以将属性脱离序列化。 例： private transient String name;","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Week5-Java总结","slug":"Week5-Java总结","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/Week5-Java总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/Week5-Java%E6%80%BB%E7%BB%93/","excerpt":"","text":"Set接口Set集合最大的特点就是不允许保存重复元素，其也是Collection子接口。 在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下： public interface Set&lt;E&gt; extends Collection&lt;E&gt; 需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()方法，也就是说无法实现指定索引数据的获取，Set接口的继承关系如下。 Set接口继承关系 从JDK1.9后，Set集合也提供了像List集合中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。范例：验证Set集合特征 import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; //进行Set集合数据的保存，并设置有重复的内容 Set&lt;String> all=Set.of(\"Hello\",\"World\",\"MLDN\",\"Hello\",\"World\"); all.forEach(System.out::println); //直接输出 //Exception in thread \"main\" java.lang.IllegalArgumentException: duplicate element: Hello &#125; &#125; 当使用of()这个新方法的时候，如果发现集合中存在重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。 Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用的子类：HashSet、TreeSet。 HashSet子类HashSet是Set接口中使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下： public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable 这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下类的继承结构： HashSet子类 范例：观察HashSet类 import java.util.HashSet; import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String> all = new HashSet&lt;String>(); all.add(\"MLDN\"); all.add(\"NiHao\"); all.add(\"Hello\"); all.add(\"Hello\"); //重复元素 all.add(\"World\"); all.forEach(System.out::println); &#125; &#125; /** * NiHao * Hello * World * MLDN */ 通过执行结果就可以发现HashSet的操作特点：不允许保存重复元素（Set接口定义的），另外一个特点就是HashSet中保存的数据是无序的。 TreeSet子类Set接口的另外一个子接口就是TreeSet，与HashSet最大区别在于TreeSet集合里面保存的数据是有序的，首先来观察TreeSet类的定义： public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable 在这个子类中依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。 TreeSet 范例：使用TreeSet子类 import java.util.TreeSet; import java.util.Set; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String> all = new TreeSet&lt;String>(); all.add(\"MLDN\"); all.add(\"NiHao\"); all.add(\"Hello\"); all.add(\"Hello\"); //重复元素 all.add(\"World\"); all.forEach(System.out::println); &#125; &#125; /** * Hello * MLDN * NiHao * World */ 当利用TreeSet保存数据的时候，所有的数据将按照数据的升序进行自动排序处理。 TreeSet子类排序操作经过分析后发现，TreeSet子类中保存的数据是允许排序的，但是这个类必须要实现Comparable接口，只有实现了此接口才能够确认出对象的大小关系。 提示：TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap（树）就需要根据Comparable来确定对象的大小关系。 那么下面就使用一个自定义的类来实现排序的处理操作。范例：使用自定义的类实现排序的处理操作 import java.util.Set; import java.util.TreeSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;Person> all=new TreeSet&lt;Person>(); all.add(new Person(\"张三\",19)); all.add(new Person(\"李四\",19)); //年龄相同，但姓名不同 all.add(new Person(\"王五\",20)); //数据重复 all.add(new Person(\"王五\",20)); //数据重复 all.add(new Person(\"小强\",78)); all.forEach(System.out::println); &#125; &#125; class Person implements Comparable&lt;Person>&#123; //比较器 private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String toString() &#123; return \"姓名：\" + this.name + \"、年龄：\" + this.age; &#125; @Override public int compareTo(Person per) &#123; if(this.age &lt; per.age)&#123; return -1 ; &#125;else if(this.age > per.age) &#123; return 1; &#125;else &#123; return this.name.compareTo(per.name); &#125; &#125; &#125; /** * 姓名：张三、年龄：19 * 姓名：李四、年龄：19 * 姓名：王五、年龄：20 * 姓名：小强、年龄：78 */ 在使用自定义类对象进行比较处理的时候，一定要将该类中所有属性都依次进行大小关系的匹配，否则某一个或者几个属性相同的时候也会被认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。 由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发中应该首选HashSet子类进行存储。 重复元素消除TreeSet类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的： 对象编码：public int hashCode(); 对象比较：public boolean equals(Object obj); 在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果该编码不存在，则表示数据不存在，证明没有重复，如果该编码存在，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是Eclipse开发工具，则可以帮助开发者自动创建HashCode()与equals()方法。 范例：实现重复元素处理 import java.util.Set; import java.util.HashSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;Person> all=new TreeSet&lt;Person>(); all.add(new Person(\"张三\",19)); all.add(new Person(\"李四\",19)); //年龄相同，但姓名不同 all.add(new Person(\"王五\",20)); //数据重复 all.add(new Person(\"王五\",20)); //数据重复 all.add(new Person(\"小强\",78)); all.forEach(System.out::println); &#125; &#125; class Person implements Comparable&lt;Person>&#123; //比较器 private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result +age; result = prime * result + ((name == null)? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Person other = (Person) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125;else if (!name.equals(other.name)) return false; return true; &#125; public String toString() &#123; return \"姓名：\" + this.name + \"、年龄：\" + this.age; &#125; @Override public int compareTo(Person per) &#123; if(this.age &lt; per.age)&#123; return -1 ; &#125;else if(this.age > per.age) &#123; return 1; &#125;else &#123; return this.name.compareTo(per.name); &#125; &#125; &#125; /** * 姓名：小强、年龄：78 * 姓名：李四、年龄：19 * 姓名：王五、年龄：20 * 姓名：张三、年龄：19 */ 在Java程序中，真正的重复元素的判断处理利用的就是hashCode和equals()两个方法共同作用完成的，而只有在排序要求的情况下（TreeSet）才会利用Comparable接口来实现。 集合输出集合输出实际上从JDK1.8开始就在Iterable接口中提供了一个forEach()方法，但是这种方法输出并不是传统意义上集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式：Iterator迭代输出（95%）、ListIterator双向迭代输出（0.1%）、Enumeration枚举输出（4.9%）、foreach输出（与Iterator相当）。 Iterator迭代输出通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个iterator()操作方法，通过此方法可以获取Iterator接口对象（在JDK1.5之前，这一方法直接定义在Collection接口之中）。 获取Iterator接口对象：public Iterator&lt;T&gt; iterator(); 在Iterator接口里面定义有如下的方法： No. 方法名称 类型 描述 01 public boolean hasNext() 普通 判断是否有数据 02 public E next() 普通 取出当前数据 03 default void remove() 普通 删除 在之前使用的java.util.Scanner类就是Iterator接口的子类，所以此时类继承关系如下： Iterator接口 范例：使用Iterator输出 import java.util.Set; import java.util.Iterator; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String> all = Set.of(\"Hello\", \"World\", \"MLDN\"); Iterator&lt;String> iter = all.iterator(); //实例化Iterator接口对象 while (iter.hasNext()) &#123; String str = iter.next(); System.out.println(str); // World Hello MLDN &#125; &#125; &#125; 但是对于Iterator接口中的remove()方法的使用需要特别注意一下（如果不是必须不要使用）。实际上在Collection接口中定义有数据的删除操作方法，但是在进行迭代输出的过程中如果你使用了Collection中的remove()方法会导致迭代失败。范例：采用Collection集合中remove()方法删除 import java.util.Set; import java.util.Iterator; import java.util.HashSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String> all = new HashSet&lt;String>(); all.add(\"Hello\"); all.add(\"World\"); all.add(\"MLDN\"); Iterator&lt;String> iter = all.iterator(); //实例化Iterator接口对象 while (iter.hasNext()) &#123; String str = iter.next(); if (\"World\".equals(str)) &#123; all.remove(\"World\"); //Collection集合方法 &#125;else &#123; System.out.println(str); // Hello Exception in thread \"main\" java.util.ConcurrentModificationException &#125; &#125; &#125; &#125; 此时无法进行数据删除处理操作，那么就只能够利用Iterator接口中的remove()方法删除。 范例：使用Iterator接口删除方法 import java.util.Set; import java.util.Iterator; import java.util.HashSet; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Set&lt;String> all = new HashSet&lt;String>(); all.add(\"Hello\"); all.add(\"World\"); all.add(\"MLDN\"); Iterator&lt;String> iter = all.iterator(); //实例化Iterator接口对象 while (iter.hasNext()) &#123; String str = iter.next(); if (\"World\".equals(str)) &#123; iter.remove(); //Collection集合方法 &#125;else &#123; System.out.println(str); // Hello Exception in thread \"main\" java.util.ConcurrentModificationException &#125; &#125; System.out.println(\"*** \"+ all); &#125; &#125; //Hello //MLDN //*** [Hello, MLDN] 此时程序执行后没有出现任何的错误，并且可以成功的删除原始集合中的数据。面试题：请解释Collection.remove()与Iterator.remove()的区别？在进行迭代输出的时候，如果使用了Collection.remove()则会造成并发更新的异常，导致程序删除出错，而此时只能够利用Iterator接口中remove()方法实现正常的删除处理。 ListIterator双向迭代输出使用Iterator进行的迭代输出操作有一个特点：只允许由前向后输出，而如果现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口：ListIterator接口来实现了。需要注意的是，如果想要获取ListIterator接口对象，Collection中并没有定义相关的处理方法，但是List子接口有，也就是说这个输出的接口是专门为List集合准备的。 ListIterator接口 ListIterator接口中定义有如下的操作方法： 判断是否有前一个元素：public boolean hasPrevious()获取当前元素：public E previous() 范例：实现双向迭代 import java.util.ArrayList; import java.util.List; import java.util.ListIterator; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all = new ArrayList&lt;String>(); all.add(\"Hello\"); all.add(\"World\"); all.add(\"MLDN\"); ListIterator&lt;String> iter = all.listIterator(); System.out.print(\"由前向后输出：\"); while (iter.hasNext()) &#123; System.out.print(iter.next() + \"、\"); &#125; System.out.print(\"\\n由后向前输出：\"); //由前向后输出：Hello、World、MLDN、 while (iter.hasPrevious()) &#123; System.out.print(iter.previous() + \"、\"); //由后向前输出：MLDN、World、Hello、 &#125; &#125; &#125; 如果想实现由后向前的遍历，那么首先要实现的是由前向后实现遍历处理。 Enumeration输出Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，所以要想获取Enumeration接口对象，那么必须依靠Vector类提供的方法： 获取Enumeration：public Enumeration&lt;E&gt; elements()在Enumeration接口中定义有两个操作方法：判断是否有下一个元素：public boolean hasMoreElements()获取当前元素：public E nextElement() Enumeration 范例：使用Enumeration实现输出 import java.util.Enumeration; import java.util.Vector; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Vector&lt;String> all = new Vector&lt;String>(); all.add(\"Hello\"); all.add(\"World\"); all.add(\"MLDN\"); Enumeration&lt;String> enu = all.elements(); while (enu.hasMoreElements()) &#123; String str = enu.nextElement(); System.out.print(str +\"、\"); //Hello、World、MLDN、 &#125; &#125; &#125; 由于该接口出现的时间比较长了，所以在一些比较早的开发过程中，也有部分的方法只支持Enumeration输出操作，但随着类方法的不断完善，大部分的操作都能直接利用Iterator实现了。 foreach输出除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。范例：使用foreach输出 import java.util.ArrayList; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all = new ArrayList&lt;String>(); all.add(\"Hello\"); all.add(\"World\"); all.add(\"MLDN\"); for (String str : all)&#123; System.out.print(str+\"、\"); //Hello、World、MLDN、 &#125; &#125; &#125; 这种输出最初出现时很多人并不建议使用，因为标准的集合操作还是以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多语法也开始被大部分人所习惯。 Map接口之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，而在数据结构中除了可以进行单个对象的保存外，也可以进行二元偶对象的保存（key&#x3D;value）的形式来存储，而存储二元偶对象的核心意义在于需要通过key获取对应的value。 在开发中，Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。 Map接口是进行二元偶对象保存的最大父接口。该接口定义如下： public interface Map&lt;K,V> 该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是在整体操作的时候需要保存两个内容，在Map接口中定义有许多操作方法，但是需要记住以下的核心操作方法： No. 方法名称 类型 描述 01 public V put(K key,V value) 普通 向集合中保存数据 02 public V get(Object key) 普通 根据key查询数据 03 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 普通 将Map集合转为Set集合 04 public boolean containsKey(Object key) 普通 查询指定的key是否存在 05 public Set&lt;K&gt; keySet() 普通 将Map集合中的key转为Set集合 06 public V remove(Object key) 普通 根据key删除指定的数据 从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用。范例：观察Map集合的特点 import java.util.Map; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; // Map&lt;String,Integer> map=Map.of(\"one\",1,\"two\",2); // System.out.println(map); //&#123;one=1,two=2&#125; // // Map&lt;String,Integer> map=Map.of(\"one\",1,\"two\",2,\"one\",101); // System.out.println(map); //Exception in thread \"main\" java.lang.IllegalArgumentException: duplicate key: one Map&lt;String,Integer> map=Map.of(\"one\",1,\"two\",2,null,0); System.out.println(map); //Exception in thread \"main\" java.lang.NullPointerException &#125; &#125; 在Map集合之中数据的保存就是按照“key&#x3D;value”的形式存储的，并且使用of()方法操作时里面的数据是不允许重复，如果重复则会出现“IllegalArgumentException”异常，如果设置的内容为null，则会出现“NullPointerException”异常。 对于现在见到的of()方法严格意义上来说并不是Map集合的标准用法，因为正常的开发中需要通过Map集合的子类来进行接口对象的实例化，而常用的子类：HashMap、HashTable、TreeMap、LinkedHashMap。 HashMap子类HashMap是Map接口中最为常见的一个子类,该类的主要特点是无序存储，通过Java文档首先来观察一下HashMap子类的定义： public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable 该类的定义继承形式符合之前的集合定义形式，依然提供有抽象类并且依然需要重复实现Map接口。 HashMap子类 范例：观察Map集合的使用 import java.util.HashMap; import java.util.Map; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Map&lt;String,Integer> map = new HashMap&lt;String,Integer>(); map.put(\"one\",1); map.put(\"two\",2); map.put(\"one\",101); //key重复 map.put(null,0); //key为null map.put(\"zero\",null); //value为null System.out.println(map.get(\"one\")); //key存在：101 System.out.println(map.get(null)); //key存在：0 System.out.println(map.get(\"ten\")); //key不存在：null &#125; &#125; 以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或者value保存null的数据，同时也可以发现即便保存数据的key重复，那么也不会出现错误，而是出现内容的替换。 但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回旧的value。范例：观察put()方法 import java.util.HashMap; import java.util.Map; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Map&lt;String, Integer> map = new HashMap&lt;String,Integer>(); System.out.println(map.put(\"one\", 1)); //key不重复，返回null：null System.out.println(map.put(\"one\", 101)); //key重复，返回旧数据：1 &#125; &#125; 在设置了相同key的内容的时候，put()方法会返回原始的数据内容。 清楚了HashMap的基本功能之后，接下来就需要研究一下HashMap中给出的源代码。HashMap之中肯定需要存储大量的数据，那么对于数据的存储，来看看HashMap是怎样操作的： public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; 当使用无参构造的时候，会出现有一个loadFactor属性，并且该属性默认的内容为“0.75”（static final float DEFAULT_LOAD_FACTOR = 0.75f;） public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; 在使用put()方法进行数据保存时会调用一个putVal()方法，同时会将key进行hash处理（生成一个hash码），而对于putVal()方法中会发现会提供一个Node节点类进行数据的保存，而在使用putVal()方法操作的过程中，会调用一个resize()方法可以进行容量的扩充。 面试题：在进行HashMap的put()操作时，如何实现容量扩充？ 在HashMap类中提供了一个“DEFAULT_INITIAL_CAPACITY”的常量，作为初始化的容量配置，而这个常量的默认大小为16个元素，也就是说默认的可以保存的最大内容是16； 当保存的内容的容量超过了一个阈值（DEFAULT_LOAD_FACTOR&#x3D;0.75f），相当于“容量*阈值&#x3D;12”保存12个元素的时候就会进行容量的扩充； 在进行扩充的时候HashMap采用的是成倍的扩充模式，即：每一次都扩充2倍的容量。 面试题：请解释HashMap的工作原理（JDK1.8之后开始的） 在HashMap中进行数据存储依然是利用Node类完成的，那么这种情况下就证明可以使用的数据结构只有两种：链表（时间复杂度“O(n)”）、二叉树（时间复杂度“O(logn)”）； 从JDK1.8开始，HashMap的实现出现了改变，因为其要适应于大数据时代的海量数据问题，所以对其存储发生了变化，并且在HashMap类的内部提供有一个常量：“static final int TREEIFY_THRESHOLD &#x3D; 8;”，在使用HashMap进行数据保存时，如果保存的数据没有超过阈值8（TREEIFY_THRESHOLD），那么会按照链表的形式进行存储，如果超过了阈值，则会将链表转为红黑树以实现树的平衡，并且利用左旋与右旋保证数据的查询性能。 LinkedHashMap子类HashMap虽然是Map集合中最为常用的子类，但是其本身保存的数据都是无序的（有序与否对Map没有影响），如果现在希望Map集合中的保存的数据的顺序为其增加顺序，则就可以更换子类为LinkedHashMap（基于链表实现的），观察LinkedHashMap类的定义形式： public class LinkedHashMap&lt;K,V> extends HashMap&lt;K,V> implements Map&lt;K,V> 既然是链表保存，所以一般在使用LinkedHashMap类时数据量不要特别大，因为会造成时间复杂度攀升，通过继承的结构可以发现LinkedHashMap是HashMap的子类，继承关系如下： LinkedHashMap 范例：使用LinkedHashMap import java.util.LinkedHashMap; import java.util.Map; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Map&lt;String, Integer> map = new LinkedHashMap&lt;String, Integer>(); map.put(\"one\", 1); map.put(\"two\", 2); map.put(\"one\", 101); map.put(\"null\", 0); map.put(\"zero\", null); System.out.println(map); //&#123;one=101, two=2, null=0, zero=null&#125; &#125; &#125; 通过此时的程序执行可以发现当使用LinkedHashMap进行存储之后所有数据的保存顺序为添加顺序。 HashTable子类HashTable类是从JDK1.0时提供的，与Vector、Enumeration属于最早的一批动态数组的实现类，后来为了将其继续保留下来，所以让其多实现了一个Map接口，HashTable类的定义如下： public class Hashtable&lt;K,V> extends Dictionary&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable HashTable的继承结构如下： HashTable子类 范例：观察HashTable子类的使用 import java.util.Hashtable; import java.util.Map; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Map&lt;String, Integer> map = new Hashtable&lt;String,Integer>(); map.put(\"one\", 1); map.put(\"two\", 2); map.put(\"one\", 101); // map.put(null, 0); //不能为空 // map.put(\"zero\",null); //不能为空，Exception in thread \"main\" java.lang.NullPointerException System.out.println(map); // &#123;two=2, one=101&#125; &#125; &#125; 通过观察可以发现在HashTable中进行数据存储时设置的key或value都不允许为null，否则会出现NullPointerException异常。 面试题：请解释HashMap与HashTable的区别？ HashMap中的方法都属于异步操作，非线程安全，HashMap允许保存有null的数据； HashTable都属于同步方法（线程安全），HashTable不允许保存null，否则会出现NullPointerException异常； Map.Entry内部接口虽然现在已经清楚了整个的Map集合的基本操作形式，但是依然需要有一个核心的问题要解决，Map集合里面是如何进行数据存储的？对于List而言（LinkedList子类）依靠的是链表的形式实现的数据存储，那么在进行数据存储的时候一定要将数据把数据保存在Node节点之中，虽然在HashMap里面也可以见到Node类型定义，通过源代码的定义可以发现，HashMap类中的Node内部类本身实现了Map.Entry接口。 static class Node&lt;K,V> implements Map.Entry&lt;K,V> &#123;&#125; 1 所以可以得出结论：所有的key和value的数据都被封装在Map.Entry接口之中，而此接口定义如下： public static interface Map.Entry&lt;K,V> 1 并且在这个内部接口里面提供有两个重要的操作方法：（1）获取key：K getKey()（2）获取value：V getValue()在JDK 1.9以前的开发版本之中，使用者基本上都不会去考虑创建Map.Entry的对象，实际上在正常的开发过程之中，使用者也不需要关心Map.Entry对象的创建，可是从JDK 1.9之后Map接口里面追加有一个新的方法：（1）创建Map.Entry对象：static &lt;K,​V&gt; Map.Entry&lt;K,​V&gt; entry​(K k, V v)范例：创建Map.Entry对象 package org.lks.demo; import java.util.Map; public class JavaReflectDemo &#123; public static void main(String[] args) &#123; Map.Entry&lt;String, Integer> mapEntry = Map.entry(\"one\", 1); System.out.println(mapEntry.getKey() + \" = \" + mapEntry.getValue()); &#125; &#125; /* one = 1 */ 12345678910111213141516 通过分析可以发现在整个的Map集合里面，Map.Entry的主要作用就是作为一个Key和Value的包装类型使用，而大部分情况下在进行数据存储的时候都会将key和value包装为一个Map.Entry对象进行使用。 利用Iterator输出Map集合对于集合的输出而言，最标准的做法就是利用Iterator接口来完成，但是需要明确一点的是在Map集合里面并没有一个方法可以直接返回Iterator的接口对象，所以这种情况下就必须分析不直接提供Iterator接口实例化的方法原因，下面对Collection与Map集合的存储结构进行一个比较处理。发现在Map集合里面保存的实际上是一组Map.Entry接口对象（里面包装的是Key和Value），所以整个来讲Map依然实现的是单值的保存，这样在Map集合里面提供有一个方法static &lt;K,​V&gt; Map.Entry&lt;K,​V&gt; entry​(K k, V v)，将全部的Map集合转为Set集合。 经过分析可以发现要想使用Iterator实现Map集合的输出则必须按照如下步骤处理：（1）利用Map接口中提供的entrySet()方法将Map集合转为Set集合；（2）利用Set接口中的iterator()方法将Set集合转为Iterator接口实例；（3）利用Iterator进行迭代输出获取每一组的Map.Entry对象，随后通过getKey()与getValue()获取数据。范例：利用Iterator输出Map集合 package org.lks.demo; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class JavaReflectDemo &#123; public static void main(String[] args) &#123; Map&lt;String, Integer> map = new HashMap&lt;String, Integer>(); map.put(\"one\", 1); map.put(\"two\", 2); map.put(\"one\", 100); map.put(null, 3); Set&lt;Map.Entry&lt;String, Integer>> set = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer>> iter = set.iterator(); while(iter.hasNext()) &#123; Map.Entry&lt;String, Integer> temp = iter.next(); System.out.println(temp.getKey() + \" = \" + temp.getValue()); &#125; &#125; &#125; 123456789101112131415161718192021222324 虽然Map集合本身支持有迭代输出的支持，但是如果从实际开发来讲，Map集合最主要的用法在于实现数据key的查找操作，另外需要提醒的是，如果现在不使用Iterator而使用foreach语法输出则以需要将Map集合转为Set集合。范例：使用foreach输出Map集合 package org.lks.demo; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set; public class JavaReflectDemo &#123; public static void main(String[] args) &#123; Map&lt;String, Integer> map = new HashMap&lt;String, Integer>(); map.put(\"one\", 1); map.put(\"two\", 2); map.put(\"one\", 100); map.put(null, 3); Set&lt;Map.Entry&lt;String, Integer>> set = map.entrySet(); for(Map.Entry&lt;String, Integer> temp : set) &#123; System.out.println(temp.getKey() + \" = \" + temp.getValue()); &#125; &#125; &#125; 12345678910111213141516171819202122 由于Map迭代输出的情况相对较少，所以对此类的语法应该·深入理解一下，并且一定要灵活掌握。 自定义Map的key类型在使用Map集合的时候可以发现对于Key和Value的类型实际上都可以由使用者任意定义，那么也就意味着现在依然可以使用自定义的类来进行Key类型的设置，对于自定义Key类型所在的类中一定要覆写hashCode()和equals()方法，否则无法查找到。 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; 123 在进行数据保存的时候发现会自动使用传入的key的数据生成一个hash码，也就是说存储的时候是有这个Hash数值。 public V get(Object key) &#123; Node&lt;K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; 1234 再根据key获取数据的时候依然要将传入的key通过hash()方法来获取其对应的hash码，那么也就证明查询的过程之中首先要利用hashCode()来进行数据查询，当使用getNode()方法查询的时候还需要使用到equals()方法。 范例：使用自定义类作为Key类型 package org.lks.demo; import java.util.HashMap; import java.util.Map; import java.util.Set; class PersonA&#123; private String name; private int age; public PersonA() &#123;&#125; public PersonA(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PersonA other = (PersonA) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; &#125; public class JavaReflectDemo &#123; public static void main(String[] args) &#123; Map&lt;PersonA, Integer> map = new HashMap&lt;PersonA, Integer>(); map.put(new PersonA(\"lks\", 23), 1); map.put(new PersonA(\"hhy\", 20), 2); System.out.println(map.get(new PersonA(\"hhy\", 20))); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 虽然允许你使用自定义类作为Key的类型，但是也需要注意一点，在实际的开发之中对于Map集合的Key常用的类型就是：String、Long、Integer，尽量使用系统类。面试题：如果在进行HashMap进行数据操作的时候出现了Hash冲突（Hash码相同），HashMap是如何解决的？当出现了Hash冲突之后为了保证程序的正常执行，会在冲突的位置上将所有Hash冲突的内容转为链表保存。 集合工具类Stack栈操作 栈是一种先进后出的数据结构。例如：在文本编辑器上都有撤销功能，那么每次使用时可以发现，最后一次的编辑操作永远是最先撤销，那么这个功能就是利用栈来实现的，栈的基本操作形式如下： Stack栈 在Java程序中使用Stack来描述栈的操作，这个类的定义如下： public class Stack&lt;E> extends Vector&lt;E> Stack栈 可以发现Stack是Vector子类，但是它使用的并不是Vector类中所提供的方法，而是采用如下的两个方法： 入栈：public E push(E item) 出栈：public E pop() ***范例***：实现栈的操作 import java.util.Stack; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Stack&lt;String> all = new Stack&lt;String> (); all.push(\"a\"); all.push(\"b\"); all.push(\"c\"); System.out.println(all.pop());//c System.out.println(all.pop());//b System.out.println(all.pop());//a System.out.println(all.pop());//Exception in thread \"main\" java.util.EmptyStackException &#125; &#125; 通过上面的操作可以发现，所有保存的数据将按照倒序的形式弹出，如果栈已经空了，则会抛出空栈异常。 Queue队列 Queue描述的是一个队列，而队列的主要特点是实现先进先出的操作形式。其基本的操作形式如下： Queue 如果将队列应用在多线程的“生产者与消费者”的模型处理上，那么对于生产者过快的情况下，就没有必要等待消费者或者数据了，可以将所有的内容保存在队列之中，队列的实现可以使用LinkedList子类来完成，观察这个类的定义： LinkedList 队列的使用主要依靠Queue接口之中提供的方法来处理，提供有如下方法： 向队列中追加数据：boolean add(E e) 向队列中追加数据：boolean offer(E e) 通过队列获取数据（弹出不删除）：E peek() 通过队列获取数据（弹出并删除）：E poll() ***范例***：实现队列操作 import java.util.LinkedList; import java.util.Queue; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Queue&lt;String> queue=new LinkedList(); queue.add(\"X\");//追加队列数据，通过队尾追加 queue.offer(\"A\");//追加队列数据，通过队尾追加 queue.offer(\"Z\");//追加队列数据，通过队尾追加 System.out.println(queue.poll());//X System.out.println(queue.poll());//A System.out.println(queue.poll());//Z System.out.println(queue.poll());//null &#125; &#125; 除了LinkedList子类以外，还有一个优先级队列的概念，可以使用PriorityQueue实现优先级队列。这个类的定义如下： public class PriorityQueue&lt;E> extends AbstractQueue&lt;E> implements Serializable public abstract class AbstractQueue&lt;E> extends AbstractCollection&lt;E> implements Queue&lt;E> public abstract class AbstractCollection&lt;E> extends Object implements Collection&lt;E> PriorityQueue ***范例***：使用优先级队列 import java.util.PriorityQueue; import java.util.Queue; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Queue&lt;String> queue=new PriorityQueue(); queue.add(\"X\");//追加队列数据，通过队尾追加 queue.offer(\"A\");//追加队列数据，通过队尾追加 queue.offer(\"Z\");//追加队列数据，通过队尾追加 System.out.println(queue.poll());//X System.out.println(queue.poll());//A System.out.println(queue.poll());//Z &#125; &#125; 对于队列的选用原则也是需要根据实际的项目环境来决定的。 Properties属性操作 在之前讲解国际化程序时讲解过资源文件(*.properties)，这类文件的存储结构是按照“key&#x3D;value”的形式存储的，而这种结构的保存形式与Map集合很相似，但是唯一的区别在于其保存的内容只能够是字符串，所以为了可以方便地描述属性的定义，java.util包中提供了Properties类型，此类是HashTable的子类。 public class Properties extends Hashtable&lt;Object,Object> 可以发现在继承HashTable时为HashTable中定义的泛型为Object，Properties是不需要操作泛型的，因为它能够操作的类型只能是String类型，在Properties中如果想要实现属性的操作可以采用如下的方法实现： 设置属性： public Object setProperty​(String key, String value) 获取属性，key不存在返回null： public String getProperty​(String key) 获取属性，key不存在返回默认值： public String getProperty​(String key, String defaultValue) 输出属性内容： public void store​(OutputStream out, String comments) throws IOException 通过输入流读取属性内容： public void load​(InputStream inStream) throws IOException ***范例***：观察属性的设置和取得 import java.util.Properties; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Properties props = new Properties(); props.setProperty(\"mldn\", \"www.baidu.com\"); props.setProperty(\"java\", \"www.baidujava.com\"); System.out.println(props.getProperty(\"mldn\"));//www.baidu.com System.out.println(props.getProperty(\"sina\"));//null System.out.println(props.getProperty(\"sina\", \"notFound\"));//notFound &#125; &#125; 通过代码可以发现Properties中可以像Map集合那样进行内容的设置与获取，但是唯一的差别是它只能够操作String类型，另外需要注意的是，之所以会提供Properties类还有一个最重要的功能是它可以通过输出流输出属性，也可以使用输入流读取属性内容。 ***范例***：将属性内容保存在文件中 import java.io.File; import java.io.FileOutputStream; import java.util.Properties; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Properties props = new Properties(); props.setProperty(\"mldn\", \"www.baidu.com\"); props.setProperty(\"java\", \"www.baidujava.com\"); props.setProperty(\"city\",\"杭州\"); props.store(new FileOutputStream(new File(\"/Users/david/Documents/mydir/mldn.properties\")),\"中文的注释-englishRemark\"); &#125; &#125; 通过程序的执行发现，的确可以实现资源文件的输出处理，但是如果输出的是中文，则会自动进行Unicode转码处理。 ***范例***：读取资源文件 import java.io.File; import java.io.FileInputStream; import java.util.Properties; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Properties props = new Properties(); props.load(new FileInputStream(new File(\"/Users/david/Documents/mydir/mldn.properties\"))); System.out.println(props.getProperty(\"mldn\"));//www.baidu.com System.out.println(props.getProperty(\"java\"));//www.baidujava.com System.out.println(props.getProperty(\"city\"));//杭州 &#125; &#125; 使用Properties类型的最大特点就是可以进行资源内容的输入与输出的处理操作，但是在实际开发中Properties往往用于读取配置资源的信息，这一点主要是在标准设计中做程序初始化准备时使用。 Collections工具类 Collections是Java提供的一组集合数据的操作工具类，也就是说利用它可以实现各个集合的操作。 ***范例***：使用Collections操作List集合 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all=new ArrayList(); Collections.addAll(all, \"Hello\",\"world\",\"MLDN\"); System.out.println(all);//[Hello, world, MLDN] Collections.reverse(all); System.out.println(all);//[MLDN, world, Hello] &#125; &#125; ***范例***：使用二分查找 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all=new ArrayList(); Collections.addAll(all, \"Hello\",\"world\",\"MLDN\"); Collections.sort(all);//先进行排序处理 System.out.println(all);//[Hello, MLDN, world] System.out.println(Collections.binarySearch(all, \"MLDN\"));//1 &#125; &#125; 大部分情况下对于集合的使用可能没有这么多复杂要求，更多情况下就是利用集合保存数据，要么进行输出，要么进行查询。 Java网络编程从JDK1.8开始，由于已经进入到了大数据的时代，所以在类集中也支持有数据的流式分析处理操作，为此就专门提供了Stream接口，同时在Collection接口中也提供有为此接口实例化的方法。 获取Stream接口对象：default Stream&lt;E&gt; stream() Stream类基础操作 Stream主要功能是进行数据的分析处理，同时主要是针对于集合中的数据尽心分析操作 。 ***范例***：Stream的基本操作 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Stream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all = new ArrayList(); Collections.addAll(all, \"JAVA\", \"JS\", \"Python\", \"HTML\", \"PHP\"); Stream&lt;String> stream = all.stream();//获取Stream接口对象 // System.out.println(stream.count());//输出元素的个数 long count=stream.filter((ele) -> ele.toLowerCase().contains(\"j\") ).count(); System.out.println(count); &#125; &#125; 但是以上的程序只是实现了一些最基础的数据的个数统计，而更多情况下可能需要的是获取里面满足条件的数据内容，以实现数据采集操作。 ***范例***：数据采集 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all = new ArrayList(); Collections.addAll(all, \"JAVA\", \"JS\", \"Python\", \"HTML\", \"PHP\"); Stream&lt;String> stream = all.stream();//获取Stream接口对象 //将满足条件的数据收集起来转为List集合 List&lt;String> list = stream.filter((ele) -> ele.toLowerCase().contains(\"j\") ).collect(Collectors.toList()); System.out.println(list); &#125; &#125; 在Stream数据流处理的过程中还允许进行数据的分页处理，提供有两个方法： 设置取出最大的数据量：Stream&lt;T&gt; limit(long maxSize) 跳过指定数据量：Stream&lt;T&gt; skip(long n) ***范例***：观察分页 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; List&lt;String> all = new ArrayList(); Collections.addAll(all, \"JAVA\", \"JS\",\"JSP\", \"Python\", \"HTML\", \"PHP\",\"JSON\"); Stream&lt;String> stream = all.stream();//获取Stream接口对象 //将满足条件的数据收集起来转为List集合 List&lt;String> list = stream.filter((ele) -> ele.toLowerCase().contains(\"j\") ).skip(2).limit(2).collect(Collectors.toList());//[JSP, JSON] System.out.println(list); &#125; &#125; Stream的操作主要是利用其自身的特点实现数据的分析处理操作。 MapReduce基础模型 在进行数据分析的处理之中，有一个最重要的基础模型：MapReduce模型，对于这个模型一共是分为两个部分：Map处理部分、Reduce分析部分，在进行数据分析前必须要对数据进行合理的处理，而后才可以做统计分析操作。 ***范例***：MapReduce基础模型 import java.util.ArrayList; import java.util.DoubleSummaryStatistics; import java.util.List; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; //如果要想使用Stream进行分析处理，则一定要将全部要分析的数据保存在集合中 List&lt;Order> all = new ArrayList(); all.add(new Order(\"A款娃娃\", 9.9, 10)); all.add(new Order(\"大娃娃\", 19.9, 5)); all.add(new Order(\"A款笔记本\", 8317.3, 10)); all.add(new Order(\"B款茶杯\", 2.9, 800)); all.add(new Order(\"A款蛋糕\", 60, 3)); //分析购买商品中带有“款”的信息数据,并且进行商品单价和数量的处理，随后分析汇总 DoubleSummaryStatistics statistics = all.stream().filter((order -> order.getName().contains(\"款\"))).mapToDouble((order) -> order.getPrice() * order.getAmount()).summaryStatistics(); System.out.println(\"购买数量：\"+statistics.getCount());//购买数量：4 System.out.println(\"购买总价：\"+statistics.getSum());//购买总价：85772.0 System.out.println(\"平均花费：\"+statistics.getAverage());//平均花费：21443.0 System.out.println(\"最多花费：\"+statistics.getMax());//最多花费：83173.0 System.out.println(\"最少花费：\"+statistics.getMin());//最少花费：99.0 &#125; &#125; @lombok.Getter @lombok.NoArgsConstructor @lombok.AllArgsConstructor class Order &#123; private String name; private double price; private int amount; &#125; 这些分析操作只是JDK本身提供的支持，而实际开发中，肯定不会这样进行，因为所有的数据如果都保存在内存中，将不再适用于大数据编程。 Java网络编程 所谓的网络编程指的是多台主机之间的数据通讯操作。 网络编程简介 网络的核心定义在于：有两台以上的电脑就称为网络。实际上在世界上产生的第一台电脑之后就有人开始去思考如何生产更多的电脑并且进行有效连接。 网络连接的目的不仅仅是为了进行电脑的串联，更多的情况下是为了进行彼此之间的数据通讯，包括现在所谓的网络游戏本质上还是网络通讯的问题，而在通讯的实现上就产生了一系列的处理协议：IP、TCP、UDP等等，也就是说所谓的网络编程，实际上实现的就是一个数据的通讯操作而已，只不过这个通讯操作需要分为客户端和服务端。 于是针对网络程序的开发就有了两种模型： ***C&#x2F;S（Client&#x2F;Server、客户端与服务端）***：要开发出两套程序，一套程序为客户端，另外一套为服务端，如果现在服务端发生了改变之后客户端也应该进行更新处理，这种开发可以由开发者自定义传输协议，并且使用一些比较私密的端口，所以安全性是比较高的，但是开发与维护成本比较高； ***B&#x2F;S（Browser&#x2F;Server、浏览器与服务端）***：只开发一套服务端的程序，而后利用浏览器作为客户端进行访问，这种开发与维护的成本较低（只有一套程序），但是由于其使用的是公共的HTTP协议并且使用的公共的80端口，所以其安全性相对较差，现在的开发基本上以“B&#x2F;S”结构为主。 本次所要的网络编程主要就是C&#x2F;S程序模型，其分为两种开发：TCP（可靠的数据连接）、UDP（不可靠的数据连接）； TCP程序的基本实现 TCP的程序开发是网络程序的最基本的开发模型，其核心的特点是使用两个类实现数据的交互处理：ServerSocket（服务端）、Socket（客户端）。 ServerSocket与Socket ServerSocket的主要目的是设置服务器的监听端口，而Socket需要指明要连接的服务器地址和端口。下面实现一个最简单的数据处理操作，即Echo程序实现。 Echo模型 ***范例***：实现服务端的定义 import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class EchoServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket server = new ServerSocket(9999);//设置服务端的监听端口 System.out.println(\"等待客户端连接................\"); Socket client = server.accept();//有客户端连接 //1、首先需要先接收客户端发来的信息，而后才可以将信息处理后发送回客户端 Scanner scanner = new Scanner(client.getInputStream());//客户端输入流 scanner.useDelimiter(\"\\n\");//设置分隔符 PrintStream out = new PrintStream(client.getOutputStream());//客户端输出流 boolean flag = true;//循环标记 while (flag) &#123; if (scanner.hasNext()) &#123;//现在有数据发送 String val = scanner.next().trim();//接收发送的数据 if (\"exit\".equalsIgnoreCase(val)) &#123; out.println(\"bye\"); flag = false; &#125; else &#123; out.println(\"【ECHO】\" + val); out.flush(); &#125; &#125; &#125; scanner.close(); out.close(); client.close(); server.close(); &#125; &#125; ***范例***：实现客户端的定义 import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintStream; import java.net.Socket; import java.util.Scanner; public class EchoClient &#123; private static final BufferedReader KEYBOARD_BUF = new BufferedReader(new InputStreamReader(System.in)); public static void main(String[] args) throws Exception&#123; Socket client = new Socket(\"localhost\",9999);//定义服务端连接信息 //现在的客户端需要有输入与输出的操作支持，所以依然要准备出Scanner与PrintWriter Scanner scanner=new Scanner(client.getInputStream());//接收服务端的输入内容 scanner.useDelimiter(\"\\n\"); PrintStream out = new PrintStream(client.getOutputStream());//向服务器发送内容 boolean flag=true;//循环标记 while (flag)&#123; String input = getString(\"请输入要发送的内容：\"); out.println(input);//加换行 if(scanner.hasNext())&#123;//服务端有回应了 System.out.println(scanner.next()); &#125; if(\"exit\".equalsIgnoreCase(input))&#123; flag =false; &#125; &#125; scanner.close(); out.close(); client.close(); &#125; public static String getString(String prompt)throws Exception&#123; System.out.print(prompt); String str=KEYBOARD_BUF.readLine(); return str; &#125; &#125; 此时就实现了一个最基础的客户端与服务端之间的数据通讯操作。 多线程与网络开发 现在尽管已经实现了一个标准的网络程序开发，但是在整个的开发过程之中存在严重的性能缺陷，因为该服务器只能够为一个线程提供Echo服务，如果说现在的服务器需要有多人进行连接访问的时候，那么其他的使用者将无法连接（等待连接）。 所以现在就可以发现单线程的服务器开发本身就是一种不合理的做法，那么此时最好的解决方案将每一个连接到服务器上的客户端都通过一个线程对象来进行处理，即：服务器上启动多个线程，每一个线程单独为每一个客户端实现Echo服务支持。 Echo多线程模型（BIO） ***范例***：修改服务器端程序 import java.io.IOException; import java.io.PrintStream; import java.net.ServerSocket; import java.net.Socket; import java.util.Scanner; public class EchoServer &#123; private static class ClientThread implements Runnable &#123; private Socket client = null; private Scanner scanner = null; private PrintStream out = null; private boolean flag = true;//循环标记 public ClientThread(Socket client) throws Exception &#123; this.client = client; scanner = new Scanner(client.getInputStream());//客户端输入流 scanner.useDelimiter(\"\\n\");//设置分隔符 out = new PrintStream(client.getOutputStream());//客户端输出流 &#125; @Override public void run() &#123; while (flag) &#123; if (scanner.hasNext()) &#123;//现在有数据发送 String val = scanner.next().trim();//接收发送的数据 if (\"exit\".equalsIgnoreCase(val)) &#123; out.println(\"bye\"); flag = false; &#125; else &#123; out.println(\"【ECHO】\" + val); out.flush(); &#125; &#125; &#125; scanner.close(); out.close(); try &#123; if (client != null) client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; ServerSocket server = new ServerSocket(9999);//设置服务端的监听端口 System.out.println(\"等待客户端连接................\"); //1、首先需要先接收客户端发来的信息，而后才可以将信息处理后发送回客户端 boolean flag = true;//循环标记 while (flag) &#123; new Thread(new ClientThread(server.accept())).start(); &#125; server.close(); &#125; &#125; 如果你在这类的代码中再追加一些集合的数据控制，实际上就可以实现一个80年代的聊天室了。 数据报发送与接收（UDP） 之前所见到的都属于TCP程序开发范畴，TCP程序最大的特点是可靠的网络连接，但是在网络程序开发之中还存在一种UDP程序，基于数据报的网络编程实现，如果想要实现UDP程序需要两个类：DatagramPacket（数据内容）、DatagramSocket（网络的发送与接收）。数据报就好比发送的短消息一样，客户端是否收到与发送者无关。 ***范例***：实现一个UDP客户端 import java.net.DatagramPacket; import java.net.DatagramSocket; public class UDPClient &#123; public static void main(String[] args) throws Exception&#123; DatagramSocket client = new DatagramSocket(9999);//连接到9999端口 byte [] data = new byte [1024];//接收信息 DatagramPacket packet = new DatagramPacket(data,data.length); System.out.println(\"客户端等待接收发送的消息............\"); client.receive(packet); System.out.println(\"接收的消息内容为：\"+new String(data,0,packet.getLength())); &#125; &#125; ***范例***：实现一个UDP服务端 import java.net.InetAddress; import java.net.DatagramPacket; import java.net.DatagramSocket; public class UDPServer &#123; public static void main(String[] args)throws Exception &#123; DatagramSocket server = new DatagramSocket(9000);//连接到9999端口 String str=\"www.baidu.com\"; DatagramPacket packet = new DatagramPacket(str.getBytes(),0, str.length(),InetAddress.getByName(\"localhost\"),9999); server.send(packet); System.out.println(\"消息发送完毕.....\"); server.close(); &#125; &#125; UDP发送的数据一定是不可靠的，但是TCP由于需要保证可靠的连接，所以所需要的服务器资源就越多。 Java数据库编程基础操作JDBC简介 对于现在的开发几乎所有的项目都是围绕着数据库展开的，很少会遇到没有数据库而独立存在的项目，所以任何一门编程语言要想发展，那么必须对数据的开发有所支持，同样，Java从最初的时代开始就一直支持数据句酷的开发标准——JDBC（Java Database Connectivity、Java数据库连接）JDBC本质上来说并不属于一个技术，它属于一种服务。而所有服务的特征：必须按照指定的规则来进行操作。 在Java中专门为JDBC提供了一个模块（java.sql）,里面核心的一个开发包（java.sql），在JDBC中核心的组成就是DriverManager类以及若干接口（Connection、Statement、PreparedStatement、ResultSet）。 对于JDBC的程序数据库访问也分为如下四种形式： JDBC-ODBC桥连接：利用微软的ODBC技术进行数据库的连接，而后再JDBC技术访问ODBC技术进行数据库的开发； - 处理流程：程序→JDBC→ODBC→数据库，操作性能很差，这种技术为Java默认支持的技术，不需要做任何额外的配置即可实现。 JDBC连接：直接利用JDBC进行数据库的连接处理； - 处理流程：程序→JDBC→数据库，这种连接一般只连接本地数据库服务。 ***JDBC网络连接***：通过特定的网络协议连接指定的数据库服务； - 处理流程：程序→JDBC→网络数据库（IP地址、端口）。 JDBC协议连接：自己通过编写指定的协议操作实现数据库的访问； 数据库连接 通过结构可以发现，整个JDBC设计实现的就是一个工厂类的处理机实现制。DriverManager是一个工厂，不同数据库生产商利用JDBC提供的标准（接口）各自的数据库处理操作。 Statement接口简介 当获取了java.sql.Connection接口对象后，那么其核心的目的一定是为了进行数据库的操作，数据库的开发操作应该使用标准sql语句来完成，所以需要有一个SQL的执行器，而执行器就可以利用Statement接口完成。 java.sql.Statement是JDBC中提供的数据库的操作接口，利用其可以实现数据的更新与查询的处理操作，该接口定义如下： public interface Statement extends Wrapper, AutoCloseable 该接口是AutoCloseable子接口，所以可以得出结论：每一次进行数据库操作完成后，都应该关闭Statement操作，即一条SQL的执行一定是一个Statement接口对象，但是如果想要获取Statement接口对象，那么必须依靠Connection接口提供的方法完成。 获取Statement对象：Statement createStatement() throws SQLException - 此时抛出的SQLException是JDBC数据库开发之中的最大异常； 当获取了Statement接口对象之后，就可以使用SQL进行处理了，而这里需要两个方法的支持： 数据更新处理（Insert、Update、Delete）： int executeUpdate​(String sql) throws SQLException（ 数据查询处理（Select、统计查询、复杂查询）： ResultSet executeQuery​(String sql) throws SQLException 这两个数据库的操作方法中都需要接收SQL字符串，也就是说Statement接口可以直接使用SQL语句实现开发。 数据更新处理返回的是SQL执行后的影响行数。 ResultSet对象时保存在内存中的，如果说查询数据的返回结果过大，那么程序可能会出现性能上或其他方面的问题。 Statement接口操作的问题 以更新操作为例，在Statement接口中如果想要执行SQL语句，那么一定要通过字符串实现SQL结构的定义，但是这种定义如果要结合到用户输入数据情况下，就可能会存在问题。 利用Statement执行的SQL语句问题有如下三种： 不能很好的描述出日期类型； 需要进行SQL语句的拼接处理，而导致SQL语句的编写与维护困难； 对于一些敏感的字符数据无法进行合理拼凑； 虽然Statement可以操作数据库，但是其在操作的过程中并没有那么方便，而其最大的弊端：需要进行SQL语句拼接。 PreparedStatement操作数据库 为了解决Statement接口存在的SQL执行问题，所以在java.sql包中又提供了一个Statement的子接口：PreparedStatement，这个接口最大的好处是可以编写正常的SQL（数据不再和SQL语法混合在一起），同时利用占位符形式，在SQL正常执行完毕后可以进行数据的设置。PreparedStatement接口定义如下： public interface PreparedStatement extends Statement 如果要想获得PreparedStatement接口的实例，依然需要通过Connection接口来实现创建方法： 创建PreparedStatement接口对象： PreparedStatement prepareStatement​(String sql)throws SQLException 由于SQL语句已经在创建PreparedStatement接口对象时提供了，所以在执行数据库操作时也要更换方法： 数据库更新：int executeUpdate() throws SQLException 数据库查询：ResultSet executeQuery() throws SQLException&#96; PreparedStatement 在JDBC中不管使用的是PreparedStatement设置的日期时间还是使用ResultSet获取的日期时间实际上都是java.util.Date的子类，也就是说是如下的对应关系。 &amp;emsp在进行全部数据查询的时候如果返回的内容过多则一会造成内存的大量占用，此时可以使用分页的形式实现数据的查询处理。","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/hello-world/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/hello-world/","excerpt":"This blog is just a test of system. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"This blog is just a test of system. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Test","slug":"Test","permalink":"https://blog.newimg.ltd/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://blog.newimg.ltd/tags/Test/"}]},{"title":"数字操作类","slug":"数字操作类","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/25/数字操作类/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C%E7%B1%BB/","excerpt":"该博客转载自温柔的养猫人，仅供学习参考。 Math数学计算类","text":"该博客转载自温柔的养猫人，仅供学习参考。 Math数学计算类 Math类的主要功能是进行数学计算的操作类，提供有基础的计算公式，这个类的构造方法被私有化了，而且该类之中提供的所有方法都是static型的方法，即：这些方法都可以通过类名称直接调用。 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; System.out.println(Math.abs(-10.1)); //获取绝对值：10.1 System.out.println(Math.max(10.2,20.3)); //获取最大值：20.3 System.out.println(Math.log(5)); //获取对数：1.6094379124341003 System.out.println(Math.round(15.1)); //四舍五入：15 System.out.println(Math.round(-15.5)); //四舍五入：-15 System.out.println(Math.round(-15.51)); //四舍五入：-16 System.out.println(Math.pow(10.2,20.2)); //幂:2.364413713591828E20 &#125; &#125; 虽然在Math类里面提供有四舍五入的处理方法，但是这个四舍五入在进行处理的时候是直接将小数点后的所有位进行进位处理，这个肯定不方便，那么现在最方便的做法是可以实现指定位数的保留。 范例：自定义的四舍五入功能 class MathUtil &#123; private MathUtil() &#123;&#125; /** * 实现数据的四舍五入操作 * @param num 要进行四舍五入操作的数字 * @param scale 四舍五入保留的小数位数 * @return 四舍五入处理后的结果 */ public static double round(double num, int scale) &#123; return Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale); &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; System.out.println(MathUtil.round(19.86273,2)); //19.86 &#125; &#125; Math类里面提供的基本上都是基础的数学公式，需要的时候需要自己重新整合。 Random随机数生成类java.util.Random类的主要功能是产生随机数，这个类主要依靠内部提供的方法来完成： 产生一个不大于边界的随机正整数：public int nextInt(int bound)； 范例：产生随机数 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Random rand =new Random(); for (int x = 0; x &lt; 10; x++) &#123; System.out.print(rand.nextInt(10)+\"、\");//6、2、2、0、5、7、3、1、9、5、 &#125; &#125; &#125; 在国内有一款36选7的彩票，那么就可以利用Random实现随机生成彩票号。范例：随机生成彩票号 对于这里面的数字肯定不能有0，不能够重复。 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; int data[] = new int[7]; //开辟7个大小的空间 Random rand = new Random(); int foot = 0; //操作data脚标 while (foot &lt; 7) &#123; //选择7个数字 int num = rand.nextInt(37); //生成一个数字 if (isUse(num, data)) &#123; //该数字现在可以使用 data[foot++] = num; //保存数据 &#125; &#125; java.util.Arrays.sort(data); for (int x = 0; x &lt; data.length; x ++) &#123; System.out.print(data[x]+ \"、\"); //7、8、9、18、19、25、34 &#125; &#125; /** * 判断传入的数字是否为0以及是否在数组中存在 * * @param num 要判断的数字 * @param temp 已存在的数据 * @return 如果该数字不是0并且可以使用返回true, 否则返回false */ public static boolean isUse(int num, int[] temp) &#123; if (num == 0) &#123; return false; &#125; for (int x = 0; x &lt; temp.length; x ++) &#123; if (num == temp[x] ) &#123; return false; &#125; &#125; return true; &#125; &#125; 以后这种随机的操作都可以利用Random来处理。 大数字操作类在进行数学计算的过程里面还有一个大数字的操作类，可以实现海量数字的计算（能提供的也只是基础计算），现在假设一个数字很大，超过了double的范围，那么这个时候并没有任何一种数据类型可以保存下此类的内容，最早的时候只能通过String保存。 String strA=\"120\"; String strB=\"230\"; 如果现在想要进行加法计算，那么就需要逐位拆分，每一位自己计算，而后自己独立控制进位处理，那么这样的开发难度是非常高的，所以为了解决这类问题，提供有两个大数字的操作类：BigInteger、BigDecimal。 大数字类 之前分析了，当数字很大的时候只能利用字符串描述数字操作，所以这一点可以观察两个大数字操作类的构造方法： BigInteger类构造：public BigInteger(String val)； BigDecimal类构造： public BigDecimal(String val)； 范例：使用BigInteger实现四则运算 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; BigInteger bigA=new BigInteger(\"234234234234234234\"); BigInteger bigB=new BigInteger(\"23423423\"); System.out.println(\"加法操作：\"+bigA.add(bigB)); //234234234257657657 System.out.println(\"减法操作：\"+bigA.subtract(bigB)); //234234234210810811 System.out.println(\"乘法操作：\"+bigA.multiply(bigB)); //5486567549549549544062982 System.out.println(\"除法操作：\"+bigA.divide(bigB)); //10000000180 &#125; &#125; 需要注意的是，虽然提供有大数字操作类，但是整体的操作之中还是需要考虑到一个性能问题。范例：观察性能问题 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; BigInteger bigA=new BigInteger(\"234234234234234234\"); System.out.println(bigA.pow(Integer.MAX_VALUE)); &#125; &#125; cpu处理 此时的计算过程是非常缓慢的，所以任何的电脑是有极限的。既然在进行数学除法的时候有可能无法进行整除处理，那么就可以使用其他的除法计算来求出余数： 求余：public BigInteger[] divideAndRemainder(BigInteger val)；数组第一个元素为商，第二个为余数； 范例：求余除法 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; BigInteger bigA = new BigInteger(\"234234234234234234\"); BigInteger bigB = new BigInteger(\"23423423\"); BigInteger[] result = bigA.divideAndRemainder(bigB); System.out.println(\"商：\" + result[0] + \"、余数：\" + result[1]);//商：100000000180、余数：18018094 &#125; &#125; 如果在开发中真进行计算的时候，该计算没有超过基本数据类型所包含的位数强烈不建议使用大数字类，因为这种计算性能很差。 BigDecimal操作形式和BigInteger是非常类似的，都有基础的数学支持。范例：使用BigDecimal计算 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; BigDecimal bigA = new BigDecimal(\"32890234890\"); BigDecimal bigB = new BigDecimal(\"1892039\"); System.out.println(\"加法计算：\"+bigA.add(bigB)); //32892126929 BigDecimal result[] = bigA.divideAndRemainder(bigB); System.out.println(\"除法计算：商：\" + result[0] + \"、余数：\" + result[1]);//商：17383、余数：920953 &#125; &#125; 但是在使用BigDecimal的时候有一个数据进位的问题，在这个类里面定义有如下的除法计算： 除法计算：public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)； 范例：使用BigDecimal实现四舍五入处理 class MathUtil &#123; private MathUtil() &#123;&#125; /** * 实现数据的四舍五入操作 * * @param num 要进行四舍五入操作的是数字 * @param scale 四舍五入保留的小数位数 * @return 四舍五入处理后的结果 */ public static double round(double num, int scale) &#123; return new BigDecimal(num).divide(new BigDecimal(1.0), scale, RoundingMode.HALF_UP).doubleValue(); &#125; &#125; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; System.out.println(MathUtil.round(19.6352, 2)); //19.64 &#125; &#125; Math的处理由于使用的都是基本数据类型，所以性能一定要高于大数字处理类。","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"algorithm","slug":"java/algorithm","permalink":"https://blog.newimg.ltd/categories/java/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"结构体及链表初始","slug":"结构体及链表初识","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"2021/11/25/结构体及链表初识/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%8A%E9%93%BE%E8%A1%A8%E5%88%9D%E8%AF%86/","excerpt":"","text":"相关定义结构体是一种复合类型 复合性： 结构体单元可以存储不同类型的数据 是一种自定义类型 使用 定义类型 → 通过类型分配结构体单元 → 使用单元 声明结构体类型struct 结构体名 &#123; 数据类型 成员1; 数据类型 成员2; ... &#125;; 说明 该定义为类型定义 类型名struct 结构体名 struct stu &#123; int x; double y; char z; &#125;; - 占用空间大小（数据对齐原则） ## 通过类型声明变量 - &#96;struct 结构体名 变量&#96; 例： &#96;&#96;&#96;c struct Stu s1, s2; 通过结构体变量引用分量成员 结构体变量名.成员名 成员运算符 运算符：. 优先级：同[]、-&gt; 例： s1.x = 3; s1.y = 5.7; s1.z = 'A'; 例2： 将结构体变量s1的存到s2中 s2.x = s1.x; s2.y = s1.y; s2.z = s1.z; //或采用下方语句 //s2 = s1; 两个同类型的结构体变量之间可以直接赋值 声明结构体指针变量，指向结构体单元 struct 结构体名* 指针变量 例： struct Stu* p; 使指针变量有指向 指针变量 = &amp;结构体变量 例： p = &amp;s1; 通过指针引用结构体成员 指针变量-&gt;成员名 指针变量指向的某个结构体单元内的成员 例： struct Stu s1; struct Stu* p; p = &amp;s1; p->x = 3; //(*&amp;s1).x = 3; p->y = 5.7; p->z = 'A'; 结构体数组的定义 struct 结构体名 数组名[个数] 例： struct Stu s[10]; 例2： #include &lt;stdio.h> #include &lt;string.h> struct Stu &#123; int sno; char name[20]; double per; &#125;; void SumScore(struct Stu s[], double* pm) &#123; for (int i = 0; i &lt; 5; i++) &#123; *pm += s[i].per; &#125; &#125; struct Stu* fmax (struct Stu s[]) &#123; struct Stu *p, *pMax; int Max, x; pm = s; for (p = s + 1; p &lt; s + 5; p++) &#123; x = p->per; &#125; &#125; int main(void) &#123; struct Stu a[5]; char n[20]; double sum; struct Stu* pMax; for (int i = 0; i &lt; 5; i++) &#123; a[i]->sno = i + 1; gets(n); strcpy(a[i].name, n); scanf(\"%lf\", &amp;a[i].per); &#125; SumScore(a, &amp;sum); printf(\"%lf\", sum / 5); &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"knowledge","slug":"c/knowledge","permalink":"https://blog.newimg.ltd/categories/c/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"输出螺旋数列 C语言解决方案","slug":"输出螺旋数列 C语言解决方案","date":"2021-11-24T16:00:00.000Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"2021/11/25/输出螺旋数列 C语言解决方案/","link":"","permalink":"https://blog.newimg.ltd/2021/11/25/%E8%BE%93%E5%87%BA%E8%9E%BA%E6%97%8B%E6%95%B0%E5%88%97%20C%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"输出螺旋数列 C语言解决方案题目自然界中我们可以常见到一些像螺，蜗牛之类的生物，他们的壳都有一道非常优美的曲线——阿基米德螺线（r&#x3D;aθ）。这里我想让你帮我用程序写出N阶的型如阿基米德螺线的螺旋数组。例如3阶的螺旋数组为：1 2 38 9 47 6 5 解答（非最优解）^1","text":"输出螺旋数列 C语言解决方案题目自然界中我们可以常见到一些像螺，蜗牛之类的生物，他们的壳都有一道非常优美的曲线——阿基米德螺线（r&#x3D;aθ）。这里我想让你帮我用程序写出N阶的型如阿基米德螺线的螺旋数组。例如3阶的螺旋数组为：1 2 38 9 47 6 5 解答（非最优解）^1 首先，我们需要获得螺旋数列的阶数并定义二维数组，举例如下： &#x2F;* 设我们需要n阶的螺旋数组 *&#x2F; int n; scanf(&quot;%d&quot;, &amp;n); int a[n][n]; 其次，我们需要找到螺旋数列的规律，它有四种运动方向，分别是上、下、左、右，而我们可以利用C语言指针的特性给定义好的数组赋值，举例如下： &#x2F;* 向右赋值 *&#x2F; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; &#x2F;&#x2F;先赋值，以避免第一个元素漏赋值 p +&#x3D; 1; &#x2F;&#x2F;将指针指向下一个需要赋值的元素 t++; &#x2F;&#x2F;为变量t加1，形成公差为一且递增的数列 *p &#x3D; t; &#x2F;&#x2F;为变量赋值，避免该行最后一个元素漏赋值 &#125; &#x2F;* 向下赋值 *&#x2F; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; &#x2F;&#x2F;先赋值，以避免第一个元素漏赋值 p +&#x3D; n; &#x2F;&#x2F;将指针指向下一个需要赋值的元素 t++; &#x2F;&#x2F;为变量t加1，形成公差为一且递增的数列 *p &#x3D; t; &#x2F;&#x2F;为变量赋值，避免该行最后一个元素漏赋值 &#125; &#x2F;* 向右赋值 *&#x2F; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; &#x2F;&#x2F;先赋值，以避免第一个元素漏赋值 p -&#x3D; 1; &#x2F;&#x2F;将指针指向下一个需要赋值的元素 t++; &#x2F;&#x2F;为变量t加1，形成公差为一且递增的数列 *p &#x3D; t; &#x2F;&#x2F;为变量赋值，避免该行最后一个元素漏赋值 &#125; &#x2F;* 向上赋值 *&#x2F; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; &#x2F;&#x2F;先赋值，以避免第一个元素漏赋值 p -&#x3D; n; &#x2F;&#x2F;将指针指向下一个需要赋值的元素 t++; &#x2F;&#x2F;为变量t加1，形成公差为一且递增的数列 *p &#x3D; t; &#x2F;&#x2F;为变量赋值，避免该行最后一个元素漏赋值 &#125; 之后，由于我们每次需要切换赋值模式和赋值数量，所以我们需要加入一些判断条件以使我们每次赋值有效。完整代码及注释如下： #include &lt;stdio.h&gt; int main(void) &#123; int n; scanf(&quot;%d&quot;, &amp;n); int m &#x3D; n + n - 1; int q &#x3D; n - 1; int t &#x3D; 1; int a[n][n]; int *p; p &#x3D; &amp;a[0][0]; int time &#x3D; 1; &#x2F;* 获取相关值并进行相关定义及初始化 *&#x2F; for (int i &#x3D; 0; i &lt; (n + n - 1); i++) &#123; if (time % 4 &#x3D;&#x3D; 1) &#123; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; p +&#x3D; 1; t++; *p &#x3D; t; &#125; &#125; else if (time % 4 &#x3D;&#x3D; 2) &#123; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; p +&#x3D; n; t++; *p &#x3D; t; &#125; &#125; else if (time % 4 &#x3D;&#x3D; 3) &#123; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; p -&#x3D; 1; t++; *p &#x3D; t; &#125; &#125; else if (time % 4 &#x3D;&#x3D; 0) &#123; for (int j &#x3D; 0; j &lt; q; j++) &#123; *p &#x3D; t; p -&#x3D; n; t++; *p &#x3D; t; &#125; &#125; if (time % 2 &amp;&amp; time !&#x3D; 1) q -&#x3D; 1; &#x2F;* 逐次缩减 *&#x2F; time++; &#125; &#x2F;* 定义大循环，循环次数为形成该螺旋数组所需的步骤 *&#x2F; for (int i &#x3D; 0; i &lt; n; i++) &#123; for (int j &#x3D; 0; j &lt; n; j++) &#123; printf(&quot;%5d&quot;, a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"2020-11-29-题目练习总结","slug":"2020-11-29-题目练习总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/2020-11-29-题目练习总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/2020-11-29-%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"[^1]: 本人编程萌新，解法仅供参考。题目来源见注解 。 第一题Sky数 ^2","text":"[^1]: 本人编程萌新，解法仅供参考。题目来源见注解 。 第一题Sky数 ^2 题目熊熊学长从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数，它的十进制数表示，其四位数字之和为2+9+9+2&#x3D;22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。熊熊学长非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。 Input输入含有一些四位正整数，如果为0，则输入结束。 Output若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。 Sample Input299212340 Sample Output2992 is a Sky Number.1234 is not a Sky Number. 分析将该数字利用 scanf 接收，并将其分别转化为十二、十六进制（可以利用函数），并比较该数在不同进制下各位之和（注意比较时的逻辑问题），相同输出 #n is a Sky Number. ，反之输出 #n is not a Sky Number. 。 解答#include &lt;stdio.h> int main(void) &#123; int a[10000]; int count = 0, val1, val2, val3; int num1, num2, num3; for (int i = 0; 1; i++) &#123; scanf(\"%d\", &amp;a[i]); if (a[i] == 0) &#123; break; &#125; count++; &#125; /* 以上是定义及输入部分 */ for (int i = 0; i &lt; count; i++) &#123; val1 = val2 = val3 = 0; num1 = num2 = num3 = 1; for (int j = 0; 1; j++) &#123; val1 += a[i] / num1 % 10; val2 += a[i] / num2 % 12; val3 += a[i] / num3 % 16; num1 *= 10; num2 *= 12; num3 *= 16; if (a[i] / num1 == 0 &amp;&amp; a[i] / num2 == 0) &#123; break; &#125; &#125; /* 进制转换 */ if (val1 == val2 &amp;&amp; val2 == val3) &#123; printf(\"%d is a Sky Number.\\n\", a[i]); &#125; else &#123; printf(\"%d is not a Sky Number.\\n\", a[i]); &#125; /* 比较并输出 */ &#125; return 0; &#125; 第二题哥德巴赫来了可能有用吧^3题目倩倩学姐想把一个偶数拆成两个不同素数的和，你有有几种拆法呢？ Input输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。 Output对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。 Sample Input30260 Sample Output32 分析方法一：暴力枚举法（易TLE） 先将该组偶数接收（接受结果为0时利用 break; 跳出），并逐一暴力尝试（注意简化判断素数时的方法，判素数时可以使 i &lt;= sqrt&#123;max&#125;），并批量输出该组数（注意格式）。 方法二：打表 将范围内的所有素数判断出来（同样记得简化），接收该组数并判断拆法，输出答案。 解答#include &lt;stdio.h> int pend(int a) &#123; for (int i = 2; i * i &lt;= a; i++) &#123; if (!(a % i)) &#123; if (i != a) &#123; return 0; &#125; &#125; &#125; return 1; /* 利用函数判断a是不是素数 */ &#125; int main(void) &#123; int a[501]; int count = 0, b, c, ans; for (int i = 0; 1; i++) &#123; scanf(\"%d\", &amp;a[i]); if (a[i] == 0) &#123; break; &#125; count++; &#125; /* 定义及输入部分 */ for (int i = 0; i &lt; count; i++) &#123; b = 3, ans = 0; for (int j = 3; j &lt; a[i] / 2; j++) &#123; if (pend(j) &amp;&amp; pend(a[i] - j) &amp;&amp; b != c) &#123; ans++; &#125; &#125; printf(\"%d\\n\", ans); &#125; /* 判断及输出部分 */ return 0; &#125; 第三题咦！这是嘛呀！^4题目现在我们有两个正整数A和B,请找出一个正整数C,使得式子((A xor C) &amp; (B xor C))最小(xor是异或运算)。当然,如果使得式子最小的C为0时,请你输出1。 Input第一行输入T,代表有T组数据。接下来每一行输入两个数A,B(A,B&lt;&#x3D;2^32) Output对于每一组数据输出一个正整数C Sample Input13 5 Sample Output1 分析本题需了解位运算相关知识&amp;：按位相与xor(^)：按位异或真值表 a b b a&amp;b a^b 值 1 1 1 1 0 0 1 0 0&#x2F;1 0 1 0 0 1 0&#x2F;1 0 1 0 0 0 1 0 0 0 之后开始分析本题 由上表知，若要使((A ^ C) &amp; (B ^ C))最小，则只需 C = A &amp; B 。 若C &#x3D; 0，则输出1，反之输出C。 解答#include &lt;stdio.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); long long a[1000][2]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lld%lld\", &amp;a[i][0], &amp;a[i][1]); &#125; /* 定义及输入部分 */ for (int i = 0; i &lt; n; i++) &#123; long long int c = a[i][0] &amp; a[i][1]; if (!c) printf(\"1\\n\"); else printf(\"%lld\\n\", c); &#125; /* 计算及输出部分 */ return 0; &#125; 第四题倩姐的自我突破^5问题倩倩学姐，一个大三的老阿姨呢，但是呢她还有一颗坚持竞赛的心。所以他碰到一个奥林匹克竞赛的数学问题，她搞不定很难受，决定暴饮暴食。聪明而优秀的学霸熊熊学长看到这一幕决定帮他解决这个问题。这个问题是：我们描述 K:k! &#x3D; 1 * 2 * ……* (k - 1) *k我们表示 S:S &#x3D; 1 * 1! + 2 * 2! + …. +(n - 1) * (n-1)!然后 S 对 n 去模是 ___________你将得到一个整数n.你需要计算 S 对 n 取模的值 输入第一行输入一个整数 T(T &lt; 1000), 表示测试用例的行数.对于每个测试用例，都有一行包含一个整数 n.保证 2 &lt;&#x3D; n &lt;&#x3D; 10^18 输出对于每个测试用例，打印一个整数 S 对 n 取模后的值. 提示第一个测试用例 S &#x3D; 1* 1!&#x3D; 1, 并且 1 的模 2 运算 1.第二个测试用例 S &#x3D; 11!+2 2!&#x3D; 5 , 并且 5 对 3 取模是 2. Sample Input223 Sample Output12 分析1 + S(n)&#x3D; 1 + 1 × 1! + 2 × 2! + ⋯ + (n − 1) × (n − 1)!&#x3D; 2 × 1! + 2 × 2! + ⋯ + (n − 1) × (n − 1)!&#x3D; 2! + 2 × 2! + ⋯ + (n − 1) × (n − 1)!&#x3D; 3 × 2! + ⋯ + (n − 1) × (n − 1)!&#x3D; 3! + 3 × 3! + ⋯ + (n − 1) × (n − 1)! &#x3D; 4 × 3! + ⋯ + (n − 1) × (n − 1)!&#x3D; ⋯ &#x3D; (n − 1)! + (n − 1) × (n − 1)! &#x3D; n × (n − 1)!&#x3D; n! S(n) mod n&#x3D; (n! − 1) mod n&#x3D; (n! + n − 1) mod n&#x3D;n! mod n + (n − 1) mod n&#x3D; n − 1 利用数学知，我们只需接收n，并输出n - 1。 解答#include &lt;stdio.h> int main(void) &#123; long long n, ans; scanf(\"%lld\", &amp;n); while (n--) &#123; scanf(\"%lld\", &amp;ans); printf(\"%lld\\n\", ans - 1); &#125; return 0; &#125; 第五题看看就好，劝一下自己^6问题古希腊数学家毕达哥拉斯在自然数研究中发现，220的所有真约数(即不是自身的约数)之和为：1+2+4+5+10+11+20+22+44+55+110＝284。而284的所有真约数为1、2、4、71、 142，加起来恰好为220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。你的任务就编写一个程序，判断给定的两个数是否是亲和数 Input输入数据第一行包含一个数M，接下有M行，每行一个实例,包含两个整数A,B； 其中 0 &lt;&#x3D; A,B &lt;&#x3D; 600000 ; Output对于每个测试实例，如果A和B是亲和数的话输出YES，否则输出NO。 Sample Input2220 284100 200 Sample OutputYESNO 分析方法一：（易TLE） 输入、分别计算两数的真约数之和并比较、输出。 方法二： 将范围内的数的真约数和打表，输入、比较、输出。 解答#include &lt;stdio.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); int a[1000][2]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;a[i][0], &amp;a[i][1]); &#125; /* 定义及输入部分 */ int b1, b2; for (int i = 0; i &lt; n; i++) &#123; b1 = b2 = 0; for (int j = 1; j &lt; a[i][0]; j++) &#123; if (!(a[i][0] % j)) b1 += j; &#125; for (int j = 1; j &lt; a[i][1]; j++) &#123; if (!(a[i][1] % j)) b2 += j; &#125; /* 比较部分 */ if (b1 == a[i][1] &amp;&amp; b2 == a[i][0]) printf(\"YES\\n\"); else printf(\"NO\\n\"); /* 输出部分 */ &#125; return 0; &#125; 第六题熊熊的尝试^7问题熊熊学长一天在实验室里闲的没事。他想做点游戏打发一下时间。他就拉上了和他同样无聊的柴柴学长。两位学长要玩的游戏是什么呢？很简单，它是这样定义的：1、 本游戏是一个二人游戏;2、 有一堆石子一共有n个；3、 两人轮流进行;4、 每走一步可以取走1…m个石子；5、 最先取光石子的一方为胜；如果游戏的双方使用的都是最优策略，请输出哪个人能赢。 Input输入数据首先包含一个正整数C(C&lt;&#x3D;100)，表示有C组测试数据。每组测试数据占一行，包含两个整数n和m（1&lt;&#x3D;n,m&lt;&#x3D;1000），n和m的含义见题目描述。 Output如果先走的人能赢，请输出“first”，否则请输出“second”，每个实例的输出占一行。 Sample Input223 24 3 Sample Outputfirstsecond 分析该题为巴什博弈（详见链接） 若n能被m + 1整除，此时后手有必胜策略，若n不能被m + 1整除，此时新手有必胜策略。 解答#include &lt;stdio.h> int n, b; int main(void) &#123; scanf(\"%d\", &amp;n); int a[1000][2]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;a[i][0], &amp;a[i][1]); &#125; /* 定义及输入部分 */ for (int i = 0; i &lt; n; i++) &#123; if (a[i][0] % (a[i][1] + 1) == 0) &#123; printf(\"second\\n\"); &#125; else &#123; printf(\"first\\n\"); &#125; /* 计算及输出部分 */ &#125; return 0; &#125; 第七题该烂怂塔，有啥看的^8问题熊熊学长是个正儿八经的陕西西安人，那烂怂大雁塔看都不想看，但是他突然发现了这道题，就更不想看那烂怂大雁塔。请你写个程序帮他解决一下问题。有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;&#x3D; N &lt;&#x3D; 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。 Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。 Sample Input1573 88 1 02 7 4 44 5 2 6 5 Sample Output30 分析该题可以利用dp思想（比较麻烦），同时可以利用由下到上的思想来实现最优策略。及由下到上取最大值（贪心）。 解答#include &lt;stdio.h> #include &lt;algorithm> int a[1000][1000]; int b[1000]; int sum; int main(void) &#123; int n, m, t, o, temp; scanf(\"%d\", &amp;n); for (int k = 0; k &lt; n; k++) &#123; scanf(\"%d\", &amp;m); o = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; o; j++) &#123; scanf(\"%d\", &amp;a[i][j]); &#125; o++; &#125; /* 定义及输入部分 */ t = m; for (int j = 0; j &lt; m; j++) &#123; for (int i = 0; i &lt; t; i++) &#123; temp = std::max(a[m - j][i], a[m - j][i + 1]); a[m - j - 1][i] += temp; &#125; t--; &#125; b[k] = a[0][0]; /* 计算及储存部分 */ &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d\\n\", b[i]); &#125; /* 输出部分 */ return 0; &#125; 第八题Tyloo的S1mple本人^9题目熊熊是一名csgo玩家，在沙二驰骋多年的他，显然已经对这个地方了如指掌。他恐怖的定位和风骚的身法以及高超的战术让他的队友后悔来到这个地方。尤其是他的大狙，当他扛着笨重的awp走到中门时，每一声枪响都会有人应声倒地。但是熊熊有个奇怪的癖好，他每一次只杀奇数个数的人，一杀他嫌太少，九杀又太多，所以他每一局他只会打出三杀，五杀或七杀。现在你在他旁边看他打游戏，你看到他杀了n个人，你现在想知道他分别打出了多少个三杀，五杀或七杀。 Input第一行的整数 t（1&lt;&#x3D;t&lt;&#x3D;1000）— 测试用例的个数.每个测试用例只有一个输入数据 — lrh杀人的总数 n（1&lt;&#x3D;n&lt;&#x3D;1000） Output如果对于某个测试样例，没有正确的答案，则输出 -1.否则，输出3个正整数-三杀的个数，五杀的个数，七杀的个数 — 如果存在多个情况，输出任意一种即可 Sample Input43067414 Sample Output2 2 27 5 3-10 0 2 分析该题利用由大到小的思想进行解题，具体解释详见代码注释。 解答#include &lt;stdio.h> int main(void) &#123; int n; scanf(\"%d\", &amp;n); int a[1001]; int b, c, d; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; /* 定义及输入部分 */ for (int i = 0; i &lt; n; i++) &#123; d = 0; for (int j = 0; j &lt;= a[i] / 7; j++) &#123; b = a[i] - j * 7; for (int k = 0; k &lt;= b / 5; k++) &#123; c = b - k * 5; if (!(c % 3)) &#123; printf(\"%d %d %d\\n\", c / 3, k, j); d = 1; break; &#125; &#125; if (d) &#123; break; &#125; &#125; /* 分别判断7，5，3杀的数量，并尽量使3杀最多，以简化运算 */ if (d == 0) &#123; printf(\"-1\\n\"); &#125; &#125; return 0; &#125; 第九题可鞥吧^10题目你有 n个 桶放在一排 , 从左到右开始编号分别为1~n. 最初, 第 i 桶装的水是 ai 升.你可以把水从一个桶倒到另一个桶。 在这个过程中, 你可以两个选择两个桶 x 和y (第 x个桶不应该为空) 然后从桶x 向桶 y 倒水(可能是所有的水).你可以假设桶的容量是无限的，所以你可以在每个桶里倒入任何数量的水。如果最多可以倒水 k 次.计算桶中最大和最小水量之间的最大可能差。举例如果你有四个桶，每个桶里装5升水，k&#x3D;1，你可以从第二个桶里倒5升水到第四个桶里，所以桶里的水量是[5,0,5,10]，最大和最小的差值是10；如果所有的桶都是空的，你就不能做任何操作，所以最大和最小的量之差仍然是0。 Input第一行包含一个整数 t (1 &lt; t &lt; 1000) — 测试用例的数量每个测试用例的第一行包含两个整数 n 和 k(1 &lt;&#x3D; k &lt; n &lt; 2&lt;&#x3D; 10^5) — 桶数和可以浇注的数量。第二行包含 n 整数 a1, a2, …… an (0 &lt;&#x3D;ai &lt;&#x3D;10^9), 其中ai 是第 i 个桶的初始水量。保证 n 个以上测试用例的总和不超过 2 * 10^5. OutputF对于每个测试用例，如果最多可以倒水k 次，请打印桶中最大和最小水量之间的最大可能差值。 Sample Input24 15 5 5 53 20 0 0 Sample Output100 分析先进行排序，若k不等于0，则后k个元素加起来便是最大可能差值，若等于0，则最后整数中最大数和最小数的差便是最大可能差值。 解答#include &lt;stdio.h> #include &lt;algorithm> int main(void) &#123; long long t, n, k, sum; scanf(\"%lld\", &amp;t); long long a[200000]; long long b[1000]; for (int i = 0; i &lt; t; i++) &#123; sum = 0; scanf(\"%lld%lld\", &amp;n, &amp;k); for (int j = 0; j &lt; n; j++) &#123; scanf(\"%lld\", &amp;a[j]); &#125; /* 定义及输入部分 */ std::sort(a, a + n); sum = a[n - 1]; for (int j = 0; j &lt; k; j++) &#123; sum += a[n - j - 2]; &#125; if (!k) &#123; b[i] = sum - a[0]; &#125; else &#123; b[i] = sum; &#125; /* 计算部分 */ &#125; for (int i = 0; i &lt; t; i++) &#123; printf(\"%lld\\n\", b[i]); &#125; /* 输出部分 */ return 0; &#125; 第十题最后是啥呢^11问题「融合」是《游戏王》集换式卡牌游戏中的一张通常魔法卡，是最早对融合怪兽进行融合召唤的魔法卡，也是进行融合召唤的泛用魔法卡。​现在zwt也想练习一下融合，他的目标转向了数组每次zwt可以选择两个不同的数字，并且大喊一声“フュージョン！！！”，然后这两个数字就会融合，变成他们和的一半（向上取整）放到数组里现在有一个序列1,2,3,4,……..,n，zwt想知道他要施法几次，每一步选择哪几个数字，这个数组才能变成一个数，并且使得这个最后留下的数字最小​如n&#x3D;4,​1.选择a&#x3D;2,b&#x3D;3,数组变为[1,3,3]​2.选择a&#x3D;3,b&#x3D;3,数组变为[1,3]​3.选择a&#x3D;1,b&#x3D;3,数组变为[2]​如果有多种方案，输出任意一种 Input第一行输入位t[1,1000]，表示有t组数据每组数据的第一行为n[2,200000]n的总和不会超过200000 Output对于每组数据输出最后留下的最小的那个数字之后n-1行依次输出步骤 Sample Input14 Sample Output22 43 33 1 分析从大到小选择两个数，并按规则计算，最后答案恒为2。 解答#include &lt;stdio.h> int a[1000]; int c[2000000]; int main(void) &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; int b = a[i]; for (int j = 0; j &lt; b; j++) &#123; c[j] = j + 1; &#125; printf(\"2\\n\"); for (int j = 0; j &lt; b - 1; j++) &#123; printf(\"%d %d\\n\", c[b - j - 2], c[b - j - 1]); c[b - j - 2] = (c[b - j - 2] + c[b - j - 1]) / 2 + (c[b - j - 2] + c[b - j - 1]) % 2; &#125; &#125; return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"C Primer Plus 第12章总结","slug":"C-Primer-Plus-第12章总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/C-Primer-Plus-第12章总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/C-Primer-Plus-%E7%AC%AC12%E7%AB%A0%E6%80%BB%E7%BB%93/","excerpt":"本人编程萌新，见解仅供参考。 储存类别（详见链接）","text":"本人编程萌新，见解仅供参考。 储存类别（详见链接） static长期存在静态存储区，直到程序结束静态局部变量是放在静态存储区内分配存储单元的，在整个程序运行期间都不释放，跟全局变量一样长期占用内存。 auto随着函数的进栈和出栈而创建和销毁我们编写程序的时候很少用auto定义变量，但其实我们之前定义的变量前面没有加static，编译系统会默认为是auto的存储方式，都会把变量存放在动态存储区。 extern长期存在静态存储区，直到程序结束用extern来声明全局变量，以扩展全局变量的作用域。 register离开函数值就会消失当今的优化编译系统能够识别使用频繁的变量，从而自动将这些变量放在寄存器中，而不需要设定为register。因此，用register声明变量是不必要的。例： /* main.c */ #include &lt;stdio.h> int count; extern void write_extern(); //跨文件调用support.c的write_extern函数 int main() &#123; count = 5; write_extern(); &#125; /* support.c */ #include &lt;stdio.h> extern int count; //跨文件调用main.c的count变量 void write_extern(void) &#123; printf(\"count is %d\\n\", count); &#125; /* main.c和support.c必须在同一个工程内 */ 列表 存储类别 存储期 作用域 链接 声明方式 自动 自动 块 无链接 块内 无关键词 寄存器 自动 块 无链接 块内 关键字regsiter 静态外部链接 静态 文件 外部 所有函数外 静态内部链接 静态 文件 外部 所有函数外 关键字static 静态无链接 静态 块 无 块内 关键字static 链接 链接属性 解释 外部external 在工程必须要有一个变量的定义、可以使工程中的不同文件可以使用相同的变量 内部internal 仅在该文件中可以使用，其他文件中不能访问 无设置none 无 内存管理（详见链接） 函数 描述 *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 上述函数多用于链表中，均处于&lt;stdlib.h&gt;中。 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> int main() &#123; char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 30 * sizeof(char) ); if( description == NULL ) &#123; fprintf(stderr, \"Error - unable to allocate required memory\\n\"); &#125; else &#123; strcpy( description, \"Zara ali a DPS student.\"); &#125; /* 假设您想要存储更大的描述信息 */ description = (char *) realloc( description, 100 * sizeof(char) ); if( description == NULL ) &#123; fprintf(stderr, \"Error - unable to allocate required memory\\n\"); &#125; else &#123; strcat( description, \"She is in class 10th\"); &#125; printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); /* 使用 free() 函数释放内存 */ free(description); &#125; 限定符const类const类型关键字声明的对象，其值不能通过赋值来递增，递减来修改。volatile类只有volatile的成员函数才能被volatile的对象调用。restrict类不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。_Atomic类该限定符是C11标准新增，当一个原子类型变量执行原子操作时，其它线程不能访问该变量。可用头文件stdatomic.h和Threads.h进行管理。","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"CPrimerPlus","slug":"c/CPrimerPlus","permalink":"https://blog.newimg.ltd/categories/c/CPrimerPlus/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"C Primer Plus 第14章总结","slug":"C-Primer-Plus-第14章总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/C-Primer-Plus-第14章总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/C-Primer-Plus-%E7%AC%AC14%E7%AB%A0%E6%80%BB%E7%BB%93/","excerpt":"本人编程萌新，见解仅供参考。 结构和其他数据形式","text":"本人编程萌新，见解仅供参考。 结构和其他数据形式 结构变量的建立、声明及初始化（链接）建立定义结构体前的准备阶段，此时应明确结构体中应含有的变量种类及数量。 声明申明结构体需要使用struct语句（与int、float相似但不同），声明样例如下： /* 声明样例1 */ struct tag &#123; member-list member-list member-list ... &#125; variable-list ; /* 声明样例2 */ struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id; &#125; book; 样例1中结构体tag包含多个变量，定义tag后其中含有多个成员。 样例2中结构体Books中包含title、author、subject、book_id四个变量，而最后一个分号前的book则定义了一个类型为Books的结构体变量book。 初始化初始化样例如下： /* 初始化样例 */ struct book library&#123; \"The Pious Pirate and Devious Damsel\", \"Renee Vivotte\", 1.95 &#125;; 该样例将结构体library中的变量初始化赋值。 结构体的数据对齐原则（链接）1： 整体空间是占用空间最大的成员（的类型）所占字节数的整数倍，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可。2： 数据对齐原则。内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍，如果不够则补齐，依次向后类推。某成员类型所占字节数超过4，如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则补齐。 结构成员的访问结构成员的访问需要使用成员访问运算符.例：library.value便是结构体变量library中的value变量。 /* 样例 */ struct book gift = &#123; .value= 25.99, .author = \"James Broadfoot\", .title = \"Rue for the Toad\"&#125;; 结构数组（链接）结构数组中的每一个元素都是struct book类型的结构体变量。 /* 结构体声明略 */ struct STUDENT stu[10]; stu[i]便是stu数组中的第i + 1个结构体变量。 嵌套结构（链接）在一个结构中包含另一个结构，以方便使用。 /* 样例 */ struct Student_info&#123; char *name; //姓 char *Branch_name; //名 struct Evaluation&#123; char *division; int hsc_score; int ssc_score; int roll_num; &#125;eval; &#125;student; 指向结构的指针（链接）当一个指针变量指向结构体时，我们就称它为结构体指针。 //结构体 struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125; stu1 = &#123; \"Tom\", 12, 18, 'A', 136.5 &#125;; struct stu *pstu = &amp;stu1; //结构体指针 使用 #include &lt;stdio.h> int main()&#123; struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125; stu1 = &#123; \"Tom\", 12, 18, 'A', 136.5 &#125;, *pstu = &amp;stu1; //读取结构体成员的值 printf(\"%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n\", (*pstu).name, (*pstu).num, (*pstu).age, (*pstu).group, (*pstu).score); printf(\"%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n\", pstu->name, pstu->num, pstu->age, pstu->group, pstu->score); return 0; &#125; -&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是-&gt;在C语言中的唯一用途。 运行结果： Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！ Tom的学号是12，年龄是18，在A组，今年的成绩是136.5！ #include &lt;stdio.h> struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125;stus[] = &#123; &#123;\"Zhou ping\", 5, 18, 'C', 145.0&#125;, &#123;\"Zhang ping\", 4, 19, 'A', 130.5&#125;, &#123;\"Liu fang\", 1, 18, 'A', 148.5&#125;, &#123;\"Cheng ling\", 2, 17, 'F', 139.0&#125;, &#123;\"Wang ming\", 3, 17, 'B', 144.5&#125; &#125;, *ps; int main()&#123; //求数组长度 int len = sizeof(stus) / sizeof(struct stu); printf(\"Name\\t\\tNum\\tAge\\tGroup\\tScore\\t\\n\"); for(ps=stus; ps&lt;stus+len; ps++)&#123; printf(\"%s\\t%d\\t%d\\t%c\\t%.1f\\n\", ps->name, ps->num, ps->age, ps->group, ps->score); &#125; return 0; &#125; 运行结果： Name Num Age Group Score Zhou ping 5 18 C 145.0 Zhang ping 4 19 A 130.5 Liu fang 1 18 A 148.5 Cheng ling 2 17 F 139.0 Wang ming 3 17 B 144.5 向函数传递结构的信息（链接）传递结构成员有时候我们并不需要对于结构体的全体成员进行访问，而只需要单个的或者个别几个的成员便足矣。这时候我们只需要将结构体的部分成员对函数及逆行传参即可。 #include&lt;stdio.h> struct person &#123; char name[10]; //成员姓名 char sex; //成员性别 double salary; //平日工资 double extra_gains; //外快收入 &#125;; double sum(double x,double y) &#123; return(x + y); &#125; int main() &#123; struct person Zhangsan = &#123; \"张三\", 'm', 10000, //张三日常划水的工资收入 10000000, //法外狂徒的外快收入 &#125; printf(\"张三一个月的收入有%.2f元\\n\",sum(Zhangsan.salary,Zhangsan.extra_gains)); return 0; &#125; 传递结构希望能够更加方便地对整个结构体进行操作，在现行的C语言标准下，是可以的，通过该函数后变化的只是结构体的副本，而非结构体本身。 #include&lt;stdio.h> struct person &#123; char name[10]; //成员姓名 char sex; //成员性别 double salary; //平日工资 double extra_gains; //外快收入 &#125;; double sum(struct person who) &#123; return(who.salary + who.extra_gains); &#125; int main() &#123; struct person Zhangsan = &#123; \"张三\", 'm', 10000, //张三日常划水的工资收入 10000000, //法外狂徒的外快收入 &#125;; printf(\"张三一个月的收入有%.2f元\\n\", sum(Zhangsan)); return 0; &#125; 传递结构的地址将指向结构体的指针作为参数传入到函数当中，由于指针本身只占有4个字节，内存较小，同时也能对结构体本身进行修改。 #include&lt;stdio.h> struct person &#123; char name[10]; //成员姓名 char sex; //成员性别 double salary; //平日工资 double extra_gains; //外快收入 &#125;; double sum(struct person who) &#123; who.extra_gains += who.salary; return( who.extra_gains); &#125; int main() &#123; struct person Zhangsan = &#123; \"张三\", 'm', 20000, //张三日常划水的工资收入 10000000, //法外狂徒的外快收入 &#125;; printf(\"张三一个月的收入有%.2f元\\n\", sum(Zhangsan)); printf(\"此时Zhangsan的extra成员的值为%f\\n\", Zhangsan.extra_gains); return 0; &#125; 复合字面量和结构（链接）复合字面量：通过复合字面量，我们可以在一个语句中给结构变量的多个成员变量赋值。 struct time this_time=&#123;3,29,55&#125;;//相当于定义了时间结构变量，并将其设置为3:29:55 struct time=&#123;.hour=12,.minut=10&#125;;//通过给出成员的名字，可以以任意顺序初始化结构变量的成员，或者只初始化部分成员 struct date birthdays[10]; //定义了一个结构数组，该数组包含了10个元素，每个元素都是一个结构类型变量 birthdays[1].month=8; birthdays[1].day=8; birthdays[1].year=2004; //将结构数组中的第二个元素赋值为2004年8月8日 checkdate(birthdays[1]); //将数组中第二个元素传递给checkdate函数 //checkdate的函数定义可能如下： void checkdate (struct date d0)&#123;&#125;//因为该函数需要接收struct date类型参数 伸缩型数组成员（链接）struct flex&#123; int count; double average; double scores[]; //伸缩型数组成员,利用molloc动态分配 &#125; #include &lt;stdio.h> #include &lt;stdlib.h> struct arr &#123; int count; double average; double scores[]; //伸缩型数组成员 &#125;; void show_arr(const struct arr *p); //不改变结构体中的内容，故使用关键字const int main (int argc, char *argv[]) &#123; int total = 0; int n = 5; int i; struct arr *p1; //为结构体分配存储空间 p1 = malloc(sizeof(struct arr) + n * sizeof(double)); p1->count = n; for (i = 0; i &lt; n; i++) &#123; p1->scores[i] = 20.0 - i; total += p1->scores[i]; &#125; p1->average = total / n; show_arr(pl); //释放在堆中动态分配的存储空间 free(p1); return 0; &#125; void show_arr(const struct arr *p) &#123; int i; printf (\"Scores : \"); for (i = 0; i &lt; p->count; i++) &#123; printf(\"%g \", p->scores[i]); &#125; printf (\"\\n\"); printf (\"Average: %g\\n\", p->average) ; &#125; 匿名结构（链接）C语言中，可以在结构体中声明某个联合体（或结构体）而不用指出它的名字，如此之后就可以像使用结构体成员一样直接使用其中联合体（或结构体）的成员。 把结构内容保存到文件中（链接）利用fprintf、fread和fwrite，对文件进行读写操作。 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。size – 这是要读取的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) ptr – 这是指向要被写入的元素数组的指针。size – 这是要被写入的每个元素的大小，以字节为单位。nmemb – 这是元素的个数，每个元素的大小为 size 字节。stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。 int fprintf(FILE *stream, const char *format, …) stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解见链接 链式结构（链接）二叉树及相关知识 联合体（共用体）简介（链接）结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union）。结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 枚举类型（链接）枚举enum是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。 #define MON 1 #define TUE 2 #define WED 3 #define THU 4 #define FRI 5 #define SAT 6 #define SUN 7 enum DAY &#123; MON=1, TUE, WED, THU, FRI, SAT, SUN &#125;; typedef简介（链接）typedef是C语言的一个重要的关键字，是为数据类型的定义一个新的名字。也就是类型的别名。 #include&lt;stdio.h> typedef int A; int main(void) &#123; A a = 10; printf(\"a = %d\", a); return 0; &#125; 其他复杂的声明 符号 含义 优先级 * 表示一个指针 低 () 表示一个函数 高 [] 表示一个数组 高 函数和指针（链接）可以把适当类型的函数的地址赋给函数指针，然后通过函数指针访问函数。 void ToUpper (char *); void ToLower (char *); int round (double); void (*Pf) (char *); pf = ToUpper; // 合法，ToUpper是函数ToUpper( )的地址 pf = ToLower; // 合法，ToLower是函数ToLower( )的地址 // pf = round; // 非法，round是错误类型的函数 // pf = ToLower(); // 非法，ToLower()不是地址","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"CPrimerPlus","slug":"c/CPrimerPlus","permalink":"https://blog.newimg.ltd/categories/c/CPrimerPlus/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Java面向对象编程","slug":"Java面向对象编程","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/Java面向对象编程/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"Java面向对象编程总结","text":"Java面向对象编程总结 Java环境配置链接 Java相关知识Java继承子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为 Java不支持多继承 Java重载重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） Java多态概念多态是同一个行为具有多个不同表现形式或形态的能力。(同一个事件发生在不同的对象上会产生不同的结果。) 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在必要条件 继承 重写 父类引用指向子类对象 Java抽象类概念在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类总结 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 Java封装概念在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 Java接口接口，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口可以继承。 Java枚举Java 枚举enum是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。 Java包概念为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 包的作用1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"oop","slug":"java/oop","permalink":"https://blog.newimg.ltd/categories/java/oop/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Linux运维-命令","slug":"Linux运维-命令","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/Linux运维-命令/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/Linux%E8%BF%90%E7%BB%B4-%E5%91%BD%E4%BB%A4/","excerpt":"链接","text":"链接 Linux相关命令command [-option] parameter1 parameter2 ... # 几个需要说明的地方： #（1）-option是命令的选项，选项又分为长选项和短选项。另外，有些选项还需要带参数 #（2）如上通用格式中的parameter1 parameter2...是命令的参数，不是选项的参数 #（3）有些命令或二进制程序还带有子命令 文件管理cat命令功能：cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。 cat [-AbeEnstTuv] [--help] [--version] fileName 参数说明： -n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； chattr命令功能：chattr命令用于改变文件属性。 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。 chattr [-RV][-v&lt;版本编号>][+/-/=&lt;属性>][文件或目录...] 参数 -R 递归处理，将指定目录下的所有文件及子目录一并处理。-v&lt;版本编号&gt; 设置文件或目录版本。-V 显示指令执行过程。+&lt;属性&gt; 开启文件或目录的该项属性。-&lt;属性&gt; 关闭文件或目录的该项属性。&#x3D;&lt;属性&gt; 指定文件或目录的该项属性。 chgrp命令功能：Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。 与 chown 命令不同，chgrp 允许普通用户改变文件所属的组，只要该用户是该组的一员。 在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录>][--version][文件或目录...] 参数： -c或–changes 效果类似”-v”参数，但仅回报更改的部分。-f或–quiet或–silent 不显示错误信息。-h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。-R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。-v或–verbose 显示指令执行过程。–help 在线帮助。–reference&#x3D;&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。–version 显示版本信息。 chgrp命令功能：Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令 Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。 文档编辑文件传输磁盘管理磁盘维护网络通讯系统管理系统设置alias命令功能：Linux alias命令用于设置指令的别名。 用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。 alias [别名] = [指令名称] 参数： 若不加任何参数，则列出目前所有的别名设置。 备份压缩设备管理","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"knowledge","slug":"linux/knowledge","permalink":"https://blog.newimg.ltd/categories/linux/knowledge/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.newimg.ltd/tags/Linux/"}]},{"title":"Week1-Linux运维总结","slug":"Week1-Linux运维总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/Week1-Linux运维总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/Week1-Linux%E8%BF%90%E7%BB%B4%E6%80%BB%E7%BB%93/","excerpt":"","text":"Day1 计算机基础计算机导论居然听懂了，链接是这部分知识点的总结。 Day2-Day6 Linux命令及部分文件管理方法Linux基础命令（链接1（内容待完善）|链接2）首先是学会使用Linux帮助文档和命令可以减少很大一部分记忆工作，其次是这部分主要学习利用系统工具或命令实现文件各种属性的查询、更改及删除。 Linux下的文件管理通过对输入及输出相关命令的学习和了解，相信对以后的脚本编写会有帮助。 学习参考链接鸟哥的Linux私房菜Linux 教程|菜鸟教程Linux下载站蓝桥云课Linux教程|W3CschoolLinux命令大全（手册）","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"knowledge","slug":"linux/knowledge","permalink":"https://blog.newimg.ltd/categories/linux/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Week2-Linux运维总结","slug":"Week2-Linux运维总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/Week2-Linux运维总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/Week2-Linux%E8%BF%90%E7%BB%B4%E6%80%BB%E7%BB%93/","excerpt":"","text":"Day1-Day3 用户和组的管理Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个唯一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 Day4-Day5 Linux Vim所有的 Linux 系统都会内置 vim 文书编辑器，其他的文书编辑器则不一定会存在。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 Day6 Java环境配置本周题目","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"knowledge","slug":"linux/knowledge","permalink":"https://blog.newimg.ltd/categories/linux/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Week3-Java总结&算法总结","slug":"Week3-Java总结&算法总结","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/Week3-Java总结&算法总结/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/Week3-Java%E6%80%BB%E7%BB%93&%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"部分资源来自温柔的养猫人，仅供学习参考。 前面的题代码链接 初识Java反射在Java语言中之所以会有如此众多的开源技术支撑，很大一部分是来自于Java最大的特征–反射机制，如果不能够灵活地去使用反射机制进行项目的开发与设计，那么可以说你并未接触到Java的精髓。所有技术实现的目标只有一点：重用性。 对于反射技术首先考虑的是“反”与“正”的操作，所谓的“正”操作指的是使用一个类的时候，一定要先导入程序所在的包，而后根据类进行对象的实例化，并依靠对象调用类中的方法。但是“反”则是根据实例化对象反推出其类型。范例：正向操作 import java.util.Date; &#x2F;&#x2F;1、导入程序所在的包.类，知道对象的出处了 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Date date&#x3D;new Date(); &#x2F;&#x2F;2、通过类产生实例化对象 System.out.println(date.getTime()); &#x2F;&#x2F;3、根据对象调用类中的方法 &#125; &#125; 执行结果： 1522630023125 如果要实现反的处理操作，那么首先要采用的就是Object类中所提供的一个方法： 获取Class对象信息：public final Class&lt;?&gt; getClass() 范例：观察Class对象的使用 import java.util.Date; &#x2F;&#x2F;1、导入程序所在的包.类，知道对象的出处了 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Date date&#x3D;new Date(); &#x2F;&#x2F;2、通过类产生实例化对象 System.out.println(date.getClass());&#x2F;&#x2F;3、根据实例化对象找到对象的所属类型 &#125; &#125; 执行结果： class java.util.Date getClass()可以帮助使用者找到对象的根源。 Class类对象的三种实例化模式反射中所有的核心操作都是通过Class类对象展开的，可以说Class类是反射操作的根源所在，但是这个类如果要想获取它的实例化对象可以采用三种方式来实现，首先来观察java.lang.Class类的定义： public final class Class&lt;T&gt; extends Object implements Serializable, GenericDeclaration, Type, AnnotatedElement 从JDK1.5开始，Class类在定义的时可以使用泛型进行标记，这样的用法主要是希望可以避免所谓的向下转型。下面通过具体的操作讲解三种实例化形式。1、【Object类支持】Object类可以根据实例化对象获取Class对象。 public final Class&lt;?&gt; getClass() class Person&#123;&#125; &#x2F;&#x2F;采用自定义的程序类 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Person per &#x3D; new Person(); &#x2F;&#x2F;已经存在有指定类的实例化对象 Class&lt;? extends Person&gt; cls &#x3D; per.getClass(); System.out.println(cls.getName()); &#x2F;&#x2F;获取的是类的完整名称 &#125; &#125; 这种方式有一个不是缺点的缺点：如果只是想获得Class类对象，则必须产生指定类对象后才可以获得。 2、【JVM直接支持】采用“类.class”的形式实例化 class Person&#123;&#125; &#x2F;&#x2F;采用自定义的程序类 public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;? extends Person&gt; cls&#x3D;Person.class; System.out.println(cls.getName()); &#x2F;&#x2F;cn.mldn.demo.Person &#125; &#125; 特点：如果想获得Class类对象，就必须导入程序所对应的开发包； 3、【Class类支持】在Class类中提供有一个static方法： 加载类：public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException package cn.mldn.vo; public class Person &#123; &#125; package cn.mldn.demo; public class JavaAPIDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls &#x3D; Class.forName(&quot;cn.mldn.vo.Person&quot;);&#x2F;&#x2F;该类必须存在 System.out.println(cls.getName()); &#x2F;&#x2F;cn.mldn.vo.Person &#125; &#125; 这种模式最大的特点：可以直接采用字符串的形式定义要使用的类型，并且程序中不需要编写任何的import语句。如果此时要使用的程序类不存在则会抛出“java.lang.ClassNotFoundException”异常。 Week3-算法总结在LeetCode做了一些偏简单的算法题😓。· 代码链接","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"图书管理系统接口说明","slug":"图书管理系统接口说明","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/图书管理系统接口说明/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E/","excerpt":"","text":"图书管理系统接口说明(Deprecated)图书管理系统接口实例https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/ 查询书籍信息分页查询书籍信息概述 该接口能获得以page和limit作为基准的数据 允许使用POST和GET两种方式的请求 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/all 参数说明 参数名 类型 描述 page int 需要第几页的数据 limit int 一页多少本书籍 数据返还&#123; \"code\": 0, \"msg\": \"\", \"count\": 1000, //书籍总数 \"data\": [&#123;&#125;, &#123;&#125;] //返还的数据 &#125; 请求样例请求https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/all?page=2&amp;limit=5 返还&#123; \"msg\": \"\", \"code\": 0, \"count\": 13, \"data\": [&#123; \"bookCounts\": 579, \"bookID\": 6, \"bookName\": \"Java编程思想（第二版）\", \"detail\": \"Java四大名著\" &#125;, &#123; \"bookCounts\": 953, \"bookID\": 7, \"bookName\": \"JAVA 2核心技术 卷I：基础知识（原书第7版）\", \"detail\": \"Java四大名著\" &#125;, &#123; \"bookCounts\": 973, \"bookID\": 8, \"bookName\": \"精通Hibernate：Java对象持久化技术详解\", \"detail\": \"本书无论对于Java开发的新手还是行家来说，都是精通Java对象持久化技术的必备实用手册。\" &#125;, &#123; \"bookCounts\": 3429, \"bookID\": 9, \"bookName\": \"Tomcat与Java Web开发技术详解\", \"detail\": \"孙老师的每一本Java著作都在广大Java爱好者中引起抢购热潮，此次推出的新著一定也不例外。\" &#125;, &#123; \"bookCounts\": 834, \"bookID\": 10, \"bookName\": \"软件加密技术内幕\", \"detail\": \"无私公开极具商业价值的加密技术，打造难以破解的软件！\" &#125;] &#125; 根据书籍id查询概述 根据书籍id查询书籍信息 使用路径获取参数id，POST、GET请求&#x3D;&#x3D;均无效&#x3D;&#x3D; 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/query 参数说明 参数名 类型 描述 id int 要查询书籍的bookID，使用路径提交 数据返还&#123; \"code\": 0, \"msg\": \"\", \"count\": 1, \"data\": [&#123;&#125;, &#123;&#125;] //返还的数据 &#125; 请求样例请求https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/query/1 返还&#123; \"msg\": \"\", \"code\": 0, \"count\": 1, \"data\": [&#123; \"bookCounts\": 1, \"bookID\": 1, \"bookName\": \"Java\", \"detail\": \"从入门到入土\" &#125;] &#125; 根据书籍名模糊查询概述 根据书籍名模糊查询 允许使用POST和GET两种方式的请求 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/queryname 参数说明 参数名 类型 描述 name String 要查询的书籍名 数据返还&#123; \"code\": 0, \"msg\": \"\", \"count\": 1, \"data\": [&#123;&#125;, &#123;&#125;] //返还的数据 &#125; 请求样例请求https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/queryname?name=my 返还&#123; \"msg\": \"\", \"code\": 0, \"count\": 1, \"data\": [&#123; \"bookCounts\": 10, \"bookID\": 2, \"bookName\": \"MySQL\", \"detail\": \"从删库到跑路\" &#125;] &#125; 增加书籍概述 增加书籍 建议使用表单提交，并使用POST方式提交 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/add 参数说明 参数名 类型 描述 bookID int 书籍ID bookName String 书籍全名 bookCounts int 书籍剩余数量 detail String 书籍详情 数据返还无 删除书籍概述 使用ID删除书籍 建议使用POST方式提交 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/delete 参数说明 参数名 类型 描述 bookID int 书籍ID 修改书籍信息概述 修改书籍信息，除ID外 建议使用POST方式提交 链接https://api.newimg.ltd/BookControllerSystemBasedBySSMFarem/book/update 参数说明 参数名 类型 描述 bookID int 书籍ID bookName String 书籍全名 bookCounts int 书籍剩余数量 detail String 书籍详情","categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"introduce","slug":"java/introduce","permalink":"https://blog.newimg.ltd/categories/java/introduce/"}],"tags":[{"name":"software","slug":"software","permalink":"https://blog.newimg.ltd/tags/software/"}]},{"title":"深入理解C语言函数","slug":"深入理解C语言函数","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/深入理解C语言函数/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","excerpt":"","text":"深入理解strcpy函数函数参数解析strcpy(目的字符数组地址, 源字符数组地址); 应用方式1int main(void) &#123; char s1[81] = \"China\"; char s2[81] = \"India\"; strcpy(s1, s2); //s2 -> s1 puts(s1); return 0; //Output:India &#125; 应用方式2int main(void) &#123; char s1[81] = \"China\"; char s2[81] = \"India\"; strcpy(s1 + 2, s2 + 1); puts(s1); return 0; //Output:chndia &#125; 函数实现void strcpy(char s1[], char s2[]) &#123; int i = 0, j = 0; while (s2[i]) &#123; s1[j++] = s2[i++]; &#125; s1[j++] = s2[i++]; return; &#125; 优化void strcpy(char s1[], char s2[]) &#123; int i = 0, j = 0; + while (s1[j++] = s2[i++]) &#123;&#125; - while (s2[i]) &#123; - s1[j++] = s2[i++]; - &#125; - s1[j++] = s2[i++]; return; &#125; 注意： 兼顾函数的高可用性和易读性 赋值表达式做条件时，先赋值，后做条件 ✦将一个顺序表作为两个顺序表使用删除一个字符串中的某个字符样例： “mydoghasabook” -&gt; “mydghasabk” 程序样例1：int main(void) &#123; char s[] = \"mydoghasabook\"; char key = 'o'; int i = 0; while (s[i]) &#123; if (s[i] - key) &#123; i++; &#125; else &#123; //删除语句 for (int j = i; s[j]; j++) &#123; s[j] = s[j + 1]; &#125; &#125; &#125; puts(s); return 0; &#125; 优化int main(void) &#123; char s[] = \"mydoghasabook\"; char key = 'o'; int i = 0; while (s[i]) &#123; if (s[i] - key) &#123; i++; &#125; else &#123; //删除语句 s[i] = 0; strcpy(s + i, s + i + 1); //strcat(s, s + i + 1); &#125; &#125; puts(s); return 0; &#125; 程序样例2int main(void) &#123; char s[] = \"mydoghasabook\"; char key = 'o'; int i = 0, j = 0; while (s[i]) &#123; if (s[i] - key) &#123; s[j++] = s[i]; &#125; i++; &#125; s[j] = 0; puts(s); return 0; &#125; 优化int main(void) &#123; char s[] = \"mydoghasabook\"; char key = 'o'; int i = 0, j = 0; while (s[j++] = s[i]) &#123; if (!(s[i++] - key)) &#123; j--; &#125; &#125; puts(s); return 0; &#125; 优化2int main(void) &#123; char s[] = \"mydoghasabook\"; char key = 'o'; int i = 0, j = 0; for (; !(s[i] - key) || (s[j++] = s[i]); i++) &#123;&#125; puts(s); return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"knowledge","slug":"c/knowledge","permalink":"https://blog.newimg.ltd/categories/c/knowledge/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"素数筛法","slug":"素数筛法","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/11/23/素数筛法/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/","excerpt":"素数筛法","text":"素数筛法 代码就放这里，解释见注释。 char pend[100000005]; int odd[7123456]; void count() &#123; int count = 1; /* 定义 */ pend[1] = 1; //特判 for (int i = 2; i * i &lt;= 100000005; i++) &#123; if (!pend[i]) &#123; for (int j = i * i; j &lt;= 100000005; j += i) &#123; pend[j] = 1; &#125; &#125; &#125; /* 线筛 */ for (int i = 1; i &lt; 100000005; i++) &#123; if (!pend[i]) &#123; odd[count++] = i; &#125; &#125; /* 储存 */ return; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"约瑟夫环","slug":"约瑟夫环","date":"2021-11-22T16:00:00.000Z","updated":"2023-09-16T15:51:01.739Z","comments":true,"path":"2021/11/23/约瑟夫环/","link":"","permalink":"https://blog.newimg.ltd/2021/11/23/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","excerpt":"","text":"问题：将顺序表看成一个环状结构 运算符：%（周期性规律） 物理上将线性表转化为环状 引入例1 设变量Today用来表示今天的星期数 变量Days表示天数 已知Days、Today求今天的星期数。 //直接上较优化的代码 #include &lt;stdio.h> int main(void) &#123; int Today, Days; puts(\"输入今天的星期数&amp;天数\"); scanf(\"%d%d\", &amp;Today, &amp;Days); printf(\"%d\\n\", (Today % 7 + Days % 7) % 7); return 0; &#125; 例2 求100的阶乘末尾0的个数 #include &lt;stdio.h> int main(void) &#123; int ans = 0; for (int i = 1; i &lt;= 100; i++) &#123; if (!(i % 5)) &#123; ans++; &#125; if (!(i % 25)) &#123; ans++; &#125; &#125; printf(\"%d\", ans); return 0; &#125; 优化： #include &lt;stdio.h> int main(void) &#123; printf(\"%d\", 100 / 5 + 100 / 25); return 0; &#125; 例3 设顺序表a长度为n = 5元素值&#123;3, 2, 5, 8, 4&#125;圈数k = 3 要求将顺序表输出k圈 #include &lt;stdio.h> int main(void) &#123; int n = 5, k = 3; int a[] = &#123;3, 2, 5, 8, 4&#125;; for (int i = 0; i &lt; k; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; printf(\"%d \", a[j]); &#125; &#125; return 0; &#125; 优化结构： #include &lt;stdio.h> int main(void) &#123; int n = 5, k = 3; int a[] = &#123;3, 2, 5, 8, 4&#125;; for (int i = 0; i &lt; k * n; i++) &#123; printf(\"%d \", a[i % n]); &#125; return 0; &#125; 约瑟夫环 有n个孩子围成一个圈，每s个孩子出圈 求孩子出圈的顺序 例情况：n = 10, s = 3 #include &lt;stdio.h> int main(void) &#123; int m = 0, n = 10, s = 3, val; val = n; int a[10] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int b[10]; for (int i = s - 1; n - 1; i = (i + s - 1) % n) &#123; b[m++] = a[i]; for (int j = i; j &lt; n - 1; j++) &#123; a[j] = a[j + 1]; &#125; n--; &#125; b[m] = a[0]; for (int i = 0; i &lt; val; i++) &#123; printf(\"%d \", b[i]); &#125; return 0; &#125; 优化： #include &lt;stdio.h> int main(void) &#123; int m = 0, n = 10, s = 3, val, temp; val = n; int a[10] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; for (int i = s - 1; n - 1; i = (i + s - 1) % n) &#123; temp = a[i]; for (int j = i; j &lt; n - 1; j++) &#123; a[j] = a[j + 1]; &#125; n--; a[n] = temp; &#125; for (int i = val - 1; i >= 0; i--) &#123; printf(\"%d \", a[i]); &#125; return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"}]},{"title":"Linux-Problem","slug":"Linux-Problem","date":"2021-02-20T16:00:00.000Z","updated":"2023-09-16T15:51:01.735Z","comments":true,"path":"2021/02/21/Linux-Problem/","link":"","permalink":"https://blog.newimg.ltd/2021/02/21/Linux-Problem/","excerpt":"部分设置PS1&#x3D;&quot;\\[\\033[1;33;1m\\][\\[\\033[1;34;1m\\]\\u@\\h:\\[\\033[0;36;1m\\]\\w\\[\\033[1;33;1m\\]]\\[\\033[1;31;1m\\]\\$ \\[\\033[1;32;0m\\]&quot;","text":"部分设置PS1&#x3D;&quot;\\[\\033[1;33;1m\\][\\[\\033[1;34;1m\\]\\u@\\h:\\[\\033[0;36;1m\\]\\w\\[\\033[1;33;1m\\]]\\[\\033[1;31;1m\\]\\$ \\[\\033[1;32;0m\\]&quot; 2021-01-251、定义别名命令baketc,每天将&#x2F;etc&#x2F;目录下所有文件，备份到&#x2F;data独立的子目录下，并要求子目录格式为backupYYYY-mm-dd,备份过程可见。 alias baketc&#x3D;&quot;&#96;mkdir &#x2F;data&#96;cp -av &#x2F;etc&#x2F; &#x2F;data&#x2F;backup&#96;date +%F&#96;&quot; 2、创建&#x2F;data&#x2F;rootdir目录， 并复制&#x2F;root下所有文件到该目录内，要求保留原有权限。 &#96;mkdir -p &#x2F;data&#x2F;rootdir&#96; cp -a &#x2F;root&#x2F;. &#x2F;data&#x2F;rootdir&#x2F; 2021-01-26rm -rf &#x2F;testdir tree &#x2F;testdir&#x2F; 1.如何创建 &#x2F;testdir&#x2F;dir1&#x2F;x, &#x2F;testdir&#x2F;dir1&#x2F;y, &#x2F;testdir&#x2F;dir1&#x2F;x&#x2F;a,&#x2F;testdir&#x2F;dir1&#x2F;x&#x2F;b, &#x2F;testdir&#x2F;dir1&#x2F;y&#x2F;a, &#x2F;testdir&#x2F;dir1&#x2F;y&#x2F;b创建后使用命令 tree &#x2F;testdir&#x2F; 显示 mkdir -pv &#x2F;testdir&#x2F;dir1&#x2F;&#123;x&#x2F;&#123;a,b&#125;,y&#x2F;&#123;a,b&#125;&#125; 2.如何创建&#x2F;testdir&#x2F;dir2&#x2F;x, &#x2F;testdir&#x2F;dir2&#x2F;y, &#x2F;testdir&#x2F;dir2&#x2F;x&#x2F;a, &#x2F;testdir&#x2F;dir2&#x2F;x&#x2F;b创建后使用命令 tree &#x2F;testdir&#x2F; 显示 mkdir -pv &#x2F;testdir&#x2F;dir2&#x2F;&#123;x&#x2F;&#123;a,b&#125;,y&#125; 2021-01-27rm -rf &#x2F;testdir tree &#x2F;testdir&#x2F; 1.计算 1+2+3..+99+100 的和 echo &#123;1..100&#125; | tr &#39; &#39; + | bc 2.如何创建 &#x2F;testdir&#x2F;dir3 , &#x2F;testdir&#x2F;dir4 , &#x2F;testdir&#x2F;dir5 , &#x2F;testdir&#x2F;dir5&#x2F;dir6 , &#x2F;testdir&#x2F;dir5&#x2F;dir7 mkdir -pv &#x2F;testdir&#x2F;dir&#123;3,4,5&#x2F;&#123;dir6,dir7&#125;&#125; 2021-01-28 1.处理字符串”xt.,I 1 jr#!$mn 2 c*&#x2F;fe 3 uz 4”，只保留其中的数字和空格. echo xt.,I 1 jr#-imn 2 c*&#x2F;fe 3 uz 4 | tr -cd [0-9]&quot; &quot;&quot;\\n&quot; 2.一个linux用户给root发邮件，要求邮件标题为 “TW” ，邮件正文如下: “ Stay hungry，Stay foolish. “ echo &quot;Stay hungry，Stay foolish.&quot; | mail -s &quot;TW&quot; root 2021-01-291.复制 &#x2F;etc&#x2F;fstab 文件到 &#x2F;var&#x2F;tmp 下，设置文件所有者为 memberone（需要新建）有读写权限，所属组为 thoughtworks（需要新建）组有读写权限，其他人无权限。 cp &#x2F;etc&#x2F;fstab &#x2F;var&#x2F;tmp&#x2F; groupadd thoughtworks useradd -g thoughtworks memberone chgrp thoughtworks fstab chown memberone fstab chmod 770 fstab userdel memberone groupdel thoughtworks rm -rf &#x2F;var&#x2F;tmp&#x2F;fstab 2.创建用户 blue ，附加组为 bin 和 root ，默认shll 为 &#x2F;bin&#x2F;csh，注释信息为”blue shine”（注：创建完成后使用命令 getent passwd blue查看注释信息；使用命令 id blue查看附加组） useradd -c &quot;blue shine&quot; -G bin,root -s &#x2F;bin&#x2F;csh blue getent passwd blue id blue userdel blue 2021-01-301.误将&#x2F;bin&#x2F;chmod文件的执行权限删除，如何恢复? chmod a-x &#x2F;bin&#x2F;chmod ll &#x2F;bin&#x2F;chmod setfacl -m user::rwx &#x2F;bin&#x2F;chmod --------------------------------- install &#x2F;bin&#x2F;chmod -m 744 &#x2F;chmod mv &#x2F;chmod &#x2F;bin&#x2F;chmod 2.取出磁盘各分区利用率，并从大到小排序 df | cut -c46-47 | sort -n df | tr -s &#39; &#39; &quot;%&quot; | cut -d% -f5 | sort -nr","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"command","slug":"linux/command","permalink":"https://blog.newimg.ltd/categories/linux/command/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.newimg.ltd/tags/Linux/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://blog.newimg.ltd/categories/java/"},{"name":"algorithm","slug":"java/algorithm","permalink":"https://blog.newimg.ltd/categories/java/algorithm/"},{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/categories/linux/"},{"name":"ssl","slug":"linux/ssl","permalink":"https://blog.newimg.ltd/categories/linux/ssl/"},{"name":"review","slug":"review","permalink":"https://blog.newimg.ltd/categories/review/"},{"name":"general","slug":"review/general","permalink":"https://blog.newimg.ltd/categories/review/general/"},{"name":"environment","slug":"environment","permalink":"https://blog.newimg.ltd/categories/environment/"},{"name":"general","slug":"environment/general","permalink":"https://blog.newimg.ltd/categories/environment/general/"},{"name":"github","slug":"github","permalink":"https://blog.newimg.ltd/categories/github/"},{"name":"action","slug":"github/action","permalink":"https://blog.newimg.ltd/categories/github/action/"},{"name":"software","slug":"software","permalink":"https://blog.newimg.ltd/categories/software/"},{"name":"introduce","slug":"software/introduce","permalink":"https://blog.newimg.ltd/categories/software/introduce/"},{"name":"c","slug":"c","permalink":"https://blog.newimg.ltd/categories/c/"},{"name":"config","slug":"c/config","permalink":"https://blog.newimg.ltd/categories/c/config/"},{"name":"sourecode","slug":"java/sourecode","permalink":"https://blog.newimg.ltd/categories/java/sourecode/"},{"name":"git","slug":"git","permalink":"https://blog.newimg.ltd/categories/git/"},{"name":"command","slug":"git/command","permalink":"https://blog.newimg.ltd/categories/git/command/"},{"name":"knowledge","slug":"java/knowledge","permalink":"https://blog.newimg.ltd/categories/java/knowledge/"},{"name":"web","slug":"web","permalink":"https://blog.newimg.ltd/categories/web/"},{"name":"custom","slug":"web/custom","permalink":"https://blog.newimg.ltd/categories/web/custom/"},{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/categories/experience/"},{"name":"linux","slug":"experience/linux","permalink":"https://blog.newimg.ltd/categories/experience/linux/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.newimg.ltd/categories/hexo/"},{"name":"backup","slug":"hexo/backup","permalink":"https://blog.newimg.ltd/categories/hexo/backup/"},{"name":"algorithm","slug":"c/algorithm","permalink":"https://blog.newimg.ltd/categories/c/algorithm/"},{"name":"thread","slug":"java/thread","permalink":"https://blog.newimg.ltd/categories/java/thread/"},{"name":"environment","slug":"java/environment","permalink":"https://blog.newimg.ltd/categories/java/environment/"},{"name":"knowledge","slug":"linux/knowledge","permalink":"https://blog.newimg.ltd/categories/linux/knowledge/"},{"name":"Test","slug":"Test","permalink":"https://blog.newimg.ltd/categories/Test/"},{"name":"knowledge","slug":"c/knowledge","permalink":"https://blog.newimg.ltd/categories/c/knowledge/"},{"name":"CPrimerPlus","slug":"c/CPrimerPlus","permalink":"https://blog.newimg.ltd/categories/c/CPrimerPlus/"},{"name":"oop","slug":"java/oop","permalink":"https://blog.newimg.ltd/categories/java/oop/"},{"name":"introduce","slug":"java/introduce","permalink":"https://blog.newimg.ltd/categories/java/introduce/"},{"name":"command","slug":"linux/command","permalink":"https://blog.newimg.ltd/categories/linux/command/"}],"tags":[{"name":"experience","slug":"experience","permalink":"https://blog.newimg.ltd/tags/experience/"},{"name":"software","slug":"software","permalink":"https://blog.newimg.ltd/tags/software/"},{"name":"learn","slug":"learn","permalink":"https://blog.newimg.ltd/tags/learn/"},{"name":"git","slug":"git","permalink":"https://blog.newimg.ltd/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://blog.newimg.ltd/tags/linux/"},{"name":"Test","slug":"Test","permalink":"https://blog.newimg.ltd/tags/Test/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.newimg.ltd/tags/Linux/"}]}